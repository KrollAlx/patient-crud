["^ ","~:output",["^ ","~:js","goog.provide('rewrite_clj.node');\n/**\n * Coerce `form` to node.\n */\nrewrite_clj.node.coerce = (function rewrite_clj$node$coerce(form){\nreturn rewrite_clj.node.protocols.coerce(form);\n});\n/**\n * Returns child nodes for `node`.\n */\nrewrite_clj.node.children = (function rewrite_clj$node$children(node){\nreturn rewrite_clj.node.protocols.children(node);\n});\n/**\n * Returns children for `node` converted to Clojure forms.\n * \n *   Optional `opts` can specify:\n *   - `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)\n */\nrewrite_clj.node.child_sexprs = (function rewrite_clj$node$child_sexprs(var_args){\nvar G__41264 = arguments.length;\nswitch (G__41264) {\ncase 1:\nreturn rewrite_clj.node.child_sexprs.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn rewrite_clj.node.child_sexprs.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(rewrite_clj.node.child_sexprs.cljs$core$IFn$_invoke$arity$1 = (function (node){\nreturn rewrite_clj.node.protocols.child_sexprs.cljs$core$IFn$_invoke$arity$1(node);\n}));\n\n(rewrite_clj.node.child_sexprs.cljs$core$IFn$_invoke$arity$2 = (function (node,opts){\nreturn rewrite_clj.node.protocols.child_sexprs.cljs$core$IFn$_invoke$arity$2(node,opts);\n}));\n\n(rewrite_clj.node.child_sexprs.cljs$lang$maxFixedArity = 2);\n\n/**\n * Returns true if `node` can have children.\n */\nrewrite_clj.node.inner_QMARK_ = (function rewrite_clj$node$inner_QMARK_(node){\nreturn rewrite_clj.node.protocols.inner_QMARK_(node);\n});\n/**\n * Returns number of characters before children for `node`.\n */\nrewrite_clj.node.leader_length = (function rewrite_clj$node$leader_length(node){\nreturn rewrite_clj.node.protocols.leader_length(node);\n});\n/**\n * Return number of characters for the string version of `node`.\n */\nrewrite_clj.node.length = (function rewrite_clj$node$length(node){\nreturn rewrite_clj.node.protocols.length(node);\n});\n/**\n * Returns true if `x` is a rewrite-clj created node.\n */\nrewrite_clj.node.node_QMARK_ = (function rewrite_clj$node$node_QMARK_(x){\nreturn rewrite_clj.node.protocols.node_QMARK_(x);\n});\n/**\n * Return true if `node` cannot be converted to an s-expression element.\n */\nrewrite_clj.node.printable_only_QMARK_ = (function rewrite_clj$node$printable_only_QMARK_(node){\nreturn rewrite_clj.node.protocols.printable_only_QMARK_(node);\n});\n/**\n * Returns `node` replacing current children with `children`.\n */\nrewrite_clj.node.replace_children = (function rewrite_clj$node$replace_children(node,children){\nreturn rewrite_clj.node.protocols.replace_children(node,children);\n});\n/**\n * Return `node` converted to form.\n * \n *   Optional `opts` can specify:\n *   - `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)\n * \n *   See docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances).\n */\nrewrite_clj.node.sexpr = (function rewrite_clj$node$sexpr(var_args){\nvar G__41271 = arguments.length;\nswitch (G__41271) {\ncase 1:\nreturn rewrite_clj.node.sexpr.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn rewrite_clj.node.sexpr.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(rewrite_clj.node.sexpr.cljs$core$IFn$_invoke$arity$1 = (function (node){\nreturn rewrite_clj.node.protocols.sexpr.cljs$core$IFn$_invoke$arity$1(node);\n}));\n\n(rewrite_clj.node.sexpr.cljs$core$IFn$_invoke$arity$2 = (function (node,opts){\nreturn rewrite_clj.node.protocols.sexpr.cljs$core$IFn$_invoke$arity$2(node,opts);\n}));\n\n(rewrite_clj.node.sexpr.cljs$lang$maxFixedArity = 2);\n\n/**\n * Return true if [[sexpr]] is supported for `node`'s element type.\n * \n * See [related docs in user guide](/doc/01-user-guide.adoc#not-all-clojure-is-sexpr-able)\n */\nrewrite_clj.node.sexpr_able_QMARK_ = (function rewrite_clj$node$sexpr_able_QMARK_(node){\nreturn rewrite_clj.node.protocols.sexpr_able_QMARK_(node);\n});\n/**\n * Return forms for `nodes`. Nodes that do not represent s-expression are skipped.\n * \n *   Optional `opts` can specify:\n *   - `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)\n * \n *   See docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances).\n */\nrewrite_clj.node.sexprs = (function rewrite_clj$node$sexprs(var_args){\nvar G__41275 = arguments.length;\nswitch (G__41275) {\ncase 1:\nreturn rewrite_clj.node.sexprs.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn rewrite_clj.node.sexprs.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(rewrite_clj.node.sexprs.cljs$core$IFn$_invoke$arity$1 = (function (nodes){\nreturn rewrite_clj.node.protocols.sexprs.cljs$core$IFn$_invoke$arity$1(nodes);\n}));\n\n(rewrite_clj.node.sexprs.cljs$core$IFn$_invoke$arity$2 = (function (nodes,opts){\nreturn rewrite_clj.node.protocols.sexprs.cljs$core$IFn$_invoke$arity$2(nodes,opts);\n}));\n\n(rewrite_clj.node.sexprs.cljs$lang$maxFixedArity = 2);\n\n/**\n * Applies `map-qualifier` context to `node`\n */\nrewrite_clj.node.map_context_apply = (function rewrite_clj$node$map_context_apply(node,map_qualifier){\nreturn rewrite_clj.node.protocols.map_context_apply(node,map_qualifier);\n});\n/**\n * Removes map-qualifier context for `node`\n */\nrewrite_clj.node.map_context_clear = (function rewrite_clj$node$map_context_clear(node){\nreturn rewrite_clj.node.protocols.map_context_clear(node);\n});\n/**\n * Return the string version of `node`.\n */\nrewrite_clj.node.string = (function rewrite_clj$node$string(node){\nreturn rewrite_clj.node.protocols.string(node);\n});\n/**\n * Returns keyword representing type of `node`.\n */\nrewrite_clj.node.tag = (function rewrite_clj$node$tag(node){\nreturn rewrite_clj.node.protocols.tag(node);\n});\n/**\n * DEPRECATED: Get first child as a pair of tag/sexpr (if inner node),\n * or just the node's own sexpr. (use explicit analysis of `children`\n * `child-sexprs` instead) \n */\nrewrite_clj.node.value = (function rewrite_clj$node$value(node){\nreturn rewrite_clj.node.protocols.value(node);\n});\n/**\n * Create node representing a comment with text `s`.\n * \n * You may optionally specify a `prefix` of `\";\"` or `\"#!\"`, defaults is `\";\"`.\n * \n * Argument `s`:\n * - must not include the `prefix`\n * - usually includes the trailing newline character, otherwise subsequent nodes will be on the comment line\n * \n * ```Clojure\n * (require '[rewrite-clj.node :as n])\n * \n * (-> (n/comment-node \"; my comment\\n\")\n *     n/string)\n * ;; => \";; my comment\\n\"\n * \n * (-> (n/comment-node \"#!\" \"/usr/bin/env bb\\n\")\n *     n/string)\n * ;; => \"#!/usr/bin/env bb\\n\"\n * ```\n */\nrewrite_clj.node.comment_node = (function rewrite_clj$node$comment_node(var_args){\nvar G__41281 = arguments.length;\nswitch (G__41281) {\ncase 1:\nreturn rewrite_clj.node.comment_node.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn rewrite_clj.node.comment_node.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(rewrite_clj.node.comment_node.cljs$core$IFn$_invoke$arity$1 = (function (s){\nreturn rewrite_clj.node.comment.comment_node.cljs$core$IFn$_invoke$arity$1(s);\n}));\n\n(rewrite_clj.node.comment_node.cljs$core$IFn$_invoke$arity$2 = (function (prefix,s){\nreturn rewrite_clj.node.comment.comment_node.cljs$core$IFn$_invoke$arity$2(prefix,s);\n}));\n\n(rewrite_clj.node.comment_node.cljs$lang$maxFixedArity = 2);\n\n/**\n * Returns true if `node` is a comment.\n */\nrewrite_clj.node.comment_QMARK_ = (function rewrite_clj$node$comment_QMARK_(node){\nreturn rewrite_clj.node.comment.comment_QMARK_(node);\n});\n/**\n * Check whether the given node represents whitespace or comment.\n */\nrewrite_clj.node.whitespace_or_comment_QMARK_ = (function rewrite_clj$node$whitespace_or_comment_QMARK_(node){\nreturn rewrite_clj.node.extras.whitespace_or_comment_QMARK_(node);\n});\n/**\n * Create node representing an anonymous function with `children`.\n * \n * ```Clojure\n * (require '[rewrite-clj.node :as n])\n * \n * (-> (n/fn-node [(n/token-node '+)\n *                 (n/spaces 1)\n *                 (n/token-node 1)\n *                 (n/spaces 1)\n *                 (n/token-node '%1)])\n *     n/string)\n * ;; => \"#(+ 1 %1)\"\n * ```\n */\nrewrite_clj.node.fn_node = (function rewrite_clj$node$fn_node(children){\nreturn rewrite_clj.node.fn.fn_node(children);\n});\n/**\n * Create top-level node wrapping multiple `children`.\n * The forms node is equivalent to an implicit `do` at the top-level.\n * \n * ```Clojure\n * (require '[rewrite-clj.node :as n])\n * \n * (-> (n/forms-node [(n/token-node 1)\n *                    (n/spaces 1)\n *                    (n/token-node 2)])\n *     n/string)\n * ;; => \"1 2\"\n * ``` \n * \n */\nrewrite_clj.node.forms_node = (function rewrite_clj$node$forms_node(children){\nreturn rewrite_clj.node.forms.forms_node(children);\n});\n/**\n * Create node representing an integer `value` in `base`.\n * \n *   `base` defaults to 10.\n * \n * ```Clojure\n * (require '[rewrite-clj.node :as n])\n * \n * (-> (n/integer-node 42)\n *     n/string)\n * ;; => \"42\"\n * \n * (-> (n/integer-node 31 2)\n *     n/string)\n * ;; => \"2r11111\"\n * ```   \n * \n * Note: the parser does not currently parse to integer-nodes, but they fully supported for output.\n */\nrewrite_clj.node.integer_node = (function rewrite_clj$node$integer_node(var_args){\nvar G__41286 = arguments.length;\nswitch (G__41286) {\ncase 1:\nreturn rewrite_clj.node.integer_node.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn rewrite_clj.node.integer_node.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(rewrite_clj.node.integer_node.cljs$core$IFn$_invoke$arity$1 = (function (value){\nreturn rewrite_clj.node.integer.integer_node.cljs$core$IFn$_invoke$arity$1(value);\n}));\n\n(rewrite_clj.node.integer_node.cljs$core$IFn$_invoke$arity$2 = (function (value,base){\nreturn rewrite_clj.node.integer.integer_node.cljs$core$IFn$_invoke$arity$2(value,base);\n}));\n\n(rewrite_clj.node.integer_node.cljs$lang$maxFixedArity = 2);\n\n/**\n * Create a node representing a keyword `k`. \n * \n * Optionally include `auto-resolved?`, which defaults to `false`.\n * \n * ```Clojure\n * (require '[rewrite-clj.node :as n]) \n * \n * ;; unqualified keyword\n * (-> (n/keyword-node :kw)\n *     n/string)\n * ;; => \":kw\"\n * \n * ;; qualified keyword\n * (-> (n/keyword-node :my-prefix/kw)\n *     n/string)\n * ;; => \":my-prefix/kw\"\n * \n * ;; keyword auto-resolved to current ns\n * (-> (n/keyword-node :kw true)\n *     n/string)\n * ;; => \"::kw\"\n * \n * ;; keyword auto-resolved to a namespace with given alias\n * (-> (n/keyword-node :ns-alias/kw true)\n *     n/string)\n * ;; => \"::ns-alias/kw\"\n * ```\n */\nrewrite_clj.node.keyword_node = (function rewrite_clj$node$keyword_node(var_args){\nvar G__41288 = arguments.length;\nswitch (G__41288) {\ncase 2:\nreturn rewrite_clj.node.keyword_node.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 1:\nreturn rewrite_clj.node.keyword_node.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(rewrite_clj.node.keyword_node.cljs$core$IFn$_invoke$arity$2 = (function (k,auto_resolved_QMARK_){\nreturn rewrite_clj.node.keyword.keyword_node.cljs$core$IFn$_invoke$arity$2(k,auto_resolved_QMARK_);\n}));\n\n(rewrite_clj.node.keyword_node.cljs$core$IFn$_invoke$arity$1 = (function (k){\nreturn rewrite_clj.node.keyword.keyword_node.cljs$core$IFn$_invoke$arity$1(k);\n}));\n\n(rewrite_clj.node.keyword_node.cljs$lang$maxFixedArity = 2);\n\n/**\n * Returns true if `n` is a node representing a keyword.\n */\nrewrite_clj.node.keyword_node_QMARK_ = (function rewrite_clj$node$keyword_node_QMARK_(n){\nreturn rewrite_clj.node.keyword.keyword_node_QMARK_(n);\n});\n/**\n * Create a node representing a form with metadata.\n * \n * When creating manually, you can specify `metadata` and `data` and spacing between the 2 elems will be included: \n * \n * ```Clojure\n * (require '[rewrite-clj.node :as n]) \n * \n * (-> (n/meta-node (n/keyword-node :foo)\n *                  (n/vector-node [(n/token-node 1)]))\n *     n/string)\n * ;; => \"^:foo [1]\"\n * \n * (-> (n/meta-node (n/map-node [:foo (n/spaces 1) 42])\n *                  (n/vector-node [(n/token-node 1)]))\n *     n/string)\n * ;; => \"^{:foo 42} [1]\"\n * ```\n * When specifying a sequence of `children`, spacing is explicit:\n * \n * ```Clojure\n * (-> (n/meta-node [(n/keyword-node :foo)\n *                   (n/spaces 1)\n *                   (n/vector-node [(n/token-node 1)])])\n *     n/string)\n * ;; => \"^:foo [1]\"\n * ```\n * See also: [[raw-meta-node]]\n */\nrewrite_clj.node.meta_node = (function rewrite_clj$node$meta_node(var_args){\nvar G__41304 = arguments.length;\nswitch (G__41304) {\ncase 1:\nreturn rewrite_clj.node.meta_node.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn rewrite_clj.node.meta_node.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(rewrite_clj.node.meta_node.cljs$core$IFn$_invoke$arity$1 = (function (children){\nreturn rewrite_clj.node.meta.meta_node.cljs$core$IFn$_invoke$arity$1(children);\n}));\n\n(rewrite_clj.node.meta_node.cljs$core$IFn$_invoke$arity$2 = (function (metadata,data){\nreturn rewrite_clj.node.meta.meta_node.cljs$core$IFn$_invoke$arity$2(metadata,data);\n}));\n\n(rewrite_clj.node.meta_node.cljs$lang$maxFixedArity = 2);\n\n/**\n * Create a node representing a form with metadata that renders to the reader syntax.\n * \n * When creating manually, you can specify `metadata` and `data` and spacing between the 2 elems will be included: \n * \n * ```Clojure\n * (require '[rewrite-clj.node :as n]) \n * \n * (-> (n/raw-meta-node (n/keyword-node :foo)\n *                      (n/vector-node [(n/token-node 2)]))\n *      n/string)\n * ;; => \"#^:foo [2]\"\n * \n * (-> (n/raw-meta-node (n/map-node [:foo (n/spaces 1) 42])\n *                      (n/vector-node [(n/token-node 2)]))\n *     n/string)\n * ;; => \"#^{:foo 42} [2]\"\n * ``` \n * When specifying a sequence of `children`, spacing is explicit:\n * \n * ```Clojure\n * (require '[rewrite-clj.node :as n]) \n * \n * (-> (n/raw-meta-node [(n/keyword-node :foo)\n *                       (n/spaces 1)\n *                       (n/vector-node [(n/token-node 2)])])\n *     n/string)\n * ;; => \"#^:foo [2]\"\n * ```\n * See also: [[meta-node]]\n */\nrewrite_clj.node.raw_meta_node = (function rewrite_clj$node$raw_meta_node(var_args){\nvar G__41310 = arguments.length;\nswitch (G__41310) {\ncase 1:\nreturn rewrite_clj.node.raw_meta_node.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn rewrite_clj.node.raw_meta_node.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(rewrite_clj.node.raw_meta_node.cljs$core$IFn$_invoke$arity$1 = (function (children){\nreturn rewrite_clj.node.meta.raw_meta_node.cljs$core$IFn$_invoke$arity$1(children);\n}));\n\n(rewrite_clj.node.raw_meta_node.cljs$core$IFn$_invoke$arity$2 = (function (metadata,data){\nreturn rewrite_clj.node.meta.raw_meta_node.cljs$core$IFn$_invoke$arity$2(metadata,data);\n}));\n\n(rewrite_clj.node.raw_meta_node.cljs$lang$maxFixedArity = 2);\n\n/**\n * Create a map qualifier node.\n * The map qualifier node is a child node of [[namespaced-map-node]].\n *   \n * ```Clojure\n * (require '[rewrite-clj.node :as n]) \n * \n * ;; qualified\n * (-> (n/map-qualifier-node false \"my-prefix\")\n *     n/string)\n * ;; => \":my-prefix\"\n * \n * ;; auto-resolved to current ns\n * (-> (n/map-qualifier-node true nil)\n *     n/string)\n * ;; => \"::\"\n * \n * ;; auto-resolve to namespace with alias\n * (-> (n/map-qualifier-node true \"my-ns-alias\")\n *     n/string)\n * ;; => \"::my-ns-alias\"\n * ```\n */\nrewrite_clj.node.map_qualifier_node = (function rewrite_clj$node$map_qualifier_node(auto_resolved_QMARK_,prefix){\nreturn rewrite_clj.node.namespaced_map.map_qualifier_node(auto_resolved_QMARK_,prefix);\n});\n/**\n * Create a namespaced map node with `children`.\n * \n * ```Clojure\n * (require '[rewrite-clj.node :as n]) \n * \n * (-> (n/namespaced-map-node [(n/map-qualifier-node true \"my-ns-alias\")\n *                             (n/spaces 1)\n *                             (n/map-node [(n/keyword-node :a)\n *                                          (n/spaces 1)\n *                                          (n/token-node 1)])])\n *     n/string)\n * ;; => \"#::my-ns-alias {:a 1}\"\n * ``` \n * \n * Map qualifier context is automatically applied to map keys for sexpr support.\n * \n * See also [[map-qualifier-node]] and [[map-node]].\n */\nrewrite_clj.node.namespaced_map_node = (function rewrite_clj$node$namespaced_map_node(children){\nreturn rewrite_clj.node.namespaced_map.namespaced_map_node(children);\n});\n/**\n * Create node representing a regex with `pattern-string`.\n * Use same escape rules for `pattern-string` as you would for `(re-pattern \"pattern-string\")`\n * \n * ```Clojure\n * (require '[rewrite-clj.node :as n])\n * \n * (-> (n/regex-node \"my\\\\.lil.*regex\")\n *     n/string)\n * ;; => \"#\\\"my\\\\.lil.*regex\\\"\"  \n * ```\n */\nrewrite_clj.node.regex_node = (function rewrite_clj$node$regex_node(pattern_string){\nreturn rewrite_clj.node.regex.regex_node(pattern_string);\n});\n/**\n * Create node representing the dereferencing of a form \n * where `children` is either a sequence of nodes or a single node.\n * \n * ```Clojure\n * (require '[rewrite-clj.node :as n])   \n * \n * (-> (n/deref-node (n/token-node 'my-var))\n *     n/string)\n * ;; => \"@my-var\"\n * \n * ;; specifying a sequence allows for whitespace between @ and form\n * (-> (n/deref-node [(n/spaces 2)\n *                    (n/token-node 'my-var)])\n *     n/string)\n * ;; => \"@  my-var\"\n * ```\n */\nrewrite_clj.node.deref_node = (function rewrite_clj$node$deref_node(children){\nreturn rewrite_clj.node.reader_macro.deref_node(children);\n});\n/**\n * Create node representing an inline evaluation\n * where `children` is either a sequence of nodes or a single node.\n * \n * ```Clojure\n * (require '[rewrite-clj.node :as n])  \n * \n * (-> (n/eval-node (n/list-node [(n/token-node 'inc)\n *                                (n/spaces 1)\n *                                (n/token-node 1)]))\n *     n/string)\n * ;; => \"#=(inc 1)\"\n * \n * ;; specifying a sequence allows for whitespace between the \n * ;; prefix and the form \n * (-> (n/eval-node [(n/spaces 3)\n *                   (n/list-node [(n/token-node 'inc)\n *                                 (n/spaces 1)\n *                                 (n/token-node 1)])])\n *     n/string)\n * ;; => \"#=   (inc 1)\"\n * ```\n */\nrewrite_clj.node.eval_node = (function rewrite_clj$node$eval_node(children){\nreturn rewrite_clj.node.reader_macro.eval_node(children);\n});\n/**\n * Create node representing a reader macro with `macro-node` and `form-node` or `children`.\n * \n * ```Clojure\n * (require '[rewrite-clj.node :as n])  \n * \n * ;; here we call with macro-node and form-node\n * (-> (n/reader-macro-node (n/token-node 'my-macro) \n *                          (n/token-node 42))\n *     n/string)\n * ;; => \"#my-macro 42\"\n * \n * ;; calling with a sequence of children gives us control over whitespace\n * (-> (n/reader-macro-node [(n/token-node 'my-macro)\n *                           (n/spaces 4)\n *                           (n/token-node 42)])\n *     n/string)\n * ;; => \"#my-macro    42\" \n * ```\n */\nrewrite_clj.node.reader_macro_node = (function rewrite_clj$node$reader_macro_node(var_args){\nvar G__41325 = arguments.length;\nswitch (G__41325) {\ncase 1:\nreturn rewrite_clj.node.reader_macro_node.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn rewrite_clj.node.reader_macro_node.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(rewrite_clj.node.reader_macro_node.cljs$core$IFn$_invoke$arity$1 = (function (children){\nreturn rewrite_clj.node.reader_macro.reader_macro_node.cljs$core$IFn$_invoke$arity$1(children);\n}));\n\n(rewrite_clj.node.reader_macro_node.cljs$core$IFn$_invoke$arity$2 = (function (macro_node,form_node){\nreturn rewrite_clj.node.reader_macro.reader_macro_node.cljs$core$IFn$_invoke$arity$2(macro_node,form_node);\n}));\n\n(rewrite_clj.node.reader_macro_node.cljs$lang$maxFixedArity = 2);\n\n/**\n * Create node representing a var where `children` is either a \n * sequence of nodes or a single node.\n * \n * ```Clojure\n * (require '[rewrite-clj.node :as n])  \n * \n * (-> (n/var-node (n/token-node 'my-var))\n *     n/string)\n * ;; => \"#'my-var\"\n * \n * ;; specifying a sequence allows for whitespace between the \n * ;; prefix and the var \n * (-> (n/var-node [(n/spaces 2)\n *                  (n/token-node 'my-var)])\n *     n/string)\n * ;; => \"#'  my-var\"\n * ```\n */\nrewrite_clj.node.var_node = (function rewrite_clj$node$var_node(children){\nreturn rewrite_clj.node.reader_macro.var_node(children);\n});\n/**\n * Create a node representing a list with `children`.\n * \n * ```Clojure\n * (require '[rewrite-clj.node :as n])\n * \n * (-> (n/list-node [(n/token-node 1)\n *                   (n/spaces 1)\n *                   (n/token-node 2)\n *                   (n/spaces 1)\n *                   (n/token-node 3)])\n *     n/string)\n * ;; => \"(1 2 3)\"\n * ```\n */\nrewrite_clj.node.list_node = (function rewrite_clj$node$list_node(children){\nreturn rewrite_clj.node.seq.list_node(children);\n});\n/**\n * Create a node representing a map with `children`.\n * ```Clojure\n * (require '[rewrite-clj.node :as n])\n * \n * (-> (n/map-node [(n/keyword-node :a)\n *                  (n/spaces 1)\n *                  (n/token-node 1)\n *                  (n/spaces 1)\n *                  (n/keyword-node :b)\n *                  (n/spaces 1)\n *                  (n/token-node 2)])\n *     (n/string))\n * ;; => \"{:a 1 :b 2}\"\n * ```\n * \n * Note that rewrite-clj allows the, technically illegal, unbalanced map:\n * ```Clojure\n * (-> (n/map-node [(n/keyword-node :a)])\n *     (n/string))\n * ;; => \"{:a}\"\n * ```\n * See [docs on unbalanced maps](/doc/01-user-guide.adoc#unbalanced-maps).\n * \n * Rewrite-clj also allows the, also technically illegal, map with duplicate keys:\n * ```Clojure\n * (-> (n/map-node [(n/keyword-node :a)\n *                  (n/spaces 1)\n *                  (n/token-node 1)\n *                  (n/spaces 1)\n *                  (n/keyword-node :a)\n *                  (n/spaces 1)\n *                  (n/token-node 2)])\n *     (n/string))\n * ;; => \"{:a 1 :a 2}\"\n * ```\n * See [docs on maps with duplicate keys](/doc/01-user-guide.adoc#maps-with-duplicate-keys).\n */\nrewrite_clj.node.map_node = (function rewrite_clj$node$map_node(children){\nreturn rewrite_clj.node.seq.map_node(children);\n});\n/**\n * Create a node representing a set with `children`.\n * \n * ```Clojure\n * (require '[rewrite-clj.node :as n])\n * \n * (-> (n/set-node [(n/token-node 1)\n *                  (n/spaces 1)\n *                  (n/token-node 2)\n *                  (n/spaces 1)\n *                  (n/token-node 3)])\n *     n/string)\n * ;; => \"#{1 2 3}\"\n * ```\n * \n * Note that rewrite-clj allows the, technically illegal, set with duplicate values:\n * ```Clojure\n * (-> (n/set-node [(n/token-node 1)\n *                  (n/spaces 1)\n *                  (n/token-node 1)])\n *     (n/string))\n * ;; => \"#{1 1}\"\n * ```\n * \n * See [docs on sets with duplicate values](/doc/01-user-guide.adoc#sets-with-duplicate-values).\n */\nrewrite_clj.node.set_node = (function rewrite_clj$node$set_node(children){\nreturn rewrite_clj.node.seq.set_node(children);\n});\n/**\n * Create a node representing a vector with `children`.\n * \n * ```Clojure\n * (require '[rewrite-clj.node :as n])\n * \n * (-> (n/vector-node [(n/token-node 1)\n *                     (n/spaces 1)\n *                     (n/token-node 2)\n *                     (n/spaces 1)\n *                     (n/token-node 3)])\n *     n/string)\n * ;; => \"[1 2 3]\"\n * ```\n */\nrewrite_clj.node.vector_node = (function rewrite_clj$node$vector_node(children){\nreturn rewrite_clj.node.seq.vector_node(children);\n});\n/**\n * Create node representing a string value where `lines` can be a sequence of strings or a single string.\n *   \n *   When `lines` is a sequence, the resulting node will `tag` will be `:multi-line`, otherwise `:token`.\n * \n *   ```Clojure\n *   (require '[rewrite-clj.node :as n])\n * \n *   (-> (n/string-node \"hello\")\n *    n/string)\n *   ;; => \"\\\"hello\\\"\"\n * \n *   (-> (n/string-node [\"line1\" \"\" \"line3\"])\n *     n/string)\n *   ;; => \"\\\"line1\\n\\nline3\\\"\"\n *   ```\n */\nrewrite_clj.node.string_node = (function rewrite_clj$node$string_node(lines){\nreturn rewrite_clj.node.stringz.string_node(lines);\n});\n/**\n * Create node representing a single quoted form where `children`\n * is either a sequence of nodes or a single node.\n * \n * ```Clojure\n * (require '[rewrite-clj.node :as n]) \n * \n * (-> (n/quote-node (n/token-node 'sym))\n *     (n/string))\n * ;; => \"'sym\"\n * \n * ;; specifying a sequence allows for whitespace between the \n * ;; quote and the quoted\n * (-> (n/quote-node [(n/spaces 10)\n *                    (n/token-node 'sym1) ])\n *     n/string)\n * ;; => \"'          sym1\"\n * ```\n */\nrewrite_clj.node.quote_node = (function rewrite_clj$node$quote_node(children){\nreturn rewrite_clj.node.quote.quote_node(children);\n});\n/**\n * Create node representing a single syntax-quoted form where `children`\n * is either a sequence of nodes or a single node.\n * \n * ```Clojure\n * (require '[rewrite-clj.node :as n]) \n * \n * (-> (n/syntax-quote-node (n/token-node 'map))\n *     n/string)\n * ;; => \"`map\"\n * \n * ;; specifying a sequence allows for whitespace between the \n * ;; syntax quote and the syntax quoted\n * (-> (n/syntax-quote-node [(n/spaces 3)\n *                           (n/token-node 'map)])\n *     n/string)\n * ;; => \"`   map\"\n * ```\n */\nrewrite_clj.node.syntax_quote_node = (function rewrite_clj$node$syntax_quote_node(children){\nreturn rewrite_clj.node.quote.syntax_quote_node(children);\n});\n/**\n * Create node representing a single unquoted form where `children`\n * is either a sequence of nodes or a single node.\n * \n * ```Clojure\n * (require '[rewrite-clj.node :as n]) \n * \n * (-> (n/unquote-node (n/token-node 'my-var))\n *     n/string)\n * ;; => \"~my-var\"\n * \n * ;; specifying a sequence allows for whitespace between the \n * ;; unquote and the uquoted\n * (-> (n/unquote-node [(n/spaces 4)\n *                      (n/token-node 'my-var)])\n *     n/string)\n * ;; => \"~    my-var\"\n * ```\n */\nrewrite_clj.node.unquote_node = (function rewrite_clj$node$unquote_node(children){\nreturn rewrite_clj.node.quote.unquote_node(children);\n});\n/**\n * Create node representing a single unquote-spliced form where `children`\n * is either a sequence of nodes or a single node.\n * \n * ```Clojure\n * (require '[rewrite-clj.node :as n]) \n * \n * (-> (n/unquote-splicing-node (n/token-node 'my-var))\n *     n/string)\n * ;; => \"~@my-var\"\n * \n * ;; specifying a sequence allows for whitespace between the \n * ;; splicing unquote and the splicing unquoted\n * (-> (n/unquote-splicing-node [(n/spaces 2)\n *                               (n/token-node 'my-var)])\n *     n/string)\n * ;; => \"~@  my-var\"   \n * ```\n */\nrewrite_clj.node.unquote_splicing_node = (function rewrite_clj$node$unquote_splicing_node(children){\nreturn rewrite_clj.node.quote.unquote_splicing_node(children);\n});\n/**\n * Create node for an unspecified token of `value`.\n * \n * ```Clojure\n * (require '[rewrite-clj.node :as n])\n * \n * (-> (n/token-node 'sym) n/string)\n * ;; => \"sym\"\n * \n * (-> (n/token-node 42) n/string)\n * ;; => \"42\"\n * ```\n */\nrewrite_clj.node.token_node = (function rewrite_clj$node$token_node(var_args){\nvar G__41345 = arguments.length;\nswitch (G__41345) {\ncase 1:\nreturn rewrite_clj.node.token_node.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn rewrite_clj.node.token_node.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(rewrite_clj.node.token_node.cljs$core$IFn$_invoke$arity$1 = (function (value){\nreturn rewrite_clj.node.token.token_node.cljs$core$IFn$_invoke$arity$1(value);\n}));\n\n(rewrite_clj.node.token_node.cljs$core$IFn$_invoke$arity$2 = (function (value,string_value){\nreturn rewrite_clj.node.token.token_node.cljs$core$IFn$_invoke$arity$2(value,string_value);\n}));\n\n(rewrite_clj.node.token_node.cljs$lang$maxFixedArity = 2);\n\n/**\n * Returns true if `n` is a node representing a symbol.\n */\nrewrite_clj.node.symbol_node_QMARK_ = (function rewrite_clj$node$symbol_node_QMARK_(n){\nreturn rewrite_clj.node.token.symbol_node_QMARK_(n);\n});\n/**\n * Create node representing an unevaled form with `children`.\n * \n * ```Clojure\n * (require '[rewrite-clj.node :as n])\n * \n * (-> (n/uneval-node [(n/spaces 1)\n *                     (n/token-node 42)])\n *     n/string)\n * ;; => \"#_ 42\"\n * ```\n */\nrewrite_clj.node.uneval_node = (function rewrite_clj$node$uneval_node(children){\nreturn rewrite_clj.node.uneval.uneval_node(children);\n});\n/**\n * Interleave `nodes` with `\", \"` nodes.\n */\nrewrite_clj.node.comma_separated = (function rewrite_clj$node$comma_separated(nodes){\nreturn rewrite_clj.node.whitespace.comma_separated(nodes);\n});\n/**\n * Interleave `nodes` with newline nodes.\n */\nrewrite_clj.node.line_separated = (function rewrite_clj$node$line_separated(nodes){\nreturn rewrite_clj.node.whitespace.line_separated(nodes);\n});\n/**\n * Returns true if `node` represents one or more linebreaks.\n */\nrewrite_clj.node.linebreak_QMARK_ = (function rewrite_clj$node$linebreak_QMARK_(node){\nreturn rewrite_clj.node.whitespace.linebreak_QMARK_(node);\n});\n/**\n * Create node representing `n` newline characters.\n */\nrewrite_clj.node.newlines = (function rewrite_clj$node$newlines(n){\nreturn rewrite_clj.node.whitespace.newlines(n);\n});\n/**\n * Create newline node of string `s`, where `s` is one or more linebreak characters.\n */\nrewrite_clj.node.newline_node = (function rewrite_clj$node$newline_node(s){\nreturn rewrite_clj.node.whitespace.newline_node(s);\n});\n/**\n * Create node representing `n` spaces.\n */\nrewrite_clj.node.spaces = (function rewrite_clj$node$spaces(n){\nreturn rewrite_clj.node.whitespace.spaces(n);\n});\n/**\n * Create whitespace node of string `s`, where `s` is one or more space characters.\n */\nrewrite_clj.node.whitespace_node = (function rewrite_clj$node$whitespace_node(s){\nreturn rewrite_clj.node.whitespace.whitespace_node(s);\n});\n/**\n * Returns true if `node` represents Clojure whitespace.\n */\nrewrite_clj.node.whitespace_QMARK_ = (function rewrite_clj$node$whitespace_QMARK_(node){\nreturn rewrite_clj.node.whitespace.whitespace_QMARK_(node);\n});\n/**\n * Create comma node of string `s`, where `s` is one or more comma characters.\n */\nrewrite_clj.node.comma_node = (function rewrite_clj$node$comma_node(s){\nreturn rewrite_clj.node.whitespace.comma_node(s);\n});\n/**\n * Returns true if `node` represents one or more commas.\n */\nrewrite_clj.node.comma_QMARK_ = (function rewrite_clj$node$comma_QMARK_(node){\nreturn rewrite_clj.node.whitespace.comma_QMARK_(node);\n});\n/**\n * Convert string `s` of whitespace to whitespace/newline nodes.\n */\nrewrite_clj.node.whitespace_nodes = (function rewrite_clj$node$whitespace_nodes(s){\nreturn rewrite_clj.node.whitespace.whitespace_nodes(s);\n});\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:doc","Create, update, convert and integorate nodes.\n\n  All nodes represent Clojure/ClojureScript/EDN.\n\n  Because this API contains many functions, we offer the following categorized listing:\n\n  **Node creation**\n  [[comma-node]]\n  [[comment-node]]\n  [[deref-node]]\n  [[eval-node]]\n  [[fn-node]]\n  [[forms-node]]\n  [[integer-node]]\n  [[keyword-node]]\n  [[map-node]]\n  [[map-qualifier-node]]\n  [[meta-node]]\n  [[namespaced-map-node]]\n  [[newline-node]]\n  [[quote-node]]\n  [[raw-meta-node]]\n  [[reader-macro-node]]\n  [[regex-node]]\n  [[set-node]]\n  [[string-node]]\n  [[syntax-quote-node]]\n  [[token-node]]\n  [[uneval-node]]\n  [[unquote-node]]\n  [[unquote-splicing-node]]\n  [[var-node]]\n  [[vector-node]]\n  [[whitespace-node]]\n\n  **Whitespace creation convenience**\n  [[spaces]]\n  [[newlines]]\n  [[comma-separated]]\n  [[line-separated]]\n  [[whitespace-nodes]]\n\n  **Convert form to node**\n  [[coerce]]\n\n  **Convert node to form**\n  [[sexpr-able?]]\n  [[sexpr]]\n  [[sexprs]]\n  [[child-sexprs]]\n\n  **Convert node to string**\n  [[string]]\n\n  **Node interogation**\n  [[tag]]\n  [[inner?]]\n  [[children]]\n  [[length]]\n  [[leader-length]]\n  [[printable-only?]]\n\n  **Update node**\n  [[replace-children]]\n\n  **Namespaced map element support**\n  [[map-context-apply]]\n  [[map-context-clear]]\n\n  **Test type**\n  [[node?]]\n  [[comment?]]\n  [[whitespace-or-comment?]]\n  [[keyword-node?]]\n  [[symbol-node?]]\n  [[linebreak?]]\n  [[comma?]]","~:file","rewrite_clj/node.cljc","~:line",2,"~:column",5,"~:end-line",2,"~:end-column",21],"~:ns-aliases",["^ ","~$clojure.spec.alpha","~$cljs.spec.alpha","~$clojure.tools.reader.impl.utils","~$cljs.tools.reader.impl.utils","~$cljs.loader","~$shadow.loader","~$clojure.tools.reader.impl.commons","~$cljs.tools.reader.impl.commons","~$clojure.tools.reader.impl.errors","~$cljs.tools.reader.impl.errors","~$react","~$module$node_modules$react$index","~$clojure.tools.reader.reader-types","~$cljs.tools.reader.reader-types","~$clojure.tools.reader.edn","~$cljs.tools.reader.edn","~$clojure.pprint","~$cljs.pprint","~$react-dom","~$module$node_modules$react_dom$index","~$clojure.repl","~$cljs.repl"],"~:use-macros",null,"~:excludes",["~#set",["~$string","~$coerce"]],"~:name","~$rewrite-clj.node","~:reader-aliases",["^ "],"~:op","~:ns","~:imports",null,"~:requires",["^ ","~$rewrite-clj.node.stringz","^13","~$rewrite-clj.node.meta","^14","~$rewrite-clj.node.integer","^15","~$rewrite-clj.node.token","^16","~$rewrite-clj.node.seq","^17","~$rewrite-clj.node.extras","^18","~$cljs.core","^19","~$goog","^1:","~$rewrite-clj.node.fn","^1;","~$rewrite-clj.node.reader-macro","^1<","~$rewrite-clj.node.keyword","^1=","~$rewrite-clj.node.comment","^1>","~$rewrite-clj.node.quote","^1?","~$rewrite-clj.node.protocols","^1@","~$rewrite-clj.node.uneval","^1A","~$rewrite-clj.node.regex","^1B","~$rewrite-clj.node.whitespace","^1C","~$rewrite-clj.node.namespaced-map","^1D","~$rewrite-clj.node.forms","^1E","~$rewrite-clj.node.coercer","^1F"],"~:seen",["^U",["~:require"]],"~:uses",null,"~:require-macros",["^ ","^19","^19","^1C","^1C"],"~:form",["~#list",["~$ns","^Y","Create, update, convert and integorate nodes.\n\n  All nodes represent Clojure/ClojureScript/EDN.\n\n  Because this API contains many functions, we offer the following categorized listing:\n\n  **Node creation**\n  [[comma-node]]\n  [[comment-node]]\n  [[deref-node]]\n  [[eval-node]]\n  [[fn-node]]\n  [[forms-node]]\n  [[integer-node]]\n  [[keyword-node]]\n  [[map-node]]\n  [[map-qualifier-node]]\n  [[meta-node]]\n  [[namespaced-map-node]]\n  [[newline-node]]\n  [[quote-node]]\n  [[raw-meta-node]]\n  [[reader-macro-node]]\n  [[regex-node]]\n  [[set-node]]\n  [[string-node]]\n  [[syntax-quote-node]]\n  [[token-node]]\n  [[uneval-node]]\n  [[unquote-node]]\n  [[unquote-splicing-node]]\n  [[var-node]]\n  [[vector-node]]\n  [[whitespace-node]]\n\n  **Whitespace creation convenience**\n  [[spaces]]\n  [[newlines]]\n  [[comma-separated]]\n  [[line-separated]]\n  [[whitespace-nodes]]\n\n  **Convert form to node**\n  [[coerce]]\n\n  **Convert node to form**\n  [[sexpr-able?]]\n  [[sexpr]]\n  [[sexprs]]\n  [[child-sexprs]]\n\n  **Convert node to string**\n  [[string]]\n\n  **Node interogation**\n  [[tag]]\n  [[inner?]]\n  [[children]]\n  [[length]]\n  [[leader-length]]\n  [[printable-only?]]\n\n  **Update node**\n  [[replace-children]]\n\n  **Namespaced map element support**\n  [[map-context-apply]]\n  [[map-context-clear]]\n\n  **Test type**\n  [[node?]]\n  [[comment?]]\n  [[whitespace-or-comment?]]\n  [[keyword-node?]]\n  [[symbol-node?]]\n  [[linebreak?]]\n  [[comma?]]",["^1L",["~:refer-clojure","~:exclude",["^V","^W"]]],["^1L",["^1H",["^1F"],["^1>"],["^18"],["^1;"],["^1E"],["^15"],["^1="],["^14"],["^1D"],["^1@"],["^1?"],["^1<"],["^1B"],["^17"],["^13"],["^16"],["^1A"],["^1C"]]]]],"~:flags",["^ ","^1H",["^U",[]]],"~:js-deps",["^ "],"~:deps",["^1:","^19","^1F","^1>","^18","^1;","^1E","^15","^1=","^14","^1D","^1@","^1?","^1<","^1B","^17","^13","^16","^1A","^1C"]],"^10","^Y","~:resource-id",["~:shadow.build.classpath/resource","rewrite_clj/node.cljc"],"~:compiled-at",1666857667045,"^Z",["^ ","^13","^13","^14","^14","^15","^15","^16","^16","^17","^17","^18","^18","^19","^19","^1:","^1:","^1;","^1;","^1<","^1<","^1=","^1=","^1>","^1>","^1?","^1?","^1@","^1@","^1A","^1A","^1B","^1B","^1C","^1C","^1D","^1D","^1E","^1E","^1F","^1F"],"~:resource-name","rewrite_clj/node.cljc","~:warnings",[],"~:source",";; DO NOT EDIT FILE, automatically generated from: ./template/rewrite_clj/node.cljc\n(ns rewrite-clj.node\n  \"Create, update, convert and integorate nodes.\n\n  All nodes represent Clojure/ClojureScript/EDN.\n\n  Because this API contains many functions, we offer the following categorized listing:\n\n  **Node creation**\n  [[comma-node]]\n  [[comment-node]]\n  [[deref-node]]\n  [[eval-node]]\n  [[fn-node]]\n  [[forms-node]]\n  [[integer-node]]\n  [[keyword-node]]\n  [[map-node]]\n  [[map-qualifier-node]]\n  [[meta-node]]\n  [[namespaced-map-node]]\n  [[newline-node]]\n  [[quote-node]]\n  [[raw-meta-node]]\n  [[reader-macro-node]]\n  [[regex-node]]\n  [[set-node]]\n  [[string-node]]\n  [[syntax-quote-node]]\n  [[token-node]]\n  [[uneval-node]]\n  [[unquote-node]]\n  [[unquote-splicing-node]]\n  [[var-node]]\n  [[vector-node]]\n  [[whitespace-node]]\n\n  **Whitespace creation convenience**\n  [[spaces]]\n  [[newlines]]\n  [[comma-separated]]\n  [[line-separated]]\n  [[whitespace-nodes]]\n\n  **Convert form to node**\n  [[coerce]]\n\n  **Convert node to form**\n  [[sexpr-able?]]\n  [[sexpr]]\n  [[sexprs]]\n  [[child-sexprs]]\n\n  **Convert node to string**\n  [[string]]\n\n  **Node interogation**\n  [[tag]]\n  [[inner?]]\n  [[children]]\n  [[length]]\n  [[leader-length]]\n  [[printable-only?]]\n\n  **Update node**\n  [[replace-children]]\n\n  **Namespaced map element support**\n  [[map-context-apply]]\n  [[map-context-clear]]\n\n  **Test type**\n  [[node?]]\n  [[comment?]]\n  [[whitespace-or-comment?]]\n  [[keyword-node?]]\n  [[symbol-node?]]\n  [[linebreak?]]\n  [[comma?]]\"\n  ^{:added \"0.4.0\"}\n  (:refer-clojure :exclude [string coerce])\n  (:require [rewrite-clj.node.coercer]\n            [rewrite-clj.node.comment]\n            [rewrite-clj.node.extras]\n            [rewrite-clj.node.fn]\n            [rewrite-clj.node.forms]\n            [rewrite-clj.node.integer]\n            [rewrite-clj.node.keyword]\n            [rewrite-clj.node.meta]\n            [rewrite-clj.node.namespaced-map]\n            [rewrite-clj.node.protocols]\n            [rewrite-clj.node.quote]\n            [rewrite-clj.node.reader-macro]\n            [rewrite-clj.node.regex]\n            [rewrite-clj.node.seq]\n            [rewrite-clj.node.stringz]\n            [rewrite-clj.node.token]\n            [rewrite-clj.node.uneval]\n            [rewrite-clj.node.whitespace]))\n\n#?(:clj (set! *warn-on-reflection* true))\n\n;; ## API Facade\n\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.protocols\n(defn coerce\n  \"Coerce `form` to node.\"\n  [form] (rewrite-clj.node.protocols/coerce form))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.protocols\n(defn children\n  \"Returns child nodes for `node`.\"\n  [node] (rewrite-clj.node.protocols/children node))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.protocols\n(defn child-sexprs\n  \"Returns children for `node` converted to Clojure forms.\n\n  Optional `opts` can specify:\n  - `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)\"\n  ([node] (rewrite-clj.node.protocols/child-sexprs node))\n  ([node opts] (rewrite-clj.node.protocols/child-sexprs node opts)))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.protocols\n(defn inner?\n  \"Returns true if `node` can have children.\"\n  [node] (rewrite-clj.node.protocols/inner? node))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.protocols\n(defn leader-length\n  \"Returns number of characters before children for `node`.\"\n  [node] (rewrite-clj.node.protocols/leader-length node))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.protocols\n(defn length\n  \"Return number of characters for the string version of `node`.\"\n  [node] (rewrite-clj.node.protocols/length node))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.protocols\n(defn node?\n  \"Returns true if `x` is a rewrite-clj created node.\"\n  [x] (rewrite-clj.node.protocols/node? x))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.protocols\n(defn printable-only?\n  \"Return true if `node` cannot be converted to an s-expression element.\"\n  [node] (rewrite-clj.node.protocols/printable-only? node))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.protocols\n(defn replace-children\n  \"Returns `node` replacing current children with `children`.\"\n  [node children] (rewrite-clj.node.protocols/replace-children node children))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.protocols\n(defn sexpr\n  \"Return `node` converted to form.\n\n  Optional `opts` can specify:\n  - `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)\n\n  See docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances).\"\n  ([node] (rewrite-clj.node.protocols/sexpr node))\n  ([node opts] (rewrite-clj.node.protocols/sexpr node opts)))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.protocols\n(defn sexpr-able?\n  \"Return true if [[sexpr]] is supported for `node`'s element type.\n\n   See [related docs in user guide](/doc/01-user-guide.adoc#not-all-clojure-is-sexpr-able)\"\n  [node] (rewrite-clj.node.protocols/sexpr-able? node))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.protocols\n(defn sexprs\n  \"Return forms for `nodes`. Nodes that do not represent s-expression are skipped.\n\n  Optional `opts` can specify:\n  - `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)\n\n  See docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances).\"\n  ([nodes] (rewrite-clj.node.protocols/sexprs nodes))\n  ([nodes opts] (rewrite-clj.node.protocols/sexprs nodes opts)))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.protocols\n(defn map-context-apply\n  \"Applies `map-qualifier` context to `node`\"\n  [node map-qualifier] (rewrite-clj.node.protocols/map-context-apply node map-qualifier))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.protocols\n(defn map-context-clear\n  \"Removes map-qualifier context for `node`\"\n  [node] (rewrite-clj.node.protocols/map-context-clear node))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.protocols\n(defn string\n  \"Return the string version of `node`.\"\n  [node] (rewrite-clj.node.protocols/string node))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.protocols\n(defn tag\n  \"Returns keyword representing type of `node`.\"\n  [node] (rewrite-clj.node.protocols/tag node))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.protocols\n(defn ^{:deprecated \"0.4.0\"} value\n  \"DEPRECATED: Get first child as a pair of tag/sexpr (if inner node),\n   or just the node's own sexpr. (use explicit analysis of `children`\n   `child-sexprs` instead) \"\n  [node] (rewrite-clj.node.protocols/value node))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.comment\n(defn comment-node\n  \"Create node representing a comment with text `s`.\n\n   You may optionally specify a `prefix` of `\\\";\\\"` or `\\\"#!\\\"`, defaults is `\\\";\\\"`.\n\n   Argument `s`:\n   - must not include the `prefix`\n   - usually includes the trailing newline character, otherwise subsequent nodes will be on the comment line\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/comment-node \\\"; my comment\\\\n\\\")\n       n/string)\n   ;; => \\\";; my comment\\\\n\\\"\n\n   (-> (n/comment-node \\\"#!\\\" \\\"/usr/bin/env bb\\\\n\\\")\n       n/string)\n   ;; => \\\"#!/usr/bin/env bb\\\\n\\\"\n   ```\"\n  ([s] (rewrite-clj.node.comment/comment-node s))\n  ([prefix s] (rewrite-clj.node.comment/comment-node prefix s)))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.comment\n(defn comment?\n  \"Returns true if `node` is a comment.\"\n  [node] (rewrite-clj.node.comment/comment? node))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.extras\n(defn whitespace-or-comment?\n  \"Check whether the given node represents whitespace or comment.\"\n  [node] (rewrite-clj.node.extras/whitespace-or-comment? node))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.fn\n(defn fn-node\n  \"Create node representing an anonymous function with `children`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/fn-node [(n/token-node '+)\n                   (n/spaces 1)\n                   (n/token-node 1)\n                   (n/spaces 1)\n                   (n/token-node '%1)])\n       n/string)\n   ;; => \\\"#(+ 1 %1)\\\"\n   ```\"\n  [children] (rewrite-clj.node.fn/fn-node children))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.forms\n(defn forms-node\n  \"Create top-level node wrapping multiple `children`.\n   The forms node is equivalent to an implicit `do` at the top-level.\n   \n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/forms-node [(n/token-node 1)\n                      (n/spaces 1)\n                      (n/token-node 2)])\n       n/string)\n   ;; => \\\"1 2\\\"\n   ``` \n   \"\n  [children] (rewrite-clj.node.forms/forms-node children))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.integer\n(defn integer-node\n  \"Create node representing an integer `value` in `base`.\n\n  `base` defaults to 10.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/integer-node 42)\n       n/string)\n   ;; => \\\"42\\\"\n\n   (-> (n/integer-node 31 2)\n       n/string)\n   ;; => \\\"2r11111\\\"\n   ```   \n\n   Note: the parser does not currently parse to integer-nodes, but they fully supported for output.\"\n  ([value] (rewrite-clj.node.integer/integer-node value))\n  ([value base] (rewrite-clj.node.integer/integer-node value base)))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.keyword\n(defn keyword-node\n  \"Create a node representing a keyword `k`. \n\n   Optionally include `auto-resolved?`, which defaults to `false`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n]) \n\n   ;; unqualified keyword\n   (-> (n/keyword-node :kw)\n       n/string)\n   ;; => \\\":kw\\\"\n\n   ;; qualified keyword\n   (-> (n/keyword-node :my-prefix/kw)\n       n/string)\n   ;; => \\\":my-prefix/kw\\\"\n\n   ;; keyword auto-resolved to current ns\n   (-> (n/keyword-node :kw true)\n       n/string)\n   ;; => \\\"::kw\\\"\n\n   ;; keyword auto-resolved to a namespace with given alias\n   (-> (n/keyword-node :ns-alias/kw true)\n       n/string)\n   ;; => \\\"::ns-alias/kw\\\"\n   ```\"\n  ([k auto-resolved?] (rewrite-clj.node.keyword/keyword-node k auto-resolved?))\n  ([k] (rewrite-clj.node.keyword/keyword-node k)))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.keyword\n(defn keyword-node?\n  \"Returns true if `n` is a node representing a keyword.\"\n  [n] (rewrite-clj.node.keyword/keyword-node? n))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.meta\n(defn meta-node\n  \"Create a node representing a form with metadata.\n\n   When creating manually, you can specify `metadata` and `data` and spacing between the 2 elems will be included: \n\n   ```Clojure\n   (require '[rewrite-clj.node :as n]) \n\n   (-> (n/meta-node (n/keyword-node :foo)\n                    (n/vector-node [(n/token-node 1)]))\n       n/string)\n   ;; => \\\"^:foo [1]\\\"\n\n   (-> (n/meta-node (n/map-node [:foo (n/spaces 1) 42])\n                    (n/vector-node [(n/token-node 1)]))\n       n/string)\n   ;; => \\\"^{:foo 42} [1]\\\"\n   ```\n   When specifying a sequence of `children`, spacing is explicit:\n\n   ```Clojure\n   (-> (n/meta-node [(n/keyword-node :foo)\n                     (n/spaces 1)\n                     (n/vector-node [(n/token-node 1)])])\n       n/string)\n   ;; => \\\"^:foo [1]\\\"\n   ```\n   See also: [[raw-meta-node]]\"\n  ([children] (rewrite-clj.node.meta/meta-node children))\n  ([metadata data] (rewrite-clj.node.meta/meta-node metadata data)))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.meta\n(defn raw-meta-node\n  \"Create a node representing a form with metadata that renders to the reader syntax.\n   \n   When creating manually, you can specify `metadata` and `data` and spacing between the 2 elems will be included: \n\n   ```Clojure\n   (require '[rewrite-clj.node :as n]) \n\n   (-> (n/raw-meta-node (n/keyword-node :foo)\n                        (n/vector-node [(n/token-node 2)]))\n        n/string)\n   ;; => \\\"#^:foo [2]\\\"\n   \n   (-> (n/raw-meta-node (n/map-node [:foo (n/spaces 1) 42])\n                        (n/vector-node [(n/token-node 2)]))\n       n/string)\n   ;; => \\\"#^{:foo 42} [2]\\\"\n   ``` \n   When specifying a sequence of `children`, spacing is explicit:\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n]) \n   \n   (-> (n/raw-meta-node [(n/keyword-node :foo)\n                         (n/spaces 1)\n                         (n/vector-node [(n/token-node 2)])])\n       n/string)\n   ;; => \\\"#^:foo [2]\\\"\n   ```\n   See also: [[meta-node]]\"\n  ([children] (rewrite-clj.node.meta/raw-meta-node children))\n  ([metadata data] (rewrite-clj.node.meta/raw-meta-node metadata data)))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.namespaced-map\n(defn map-qualifier-node\n  \"Create a map qualifier node.\n   The map qualifier node is a child node of [[namespaced-map-node]].\n     \n   ```Clojure\n   (require '[rewrite-clj.node :as n]) \n   \n   ;; qualified\n   (-> (n/map-qualifier-node false \\\"my-prefix\\\")\n       n/string)\n   ;; => \\\":my-prefix\\\"\n\n   ;; auto-resolved to current ns\n   (-> (n/map-qualifier-node true nil)\n       n/string)\n   ;; => \\\"::\\\"\n\n   ;; auto-resolve to namespace with alias\n   (-> (n/map-qualifier-node true \\\"my-ns-alias\\\")\n       n/string)\n   ;; => \\\"::my-ns-alias\\\"\n   ```\"\n  [auto-resolved? prefix] (rewrite-clj.node.namespaced-map/map-qualifier-node auto-resolved? prefix))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.namespaced-map\n(defn namespaced-map-node\n  \"Create a namespaced map node with `children`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n]) \n   \n   (-> (n/namespaced-map-node [(n/map-qualifier-node true \\\"my-ns-alias\\\")\n                               (n/spaces 1)\n                               (n/map-node [(n/keyword-node :a)\n                                            (n/spaces 1)\n                                            (n/token-node 1)])])\n       n/string)\n   ;; => \\\"#::my-ns-alias {:a 1}\\\"\n   ``` \n   \n   Map qualifier context is automatically applied to map keys for sexpr support.\n\n   See also [[map-qualifier-node]] and [[map-node]].\"\n  [children] (rewrite-clj.node.namespaced-map/namespaced-map-node children))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.regex\n(defn regex-node\n  \"Create node representing a regex with `pattern-string`.\n   Use same escape rules for `pattern-string` as you would for `(re-pattern \\\"pattern-string\\\")`\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/regex-node \\\"my\\\\\\\\.lil.*regex\\\")\n       n/string)\n   ;; => \\\"#\\\\\\\"my\\\\\\\\.lil.*regex\\\\\\\"\\\"  \n   ```\"\n  [pattern-string] (rewrite-clj.node.regex/regex-node pattern-string))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.reader-macro\n(defn deref-node\n  \"Create node representing the dereferencing of a form \n   where `children` is either a sequence of nodes or a single node.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])   \n\n   (-> (n/deref-node (n/token-node 'my-var))\n       n/string)\n   ;; => \\\"@my-var\\\"\n\n   ;; specifying a sequence allows for whitespace between @ and form\n   (-> (n/deref-node [(n/spaces 2)\n                      (n/token-node 'my-var)])\n       n/string)\n   ;; => \\\"@  my-var\\\"\n   ```\"\n  [children] (rewrite-clj.node.reader-macro/deref-node children))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.reader-macro\n(defn eval-node\n  \"Create node representing an inline evaluation\n   where `children` is either a sequence of nodes or a single node.\n   \n   ```Clojure\n   (require '[rewrite-clj.node :as n])  \n\n   (-> (n/eval-node (n/list-node [(n/token-node 'inc)\n                                  (n/spaces 1)\n                                  (n/token-node 1)]))\n       n/string)\n   ;; => \\\"#=(inc 1)\\\"\n\n   ;; specifying a sequence allows for whitespace between the \n   ;; prefix and the form \n   (-> (n/eval-node [(n/spaces 3)\n                     (n/list-node [(n/token-node 'inc)\n                                   (n/spaces 1)\n                                   (n/token-node 1)])])\n       n/string)\n   ;; => \\\"#=   (inc 1)\\\"\n   ```\"\n  [children] (rewrite-clj.node.reader-macro/eval-node children))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.reader-macro\n(defn reader-macro-node\n  \"Create node representing a reader macro with `macro-node` and `form-node` or `children`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])  \n\n   ;; here we call with macro-node and form-node\n   (-> (n/reader-macro-node (n/token-node 'my-macro) \n                            (n/token-node 42))\n       n/string)\n   ;; => \\\"#my-macro 42\\\"\n\n   ;; calling with a sequence of children gives us control over whitespace\n   (-> (n/reader-macro-node [(n/token-node 'my-macro)\n                             (n/spaces 4)\n                             (n/token-node 42)])\n       n/string)\n   ;; => \\\"#my-macro    42\\\" \n   ```\"\n  ([children] (rewrite-clj.node.reader-macro/reader-macro-node children))\n  ([macro-node form-node] (rewrite-clj.node.reader-macro/reader-macro-node macro-node form-node)))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.reader-macro\n(defn var-node\n  \"Create node representing a var where `children` is either a \n   sequence of nodes or a single node.\n   \n   ```Clojure\n   (require '[rewrite-clj.node :as n])  \n\n   (-> (n/var-node (n/token-node 'my-var))\n       n/string)\n   ;; => \\\"#'my-var\\\"\n\n   ;; specifying a sequence allows for whitespace between the \n   ;; prefix and the var \n   (-> (n/var-node [(n/spaces 2)\n                    (n/token-node 'my-var)])\n       n/string)\n   ;; => \\\"#'  my-var\\\"\n   ```\"\n  [children] (rewrite-clj.node.reader-macro/var-node children))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.seq\n(defn list-node\n  \"Create a node representing a list with `children`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/list-node [(n/token-node 1)\n                     (n/spaces 1)\n                     (n/token-node 2)\n                     (n/spaces 1)\n                     (n/token-node 3)])\n       n/string)\n   ;; => \\\"(1 2 3)\\\"\n   ```\"\n  [children] (rewrite-clj.node.seq/list-node children))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.seq\n(defn map-node\n  \"Create a node representing a map with `children`.\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/map-node [(n/keyword-node :a)\n                    (n/spaces 1)\n                    (n/token-node 1)\n                    (n/spaces 1)\n                    (n/keyword-node :b)\n                    (n/spaces 1)\n                    (n/token-node 2)])\n       (n/string))\n   ;; => \\\"{:a 1 :b 2}\\\"\n   ```\n\n   Note that rewrite-clj allows the, technically illegal, unbalanced map:\n   ```Clojure\n   (-> (n/map-node [(n/keyword-node :a)])\n       (n/string))\n   ;; => \\\"{:a}\\\"\n   ```\n   See [docs on unbalanced maps](/doc/01-user-guide.adoc#unbalanced-maps).\n\n   Rewrite-clj also allows the, also technically illegal, map with duplicate keys:\n   ```Clojure\n   (-> (n/map-node [(n/keyword-node :a)\n                    (n/spaces 1)\n                    (n/token-node 1)\n                    (n/spaces 1)\n                    (n/keyword-node :a)\n                    (n/spaces 1)\n                    (n/token-node 2)])\n       (n/string))\n   ;; => \\\"{:a 1 :a 2}\\\"\n   ```\n   See [docs on maps with duplicate keys](/doc/01-user-guide.adoc#maps-with-duplicate-keys).\"\n  [children] (rewrite-clj.node.seq/map-node children))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.seq\n(defn set-node\n  \"Create a node representing a set with `children`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/set-node [(n/token-node 1)\n                    (n/spaces 1)\n                    (n/token-node 2)\n                    (n/spaces 1)\n                    (n/token-node 3)])\n       n/string)\n   ;; => \\\"#{1 2 3}\\\"\n   ```\n\n   Note that rewrite-clj allows the, technically illegal, set with duplicate values:\n   ```Clojure\n   (-> (n/set-node [(n/token-node 1)\n                    (n/spaces 1)\n                    (n/token-node 1)])\n       (n/string))\n   ;; => \\\"#{1 1}\\\"\n   ```\n\n   See [docs on sets with duplicate values](/doc/01-user-guide.adoc#sets-with-duplicate-values).\"\n  [children] (rewrite-clj.node.seq/set-node children))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.seq\n(defn vector-node\n  \"Create a node representing a vector with `children`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/vector-node [(n/token-node 1)\n                       (n/spaces 1)\n                       (n/token-node 2)\n                       (n/spaces 1)\n                       (n/token-node 3)])\n       n/string)\n   ;; => \\\"[1 2 3]\\\"\n   ```\"\n  [children] (rewrite-clj.node.seq/vector-node children))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.stringz\n(defn string-node\n  \"Create node representing a string value where `lines` can be a sequence of strings or a single string.\n  \n  When `lines` is a sequence, the resulting node will `tag` will be `:multi-line`, otherwise `:token`.\n   \n  ```Clojure\n  (require '[rewrite-clj.node :as n])\n\n  (-> (n/string-node \\\"hello\\\")\n      n/string)\n  ;; => \\\"\\\\\\\"hello\\\\\\\"\\\"\n\n  (-> (n/string-node [\\\"line1\\\" \\\"\\\" \\\"line3\\\"])\n       n/string)\n  ;; => \\\"\\\\\\\"line1\\\\n\\\\nline3\\\\\\\"\\\"\n  ```\"\n  [lines] (rewrite-clj.node.stringz/string-node lines))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.quote\n(defn quote-node\n  \"Create node representing a single quoted form where `children`\n   is either a sequence of nodes or a single node.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n]) \n\n   (-> (n/quote-node (n/token-node 'sym))\n       (n/string))\n   ;; => \\\"'sym\\\"\n\n   ;; specifying a sequence allows for whitespace between the \n   ;; quote and the quoted\n   (-> (n/quote-node [(n/spaces 10)\n                      (n/token-node 'sym1) ])\n       n/string)\n   ;; => \\\"'          sym1\\\"\n   ```\"\n  [children] (rewrite-clj.node.quote/quote-node children))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.quote\n(defn syntax-quote-node\n  \"Create node representing a single syntax-quoted form where `children`\n   is either a sequence of nodes or a single node.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n]) \n\n   (-> (n/syntax-quote-node (n/token-node 'map))\n       n/string)\n   ;; => \\\"`map\\\"\n\n   ;; specifying a sequence allows for whitespace between the \n   ;; syntax quote and the syntax quoted\n   (-> (n/syntax-quote-node [(n/spaces 3)\n                             (n/token-node 'map)])\n       n/string)\n   ;; => \\\"`   map\\\"\n   ```\"\n  [children] (rewrite-clj.node.quote/syntax-quote-node children))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.quote\n(defn unquote-node\n  \"Create node representing a single unquoted form where `children`\n   is either a sequence of nodes or a single node.\n   \n   ```Clojure\n   (require '[rewrite-clj.node :as n]) \n\n   (-> (n/unquote-node (n/token-node 'my-var))\n       n/string)\n   ;; => \\\"~my-var\\\"\n\n   ;; specifying a sequence allows for whitespace between the \n   ;; unquote and the uquoted\n   (-> (n/unquote-node [(n/spaces 4)\n                        (n/token-node 'my-var)])\n       n/string)\n   ;; => \\\"~    my-var\\\"\n   ```\"\n  [children] (rewrite-clj.node.quote/unquote-node children))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.quote\n(defn unquote-splicing-node\n  \"Create node representing a single unquote-spliced form where `children`\n   is either a sequence of nodes or a single node.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n]) \n\n   (-> (n/unquote-splicing-node (n/token-node 'my-var))\n       n/string)\n   ;; => \\\"~@my-var\\\"\n\n   ;; specifying a sequence allows for whitespace between the \n   ;; splicing unquote and the splicing unquoted\n   (-> (n/unquote-splicing-node [(n/spaces 2)\n                                 (n/token-node 'my-var)])\n       n/string)\n   ;; => \\\"~@  my-var\\\"   \n   ```\"\n  [children] (rewrite-clj.node.quote/unquote-splicing-node children))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.token\n(defn token-node\n  \"Create node for an unspecified token of `value`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/token-node 'sym) n/string)\n   ;; => \\\"sym\\\"\n\n   (-> (n/token-node 42) n/string)\n   ;; => \\\"42\\\"\n   ```\"\n  ([value] (rewrite-clj.node.token/token-node value))\n  ([value string-value] (rewrite-clj.node.token/token-node value string-value)))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.token\n(defn symbol-node?\n  \"Returns true if `n` is a node representing a symbol.\"\n  [n] (rewrite-clj.node.token/symbol-node? n))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.uneval\n(defn uneval-node\n  \"Create node representing an unevaled form with `children`.\n   \n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/uneval-node [(n/spaces 1)\n                       (n/token-node 42)])\n       n/string)\n   ;; => \\\"#_ 42\\\"\n   ```\"\n  [children] (rewrite-clj.node.uneval/uneval-node children))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.whitespace\n(defn comma-separated\n  \"Interleave `nodes` with `\\\", \\\"` nodes.\"\n  [nodes] (rewrite-clj.node.whitespace/comma-separated nodes))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.whitespace\n(defn line-separated\n  \"Interleave `nodes` with newline nodes.\"\n  [nodes] (rewrite-clj.node.whitespace/line-separated nodes))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.whitespace\n(defn linebreak?\n  \"Returns true if `node` represents one or more linebreaks.\"\n  [node] (rewrite-clj.node.whitespace/linebreak? node))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.whitespace\n(defn newlines\n  \"Create node representing `n` newline characters.\"\n  [n] (rewrite-clj.node.whitespace/newlines n))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.whitespace\n(defn newline-node\n  \"Create newline node of string `s`, where `s` is one or more linebreak characters.\"\n  [s] (rewrite-clj.node.whitespace/newline-node s))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.whitespace\n(defn spaces\n  \"Create node representing `n` spaces.\"\n  [n] (rewrite-clj.node.whitespace/spaces n))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.whitespace\n(defn whitespace-node\n  \"Create whitespace node of string `s`, where `s` is one or more space characters.\"\n  [s] (rewrite-clj.node.whitespace/whitespace-node s))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.whitespace\n(defn whitespace?\n  \"Returns true if `node` represents Clojure whitespace.\"\n  [node] (rewrite-clj.node.whitespace/whitespace? node))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.whitespace\n(defn comma-node\n  \"Create comma node of string `s`, where `s` is one or more comma characters.\"\n  [s] (rewrite-clj.node.whitespace/comma-node s))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.whitespace\n(defn comma?\n  \"Returns true if `node` represents one or more commas.\"\n  [node] (rewrite-clj.node.whitespace/comma? node))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.whitespace\n(defn whitespace-nodes\n  \"Convert string `s` of whitespace to whitespace/newline nodes.\"\n  [s] (rewrite-clj.node.whitespace/whitespace-nodes s))\n","~:reader-features",["^U",["~:cljs"]],"~:cljc",true,"~:source-map-compact",["^ ","mappings","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","names",["rewrite-clj.node/coerce","form","rewrite-clj.node.protocols/coerce","rewrite-clj.node/children","node","rewrite-clj.node.protocols/children","var_args","G__41264","rewrite-clj.node/child-sexprs","js/Error","rewrite_clj.node.protocols.child_sexprs","opts","rewrite-clj.node/inner?","rewrite-clj.node.protocols/inner?","rewrite-clj.node/leader-length","rewrite-clj.node.protocols/leader-length","rewrite-clj.node/length","rewrite-clj.node.protocols/length","rewrite-clj.node/node?","x","rewrite-clj.node.protocols/node?","rewrite-clj.node/printable-only?","rewrite-clj.node.protocols/printable-only?","rewrite-clj.node/replace-children","children","rewrite-clj.node.protocols/replace-children","G__41271","rewrite-clj.node/sexpr","rewrite_clj.node.protocols.sexpr","rewrite-clj.node/sexpr-able?","rewrite-clj.node.protocols/sexpr-able?","G__41275","rewrite-clj.node/sexprs","nodes","rewrite_clj.node.protocols.sexprs","rewrite-clj.node/map-context-apply","map-qualifier","rewrite-clj.node.protocols/map-context-apply","rewrite-clj.node/map-context-clear","rewrite-clj.node.protocols/map-context-clear","rewrite-clj.node/string","rewrite-clj.node.protocols/string","rewrite-clj.node/tag","rewrite-clj.node.protocols/tag","rewrite-clj.node/value","rewrite-clj.node.protocols/value","G__41281","rewrite-clj.node/comment-node","s","rewrite_clj.node.comment.comment_node","prefix","rewrite-clj.node/comment?","rewrite-clj.node.comment/comment?","rewrite-clj.node/whitespace-or-comment?","rewrite-clj.node.extras/whitespace-or-comment?","rewrite-clj.node/fn-node","rewrite-clj.node.fn/fn-node","rewrite-clj.node/forms-node","rewrite-clj.node.forms/forms-node","G__41286","rewrite-clj.node/integer-node","value","rewrite_clj.node.integer.integer_node","base","G__41288","rewrite-clj.node/keyword-node","k","auto-resolved?","rewrite_clj.node.keyword.keyword_node","rewrite-clj.node/keyword-node?","n","rewrite-clj.node.keyword/keyword-node?","G__41304","rewrite-clj.node/meta-node","rewrite_clj.node.meta.meta_node","metadata","data","G__41310","rewrite-clj.node/raw-meta-node","rewrite_clj.node.meta.raw_meta_node","rewrite-clj.node/map-qualifier-node","rewrite-clj.node.namespaced-map/map-qualifier-node","rewrite-clj.node/namespaced-map-node","rewrite-clj.node.namespaced-map/namespaced-map-node","rewrite-clj.node/regex-node","pattern-string","rewrite-clj.node.regex/regex-node","rewrite-clj.node/deref-node","rewrite-clj.node.reader-macro/deref-node","rewrite-clj.node/eval-node","rewrite-clj.node.reader-macro/eval-node","G__41325","rewrite-clj.node/reader-macro-node","rewrite_clj.node.reader_macro.reader_macro_node","macro-node","form-node","rewrite-clj.node/var-node","rewrite-clj.node.reader-macro/var-node","rewrite-clj.node/list-node","rewrite-clj.node.seq/list-node","rewrite-clj.node/map-node","rewrite-clj.node.seq/map-node","rewrite-clj.node/set-node","rewrite-clj.node.seq/set-node","rewrite-clj.node/vector-node","rewrite-clj.node.seq/vector-node","rewrite-clj.node/string-node","lines","rewrite-clj.node.stringz/string-node","rewrite-clj.node/quote-node","rewrite-clj.node.quote/quote-node","rewrite-clj.node/syntax-quote-node","rewrite-clj.node.quote/syntax-quote-node","rewrite-clj.node/unquote-node","rewrite-clj.node.quote/unquote-node","rewrite-clj.node/unquote-splicing-node","rewrite-clj.node.quote/unquote-splicing-node","G__41345","rewrite-clj.node/token-node","rewrite_clj.node.token.token_node","string-value","rewrite-clj.node/symbol-node?","rewrite-clj.node.token/symbol-node?","rewrite-clj.node/uneval-node","rewrite-clj.node.uneval/uneval-node","rewrite-clj.node/comma-separated","rewrite-clj.node.whitespace/comma-separated","rewrite-clj.node/line-separated","rewrite-clj.node.whitespace/line-separated","rewrite-clj.node/linebreak?","rewrite-clj.node.whitespace/linebreak?","rewrite-clj.node/newlines","rewrite-clj.node.whitespace/newlines","rewrite-clj.node/newline-node","rewrite-clj.node.whitespace/newline-node","rewrite-clj.node/spaces","rewrite-clj.node.whitespace/spaces","rewrite-clj.node/whitespace-node","rewrite-clj.node.whitespace/whitespace-node","rewrite-clj.node/whitespace?","rewrite-clj.node.whitespace/whitespace?","rewrite-clj.node/comma-node","rewrite-clj.node.whitespace/comma-node","rewrite-clj.node/comma?","rewrite-clj.node.whitespace/comma?","rewrite-clj.node/whitespace-nodes","rewrite-clj.node.whitespace/whitespace-nodes"]],"~:used-vars",["^U",["~$rewrite-clj.node/syntax-quote-node","~$rewrite-clj.node/sexpr","~$rewrite-clj.node/namespaced-map-node","~$rewrite-clj.node/value","~$rewrite-clj.node.seq/list-node","~$rewrite-clj.node.whitespace/spaces","~$rewrite-clj.node/comma-node","~$rewrite-clj.node/newline-node","~$rewrite-clj.node.uneval/uneval-node","~$rewrite-clj.node.protocols/sexpr-able?","~$rewrite-clj.node.namespaced-map/map-qualifier-node","~$rewrite-clj.node/unquote-splicing-node","~$rewrite-clj.node.seq/vector-node","~$rewrite-clj.node.reader-macro/eval-node","~$rewrite-clj.node/string","~$rewrite-clj.node.reader-macro/var-node","~$rewrite-clj.node.protocols/child-sexprs","~$rewrite-clj.node/map-node","~$rewrite-clj.node.protocols/tag","~$rewrite-clj.node/map-context-apply","~$rewrite-clj.node.protocols/map-context-clear","~$rewrite-clj.node.protocols/children","~$rewrite-clj.node.reader-macro/deref-node","~$rewrite-clj.node.integer/integer-node","~$rewrite-clj.node.token/symbol-node?","~$rewrite-clj.node/reader-macro-node","~$rewrite-clj.node/comment?","~$rewrite-clj.node.fn/fn-node","~$rewrite-clj.node.protocols/leader-length","~$rewrite-clj.node/set-node","~$rewrite-clj.node/spaces","~$rewrite-clj.node.protocols/inner?","~$rewrite-clj.node/keyword-node","~$rewrite-clj.node.protocols/sexprs","~$rewrite-clj.node/comment-node","~$rewrite-clj.node/raw-meta-node","~$rewrite-clj.node.protocols/map-context-apply","~$rewrite-clj.node.keyword/keyword-node?","~$rewrite-clj.node/symbol-node?","~$rewrite-clj.node.whitespace/whitespace?","~$rewrite-clj.node/length","~$rewrite-clj.node/unquote-node","~$rewrite-clj.node/quote-node","~$rewrite-clj.node/uneval-node","~$rewrite-clj.node/node?","~$rewrite-clj.node.meta/meta-node","~$rewrite-clj.node/keyword-node?","~$rewrite-clj.node.protocols/replace-children","~$rewrite-clj.node/token-node","~$rewrite-clj.node/whitespace-or-comment?","~$rewrite-clj.node/coerce","~$rewrite-clj.node.whitespace/comma-separated","~$rewrite-clj.node/line-separated","~$rewrite-clj.node/tag","~$rewrite-clj.node.extras/whitespace-or-comment?","~$rewrite-clj.node/child-sexprs","~$rewrite-clj.node.protocols/printable-only?","~$rewrite-clj.node/whitespace?","~$rewrite-clj.node.quote/syntax-quote-node","~$rewrite-clj.node.whitespace/newlines","~$rewrite-clj.node/whitespace-node","~$rewrite-clj.node/map-context-clear","~$rewrite-clj.node.protocols/node?","~$rewrite-clj.node/fn-node","~$rewrite-clj.node.protocols/sexpr","~$rewrite-clj.node.protocols/value","~$rewrite-clj.node.seq/map-node","~$rewrite-clj.node/linebreak?","~$rewrite-clj.node/vector-node","~$rewrite-clj.node/var-node","~$rewrite-clj.node/eval-node","~$rewrite-clj.node/deref-node","~$rewrite-clj.node.whitespace/whitespace-nodes","~$rewrite-clj.node/integer-node","~$rewrite-clj.node.keyword/keyword-node","~$rewrite-clj.node.whitespace/comma?","~$rewrite-clj.node.protocols/coerce","~$rewrite-clj.node.protocols/string","~$rewrite-clj.node.reader-macro/reader-macro-node","~$rewrite-clj.node.regex/regex-node","~$rewrite-clj.node/comma-separated","~$rewrite-clj.node/inner?","~$rewrite-clj.node/newlines","~$rewrite-clj.node.whitespace/newline-node","~$rewrite-clj.node/children","~$rewrite-clj.node.whitespace/comma-node","~$rewrite-clj.node/sexprs","~$rewrite-clj.node.forms/forms-node","~$rewrite-clj.node.quote/unquote-splicing-node","~$rewrite-clj.node.token/token-node","~$rewrite-clj.node/string-node","~$rewrite-clj.node.protocols/length","~$rewrite-clj.node/comma?","~$rewrite-clj.node/replace-children","~$rewrite-clj.node.whitespace/line-separated","~$rewrite-clj.node/forms-node","~$rewrite-clj.node/whitespace-nodes","~$rewrite-clj.node.comment/comment-node","~$rewrite-clj.node.whitespace/linebreak?","~$rewrite-clj.node/meta-node","~$rewrite-clj.node.seq/set-node","~$rewrite-clj.node/printable-only?","~$rewrite-clj.node/map-qualifier-node","~$rewrite-clj.node.stringz/string-node","~$rewrite-clj.node.namespaced-map/namespaced-map-node","~$rewrite-clj.node/sexpr-able?","~$js/Error","~$rewrite-clj.node/leader-length","~$rewrite-clj.node.whitespace/whitespace-node","~$rewrite-clj.node/list-node","~$rewrite-clj.node.meta/raw-meta-node","~$rewrite-clj.node.comment/comment?","~$rewrite-clj.node/regex-node","~$rewrite-clj.node.quote/unquote-node","~$rewrite-clj.node.quote/quote-node"]]],"~:cache-keys",["~#cmap",[["^1T","goog/dom/tagname.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","~:shadow.build.compiler/resolve",["^ ","~:require-id",null,"~:deps-ids",["^U",[]],"~:deps-syms",["^1:","~$goog.dom.HtmlElement"]]],["^1T","cljs/tools/reader/impl/utils.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^19","~$clojure.string","~$goog.string"]]],["^1T","rewrite_clj/node/reader_macro.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^19","^1@","^1C"]]],["^1T","goog/html/trustedtypes.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:"]]],["^1T","goog/string/stringformat.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^4W"]]],["^1T","goog/labs/useragent/browser.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","~$goog.array","~$goog.object","~$goog.labs.userAgent.util","~$goog.string.internal"]]],["^1T","goog/html/safeurl.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","~$goog.asserts","~$goog.fs.url","~$goog.html.TrustedResourceUrl","~$goog.i18n.bidi.Dir","~$goog.i18n.bidi.DirectionalString","~$goog.string.Const","~$goog.string.TypedString","^4["]]],["^1T","goog/array/array.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^50"]]],["^1T","rewrite_clj/node/regex.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^19","^1@"]]],["^1T","goog/debug/error.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:"]]],["^1T","cljs/tools/reader/edn.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^19","^F","^J","^@","^D","~$cljs.tools.reader","^4W","~$goog.string.StringBuffer"]]],["^1T","goog/dom/nodetype.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:"]]],["^1T","cljs/tools/reader/impl/inspect.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^19"]]],["^1T","cljs/tools/reader.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^19","^J","^@","^D","^F","^4X","^4W","^58"]]],["^1T","rewrite_clj/node/uneval.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^19","^1@"]]],["^1T","goog/string/typedstring.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:"]]],["^1T","goog/object/object.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:"]]],["^1T","goog/dom/asserts.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^50"]]],"~:SHADOW-TIMESTAMP",[1666857604000,1666857604000,1666857293000],["^1T","rewrite_clj/node/keyword.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^19","^1@"]]],["^1T","rewrite_clj/node/token.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^19","^1@"]]],["^1T","goog/math/long.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^50","~$goog.reflect"]]],["^1T","goog/html/trustedresourceurl.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^50","~$goog.fs.blob","^51","~$goog.html.SafeScript","~$goog.html.trustedtypes","^53","^54","^55","^56"]]],["^1T","rewrite_clj/node.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^19","^1F","^1>","^18","^1;","^1E","^15","^1=","^14","^1D","^1@","^1?","^1<","^1B","^17","^13","^16","^1A","^1C"]]],["^1T","rewrite_clj/node/comment.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^19","^1@"]]],["^1T","goog/string/internal.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:"]]],["^1T","goog/functions/functions.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:"]]],["^1T","goog/html/safestyle.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^55","~$goog.html.SafeUrl","^56","^50","^4["]]],["^1T","goog/dom/safe.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^50","~$goog.dom.asserts","~$goog.functions","~$goog.html.SafeHtml","^5<","~$goog.html.SafeStyle","^5>","^52","~$goog.html.uncheckedconversions","^55","^4["]]],["^1T","clojure/walk.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^19"]]],["^1T","goog/html/safehtml.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^55","^53","^54","^5<","^5B","~$goog.html.SafeStyleSheet","^5>","~$goog.dom.TagName","^52","^56","^50","~$goog.labs.userAgent.browser","^4X","^4Y","^4[","~$goog.dom.tags","^5="]]],["^1T","rewrite_clj/node/forms.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^19","^1@"]]],["^1T","goog/dom/tags.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^4Y"]]],["^1T","rewrite_clj/node/integer.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^19","~$rewrite-clj.interop","^1@"]]],["^1T","rewrite_clj/node/fn.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^19","^4V","~$clojure.walk","^5H","^1@"]]],["^1T","goog/fs/blob.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:"]]],["^1T","rewrite_clj/node/protocols.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^19","^4V","^5H"]]],["^1T","goog/asserts/asserts.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","~$goog.debug.Error","~$goog.dom.NodeType"]]],["^1T","goog/uri/uri.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^4X","^50","~$goog.collections.maps","^4W","~$goog.structs","~$goog.uri.utils","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"]]],["^1T","rewrite_clj/node/meta.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^19","^5H","^1@","^1C"]]],["^1T","rewrite_clj/node/stringz.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^19","^4V","^L","^1@"]]],["^1T","goog/collections/maps.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:"]]],["^1T","rewrite_clj/node/whitespace.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^19","^1@","~$rewrite-clj.reader"]]],["^1T","goog/i18n/bidi.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:"]]],["^1T","goog/fs/url.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:"]]],["^1T","rewrite_clj/node/quote.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^19","^1@"]]],["^1T","goog/base.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",[]]],["^1T","goog/structs/structs.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^4X","^4Y"]]],["^1T","cljs/tools/reader/impl/errors.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^19","^J","^4V","~$cljs.tools.reader.impl.inspect"]]],["^1T","clojure/string.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^19","^4W","^58"]]],["^1T","rewrite_clj/node/namespaced_map.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^19","^1@"]]],["^1T","goog/string/string.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","~$goog.dom.safe","^5C","^55","^4["]]],["^1T","goog/reflect/reflect.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:"]]],["^1T","goog/labs/useragent/util.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","~$goog.labs.userAgent","^4["]]],["^1T","goog/string/stringbuffer.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:"]]],["^1T","cljs/tools/reader/reader_types.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^19","^@","^4W","^58"]]],["^1T","rewrite_clj/reader.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^19","^L","^D","^F","^@","^J","^5H","^58"]]],["^1T","goog/labs/useragent/useragent.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:"]]],["^1T","rewrite_clj/node/coercer.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^19","^4V","^1>","^1;","^1E","^15","^1=","^14","^1D","^1@","^1?","^1<","^1B","^17","^13","^16","^1A","^1C"]]],["^1T","goog/html/uncheckedconversions.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^50","^5A","^5<","^5B","^5D","^5>","^52","^55","^4[","^53"]]],["^1T","cljs/tools/reader/impl/commons.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^19","^F","^J","^@"]]],["^1T","goog/dom/htmlelement.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:"]]],["^1T","cljs/core.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","~$goog.math.Long","~$goog.math.Integer","^4W","^4Y","^4X","~$goog.Uri","^58"]]],["^1T","goog/html/safescript.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^55","^56","^5=","^50"]]],["^1T","rewrite_clj/node/extras.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^19","^1>","^1C"]]],["^1T","goog/html/safestylesheet.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^55","^5B","^56","^4Y","^50","^4["]]],["^1T","goog/math/integer.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^5:"]]],["^1T","goog/uri/utils.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^50","^4W"]]],["^1T","goog/string/const.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^50","^56"]]],["^1T","rewrite_clj/interop.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^19","^4W","~$goog.string.format"]]],["^1T","rewrite_clj/node/seq.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^4Q",["^ ","^4R",null,"^4S",["^U",[]],"^4T",["^1:","^19","^5H","^1@"]]]]],"~:clj-info",["^ ","jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/string.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/impl/errors.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/env.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/default_data_readers.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/core.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/edn.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/reader.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/reader_types.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/util.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/compiler.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/impl/inspect.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/edn.clj",1666857280000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/passes/and_or.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/pprint.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map/base64_vlq.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/set.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/reader_types.clj",1666857280000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/node/protocols.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/instant.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map/base64.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/interop.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/impl/utils.clj",1666857280000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/externs.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/impl/commons.clj",1666857280000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/js_deps.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/binaryage/devtools/1.0.6/devtools-1.0.6.jar!/devtools/defaults.clj",1666857314000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/java/io.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/impl/inspect.clj",1666857280000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/node/whitespace.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/impl.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/tagged_literals.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/core.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/passes.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/data/json.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/instant.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/impl/namespaces.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/impl/errors.clj",1666857280000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/cljs/tools/reader/reader_types.clj",1666857280000],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","Create, update, convert and integorate nodes.\n\n  All nodes represent Clojure/ClojureScript/EDN.\n\n  Because this API contains many functions, we offer the following categorized listing:\n\n  **Node creation**\n  [[comma-node]]\n  [[comment-node]]\n  [[deref-node]]\n  [[eval-node]]\n  [[fn-node]]\n  [[forms-node]]\n  [[integer-node]]\n  [[keyword-node]]\n  [[map-node]]\n  [[map-qualifier-node]]\n  [[meta-node]]\n  [[namespaced-map-node]]\n  [[newline-node]]\n  [[quote-node]]\n  [[raw-meta-node]]\n  [[reader-macro-node]]\n  [[regex-node]]\n  [[set-node]]\n  [[string-node]]\n  [[syntax-quote-node]]\n  [[token-node]]\n  [[uneval-node]]\n  [[unquote-node]]\n  [[unquote-splicing-node]]\n  [[var-node]]\n  [[vector-node]]\n  [[whitespace-node]]\n\n  **Whitespace creation convenience**\n  [[spaces]]\n  [[newlines]]\n  [[comma-separated]]\n  [[line-separated]]\n  [[whitespace-nodes]]\n\n  **Convert form to node**\n  [[coerce]]\n\n  **Convert node to form**\n  [[sexpr-able?]]\n  [[sexpr]]\n  [[sexprs]]\n  [[child-sexprs]]\n\n  **Convert node to string**\n  [[string]]\n\n  **Node interogation**\n  [[tag]]\n  [[inner?]]\n  [[children]]\n  [[length]]\n  [[leader-length]]\n  [[printable-only?]]\n\n  **Update node**\n  [[replace-children]]\n\n  **Namespaced map element support**\n  [[map-context-apply]]\n  [[map-context-clear]]\n\n  **Test type**\n  [[node?]]\n  [[comment?]]\n  [[whitespace-or-comment?]]\n  [[keyword-node?]]\n  [[symbol-node?]]\n  [[linebreak?]]\n  [[comma?]]","^7","rewrite_clj/node.cljc","^8",2,"^9",5,"^:",2,"^;",21],"^<",["^ ","^=","^>","^?","^@","^A","^B","^C","^D","^E","^F","^G","^H","^I","^J","^K","^L","^M","^N","^O","^P","^Q","^R"],"^S",null,"^T",["^U",["^V","^W"]],"^X","^Y","^Z",["^ "],"^11",null,"^12",["^ ","^13","^13","^14","^14","^15","^15","^16","^16","^17","^17","^18","^18","^19","^19","^1:","^1:","^1;","^1;","^1<","^1<","^1=","^1=","^1>","^1>","^1?","^1?","^1@","^1@","^1A","^1A","^1B","^1B","^1C","^1C","^1D","^1D","^1E","^1E","^1F","^1F"],"^1G",["^U",["^1H"]],"~:shadow/js-access-global",["^U",["Error"]],"^1I",null,"~:defs",["^ ","~$child-sexprs",["^ ","~:protocol-inline",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",117,"^9",7,"^:",117,"^;",19,"~:arglists",["^1L",["~$quote",["^1L",[["~$node"],["^72","~$opts"]]]]],"^6","Returns children for `node` converted to Clojure forms.\n\n  Optional `opts` can specify:\n  - `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)","~:top-fn",["^ ","~:variadic?",false,"~:fixed-arity",2,"~:max-fixed-arity",2,"~:method-params",[["^72"],["^72","^73"]],"^70",["^1L",[["^72"],["^72","^73"]]],"~:arglists-meta",["^1L",[null,null]]]],"^X","^3?","^7","rewrite_clj/node.cljc","^;",19,"^74",["^ ","^75",false,"^76",2,"^77",2,"^78",[["^72"],["^72","^73"]],"^70",["^1L",[["^72"],["^72","^73"]]],"^79",["^1L",[null,null]]],"^78",[["^72"],["^72","^73"]],"~:protocol-impl",null,"^76",2,"^79",["^1L",[null,null]],"^9",1,"^75",false,"~:methods",[["^ ","^76",1,"^75",false,"~:tag","~$any"],["^ ","^76",2,"^75",false,"^7<",["^U",["~$cljs.core/LazySeq","~$clj-nil"]]]],"^8",117,"^:",117,"^77",2,"~:fn-var",true,"^70",["^1L",[["^72"],["^72","^73"]]],"^6","Returns children for `node` converted to Clojure forms.\n\n  Optional `opts` can specify:\n  - `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)"],"~$tag",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",200,"^9",7,"^:",200,"^;",10,"^70",["^1L",["^71",["^1L",[["^72"]]]]],"^6","Returns keyword representing type of `node`."],"^X","^3=","^7","rewrite_clj/node.cljc","^;",10,"^78",["^1L",[["^72"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",200,"~:ret-tag","^7=","^:",200,"^77",1,"^7@",true,"^70",["^1L",["^71",["^1L",[["^72"]]]]],"^6","Returns keyword representing type of `node`."],"~$whitespace?",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",829,"^9",7,"^:",829,"^;",18,"^70",["^1L",["^71",["^1L",[["^72"]]]]],"^6","Returns true if `node` represents Clojure whitespace."],"^X","^3A","^7","rewrite_clj/node.cljc","^;",18,"^78",["^1L",[["^72"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",829,"^7B","~$boolean","^:",829,"^77",1,"^7@",true,"^70",["^1L",["^71",["^1L",[["^72"]]]]],"^6","Returns true if `node` represents Clojure whitespace."],"~$whitespace-node",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",824,"^9",7,"^:",824,"^;",22,"^70",["^1L",["^71",["^1L",[["~$s"]]]]],"^6","Create whitespace node of string `s`, where `s` is one or more space characters."],"^X","^3D","^7","rewrite_clj/node.cljc","^;",22,"^78",["^1L",[["~$s"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",824,"^7B","~$rewrite-clj.node.whitespace/WhitespaceNode","^:",824,"^77",1,"^7@",true,"^70",["^1L",["^71",["^1L",[["~$s"]]]]],"^6","Create whitespace node of string `s`, where `s` is one or more space characters."],"~$fn-node",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",246,"^9",7,"^:",246,"^;",14,"^70",["^1L",["^71",["^1L",[["~$children"]]]]],"^6","Create node representing an anonymous function with `children`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/fn-node [(n/token-node '+)\n                   (n/spaces 1)\n                   (n/token-node 1)\n                   (n/spaces 1)\n                   (n/token-node '%1)])\n       n/string)\n   ;; => \"#(+ 1 %1)\"\n   ```"],"^X","^3G","^7","rewrite_clj/node.cljc","^;",14,"^78",["^1L",[["^7H"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",246,"^7B","~$rewrite-clj.node.fn/FnNode","^:",246,"^77",1,"^7@",true,"^70",["^1L",["^71",["^1L",[["^7H"]]]]],"^6","Create node representing an anonymous function with `children`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/fn-node [(n/token-node '+)\n                   (n/spaces 1)\n                   (n/token-node 1)\n                   (n/spaces 1)\n                   (n/token-node '%1)])\n       n/string)\n   ;; => \"#(+ 1 %1)\"\n   ```"],"~$map-context-clear",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",190,"^9",7,"^:",190,"^;",24,"^70",["^1L",["^71",["^1L",[["^72"]]]]],"^6","Removes map-qualifier context for `node`"],"^X","^3E","^7","rewrite_clj/node.cljc","^;",24,"^78",["^1L",[["^72"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",190,"^7B","^7=","^:",190,"^77",1,"^7@",true,"^70",["^1L",["^71",["^1L",[["^72"]]]]],"^6","Removes map-qualifier context for `node`"],"~$linebreak?",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",804,"^9",7,"^:",804,"^;",17,"^70",["^1L",["^71",["^1L",[["^72"]]]]],"^6","Returns true if `node` represents one or more linebreaks."],"^X","^3K","^7","rewrite_clj/node.cljc","^;",17,"^78",["^1L",[["^72"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",804,"^7B","^7D","^:",804,"^77",1,"^7@",true,"^70",["^1L",["^71",["^1L",[["^72"]]]]],"^6","Returns true if `node` represents one or more linebreaks."],"~$var-node",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",533,"^9",7,"^:",533,"^;",15,"^70",["^1L",["^71",["^1L",[["^7H"]]]]],"^6","Create node representing a var where `children` is either a \n   sequence of nodes or a single node.\n   \n   ```Clojure\n   (require '[rewrite-clj.node :as n])  \n\n   (-> (n/var-node (n/token-node 'my-var))\n       n/string)\n   ;; => \"#'my-var\"\n\n   ;; specifying a sequence allows for whitespace between the \n   ;; prefix and the var \n   (-> (n/var-node [(n/spaces 2)\n                    (n/token-node 'my-var)])\n       n/string)\n   ;; => \"#'  my-var\"\n   ```"],"^X","^3M","^7","rewrite_clj/node.cljc","^;",15,"^78",["^1L",[["^7H"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",533,"^7B","~$rewrite-clj.node.reader-macro/ReaderNode","^:",533,"^77",1,"^7@",true,"^70",["^1L",["^71",["^1L",[["^7H"]]]]],"^6","Create node representing a var where `children` is either a \n   sequence of nodes or a single node.\n   \n   ```Clojure\n   (require '[rewrite-clj.node :as n])  \n\n   (-> (n/var-node (n/token-node 'my-var))\n       n/string)\n   ;; => \"#'my-var\"\n\n   ;; specifying a sequence allows for whitespace between the \n   ;; prefix and the var \n   (-> (n/var-node [(n/spaces 2)\n                    (n/token-node 'my-var)])\n       n/string)\n   ;; => \"#'  my-var\"\n   ```"],"~$vector-node",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",639,"^9",7,"^:",639,"^;",18,"^70",["^1L",["^71",["^1L",[["^7H"]]]]],"^6","Create a node representing a vector with `children`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/vector-node [(n/token-node 1)\n                       (n/spaces 1)\n                       (n/token-node 2)\n                       (n/spaces 1)\n                       (n/token-node 3)])\n       n/string)\n   ;; => \"[1 2 3]\"\n   ```"],"^X","^3L","^7","rewrite_clj/node.cljc","^;",18,"^78",["^1L",[["^7H"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",639,"^7B","~$rewrite-clj.node.seq/SeqNode","^:",639,"^77",1,"^7@",true,"^70",["^1L",["^71",["^1L",[["^7H"]]]]],"^6","Create a node representing a vector with `children`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/vector-node [(n/token-node 1)\n                       (n/spaces 1)\n                       (n/token-node 2)\n                       (n/spaces 1)\n                       (n/token-node 3)])\n       n/string)\n   ;; => \"[1 2 3]\"\n   ```"],"~$eval-node",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",485,"^9",7,"^:",485,"^;",16,"^70",["^1L",["^71",["^1L",[["^7H"]]]]],"^6","Create node representing an inline evaluation\n   where `children` is either a sequence of nodes or a single node.\n   \n   ```Clojure\n   (require '[rewrite-clj.node :as n])  \n\n   (-> (n/eval-node (n/list-node [(n/token-node 'inc)\n                                  (n/spaces 1)\n                                  (n/token-node 1)]))\n       n/string)\n   ;; => \"#=(inc 1)\"\n\n   ;; specifying a sequence allows for whitespace between the \n   ;; prefix and the form \n   (-> (n/eval-node [(n/spaces 3)\n                     (n/list-node [(n/token-node 'inc)\n                                   (n/spaces 1)\n                                   (n/token-node 1)])])\n       n/string)\n   ;; => \"#=   (inc 1)\"\n   ```"],"^X","^3N","^7","rewrite_clj/node.cljc","^;",16,"^78",["^1L",[["^7H"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",485,"^7B","^7M","^:",485,"^77",1,"^7@",true,"^70",["^1L",["^71",["^1L",[["^7H"]]]]],"^6","Create node representing an inline evaluation\n   where `children` is either a sequence of nodes or a single node.\n   \n   ```Clojure\n   (require '[rewrite-clj.node :as n])  \n\n   (-> (n/eval-node (n/list-node [(n/token-node 'inc)\n                                  (n/spaces 1)\n                                  (n/token-node 1)]))\n       n/string)\n   ;; => \"#=(inc 1)\"\n\n   ;; specifying a sequence allows for whitespace between the \n   ;; prefix and the form \n   (-> (n/eval-node [(n/spaces 3)\n                     (n/list-node [(n/token-node 'inc)\n                                   (n/spaces 1)\n                                   (n/token-node 1)])])\n       n/string)\n   ;; => \"#=   (inc 1)\"\n   ```"],"~$deref-node",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",465,"^9",7,"^:",465,"^;",17,"^70",["^1L",["^71",["^1L",[["^7H"]]]]],"^6","Create node representing the dereferencing of a form \n   where `children` is either a sequence of nodes or a single node.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])   \n\n   (-> (n/deref-node (n/token-node 'my-var))\n       n/string)\n   ;; => \"@my-var\"\n\n   ;; specifying a sequence allows for whitespace between @ and form\n   (-> (n/deref-node [(n/spaces 2)\n                      (n/token-node 'my-var)])\n       n/string)\n   ;; => \"@  my-var\"\n   ```"],"^X","^3O","^7","rewrite_clj/node.cljc","^;",17,"^78",["^1L",[["^7H"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",465,"^7B","~$rewrite-clj.node.reader-macro/DerefNode","^:",465,"^77",1,"^7@",true,"^70",["^1L",["^71",["^1L",[["^7H"]]]]],"^6","Create node representing the dereferencing of a form \n   where `children` is either a sequence of nodes or a single node.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])   \n\n   (-> (n/deref-node (n/token-node 'my-var))\n       n/string)\n   ;; => \"@my-var\"\n\n   ;; specifying a sequence allows for whitespace between @ and form\n   (-> (n/deref-node [(n/spaces 2)\n                      (n/token-node 'my-var)])\n       n/string)\n   ;; => \"@  my-var\"\n   ```"],"~$integer-node",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",280,"^9",7,"^:",280,"^;",19,"^70",["^1L",["^71",["^1L",[["~$value"],["^7T","~$base"]]]]],"^6","Create node representing an integer `value` in `base`.\n\n  `base` defaults to 10.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/integer-node 42)\n       n/string)\n   ;; => \"42\"\n\n   (-> (n/integer-node 31 2)\n       n/string)\n   ;; => \"2r11111\"\n   ```   \n\n   Note: the parser does not currently parse to integer-nodes, but they fully supported for output.","^74",["^ ","^75",false,"^76",2,"^77",2,"^78",[["^7T"],["^7T","^7U"]],"^70",["^1L",[["^7T"],["^7T","^7U"]]],"^79",["^1L",[null,null]]]],"^X","^3Q","^7","rewrite_clj/node.cljc","^;",19,"^74",["^ ","^75",false,"^76",2,"^77",2,"^78",[["^7T"],["^7T","^7U"]],"^70",["^1L",[["^7T"],["^7T","^7U"]]],"^79",["^1L",[null,null]]],"^78",[["^7T"],["^7T","^7U"]],"^7:",null,"^76",2,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^7;",[["^ ","^76",1,"^75",false,"^7<","^7="],["^ ","^76",2,"^75",false,"^7<","~$rewrite-clj.node.integer/IntNode"]],"^8",280,"^:",280,"^77",2,"^7@",true,"^70",["^1L",[["^7T"],["^7T","^7U"]]],"^6","Create node representing an integer `value` in `base`.\n\n  `base` defaults to 10.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/integer-node 42)\n       n/string)\n   ;; => \"42\"\n\n   (-> (n/integer-node 31 2)\n       n/string)\n   ;; => \"2r11111\"\n   ```   \n\n   Note: the parser does not currently parse to integer-nodes, but they fully supported for output."],"~$comma-separated",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",794,"^9",7,"^:",794,"^;",22,"^70",["^1L",["^71",["^1L",[["~$nodes"]]]]],"^6","Interleave `nodes` with `\", \"` nodes."],"^X","^3X","^7","rewrite_clj/node.cljc","^;",22,"^78",["^1L",[["^7X"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",794,"^7B","^7>","^:",794,"^77",1,"^7@",true,"^70",["^1L",["^71",["^1L",[["^7X"]]]]],"^6","Interleave `nodes` with `\", \"` nodes."],"^7H",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",112,"^9",7,"^:",112,"^;",15,"^70",["^1L",["^71",["^1L",[["^72"]]]]],"^6","Returns child nodes for `node`."],"^X","^40","^7","rewrite_clj/node.cljc","^;",15,"^78",["^1L",[["^72"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",112,"^7B","^7=","^:",112,"^77",1,"^7@",true,"^70",["^1L",["^71",["^1L",[["^72"]]]]],"^6","Returns child nodes for `node`."],"~$newlines",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",809,"^9",7,"^:",809,"^;",15,"^70",["^1L",["^71",["^1L",[["~$n"]]]]],"^6","Create node representing `n` newline characters."],"^X","^3Z","^7","rewrite_clj/node.cljc","^;",15,"^78",["^1L",[["~$n"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",809,"^7B","~$rewrite-clj.node.whitespace/NewlineNode","^:",809,"^77",1,"^7@",true,"^70",["^1L",["^71",["^1L",[["~$n"]]]]],"^6","Create node representing `n` newline characters."],"~$sexprs",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",174,"^9",7,"^:",174,"^;",13,"^70",["^1L",["^71",["^1L",[["^7X"],["^7X","^73"]]]]],"^6","Return forms for `nodes`. Nodes that do not represent s-expression are skipped.\n\n  Optional `opts` can specify:\n  - `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)\n\n  See docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances).","^74",["^ ","^75",false,"^76",2,"^77",2,"^78",[["^7X"],["^7X","^73"]],"^70",["^1L",[["^7X"],["^7X","^73"]]],"^79",["^1L",[null,null]]]],"^X","^42","^7","rewrite_clj/node.cljc","^;",13,"^74",["^ ","^75",false,"^76",2,"^77",2,"^78",[["^7X"],["^7X","^73"]],"^70",["^1L",[["^7X"],["^7X","^73"]]],"^79",["^1L",[null,null]]],"^78",[["^7X"],["^7X","^73"]],"^7:",null,"^76",2,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^7;",[["^ ","^76",1,"^75",false,"^7<","^7="],["^ ","^76",2,"^75",false,"^7<","^7>"]],"^8",174,"^:",174,"^77",2,"^7@",true,"^70",["^1L",[["^7X"],["^7X","^73"]]],"^6","Return forms for `nodes`. Nodes that do not represent s-expression are skipped.\n\n  Optional `opts` can specify:\n  - `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)\n\n  See docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances)."],"~$inner?",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",126,"^9",7,"^:",126,"^;",13,"^70",["^1L",["^71",["^1L",[["^72"]]]]],"^6","Returns true if `node` can have children."],"^X","^3Y","^7","rewrite_clj/node.cljc","^;",13,"^78",["^1L",[["^72"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",126,"^7B","^7=","^:",126,"^77",1,"^7@",true,"^70",["^1L",["^71",["^1L",[["^72"]]]]],"^6","Returns true if `node` can have children."],"~$replace-children",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",151,"^9",7,"^:",151,"^;",23,"^70",["^1L",["^71",["^1L",[["^72","^7H"]]]]],"^6","Returns `node` replacing current children with `children`."],"^X","^49","^7","rewrite_clj/node.cljc","^;",23,"^78",["^1L",[["^72","^7H"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",151,"^7B","^7=","^:",151,"^77",2,"^7@",true,"^70",["^1L",["^71",["^1L",[["^72","^7H"]]]]],"^6","Returns `node` replacing current children with `children`."],"~$comma?",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",839,"^9",7,"^:",839,"^;",13,"^70",["^1L",["^71",["^1L",[["^72"]]]]],"^6","Returns true if `node` represents one or more commas."],"^X","^48","^7","rewrite_clj/node.cljc","^;",13,"^78",["^1L",[["^72"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",839,"^7B","^7D","^:",839,"^77",1,"^7@",true,"^70",["^1L",["^71",["^1L",[["^72"]]]]],"^6","Returns true if `node` represents one or more commas."],"~$forms-node",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",263,"^9",7,"^:",263,"^;",17,"^70",["^1L",["^71",["^1L",[["^7H"]]]]],"^6","Create top-level node wrapping multiple `children`.\n   The forms node is equivalent to an implicit `do` at the top-level.\n   \n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/forms-node [(n/token-node 1)\n                      (n/spaces 1)\n                      (n/token-node 2)])\n       n/string)\n   ;; => \"1 2\"\n   ``` \n   "],"^X","^4;","^7","rewrite_clj/node.cljc","^;",17,"^78",["^1L",[["^7H"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",263,"^7B","~$rewrite-clj.node.forms/FormsNode","^:",263,"^77",1,"^7@",true,"^70",["^1L",["^71",["^1L",[["^7H"]]]]],"^6","Create top-level node wrapping multiple `children`.\n   The forms node is equivalent to an implicit `do` at the top-level.\n   \n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/forms-node [(n/token-node 1)\n                      (n/spaces 1)\n                      (n/token-node 2)])\n       n/string)\n   ;; => \"1 2\"\n   ``` \n   "],"~$string-node",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",656,"^9",7,"^:",656,"^;",18,"^70",["^1L",["^71",["^1L",[["~$lines"]]]]],"^6","Create node representing a string value where `lines` can be a sequence of strings or a single string.\n  \n  When `lines` is a sequence, the resulting node will `tag` will be `:multi-line`, otherwise `:token`.\n   \n  ```Clojure\n  (require '[rewrite-clj.node :as n])\n\n  (-> (n/string-node \"hello\")\n      n/string)\n  ;; => \"\\\"hello\\\"\"\n\n  (-> (n/string-node [\"line1\" \"\" \"line3\"])\n       n/string)\n  ;; => \"\\\"line1\\n\\nline3\\\"\"\n  ```"],"^X","^46","^7","rewrite_clj/node.cljc","^;",18,"^78",["^1L",[["^86"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",656,"^7B","~$rewrite-clj.node.stringz/StringNode","^:",656,"^77",1,"^7@",true,"^70",["^1L",["^71",["^1L",[["^86"]]]]],"^6","Create node representing a string value where `lines` can be a sequence of strings or a single string.\n  \n  When `lines` is a sequence, the resulting node will `tag` will be `:multi-line`, otherwise `:token`.\n   \n  ```Clojure\n  (require '[rewrite-clj.node :as n])\n\n  (-> (n/string-node \"hello\")\n      n/string)\n  ;; => \"\\\"hello\\\"\"\n\n  (-> (n/string-node [\"line1\" \"\" \"line3\"])\n       n/string)\n  ;; => \"\\\"line1\\n\\nline3\\\"\"\n  ```"],"~$meta-node",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",339,"^9",7,"^:",339,"^;",16,"^70",["^1L",["^71",["^1L",[["^7H"],["~$metadata","~$data"]]]]],"^6","Create a node representing a form with metadata.\n\n   When creating manually, you can specify `metadata` and `data` and spacing between the 2 elems will be included: \n\n   ```Clojure\n   (require '[rewrite-clj.node :as n]) \n\n   (-> (n/meta-node (n/keyword-node :foo)\n                    (n/vector-node [(n/token-node 1)]))\n       n/string)\n   ;; => \"^:foo [1]\"\n\n   (-> (n/meta-node (n/map-node [:foo (n/spaces 1) 42])\n                    (n/vector-node [(n/token-node 1)]))\n       n/string)\n   ;; => \"^{:foo 42} [1]\"\n   ```\n   When specifying a sequence of `children`, spacing is explicit:\n\n   ```Clojure\n   (-> (n/meta-node [(n/keyword-node :foo)\n                     (n/spaces 1)\n                     (n/vector-node [(n/token-node 1)])])\n       n/string)\n   ;; => \"^:foo [1]\"\n   ```\n   See also: [[raw-meta-node]]","^74",["^ ","^75",false,"^76",2,"^77",2,"^78",[["^7H"],["^89","^8:"]],"^70",["^1L",[["^7H"],["^89","^8:"]]],"^79",["^1L",[null,null]]]],"^X","^4?","^7","rewrite_clj/node.cljc","^;",16,"^74",["^ ","^75",false,"^76",2,"^77",2,"^78",[["^7H"],["^89","^8:"]],"^70",["^1L",[["^7H"],["^89","^8:"]]],"^79",["^1L",[null,null]]],"^78",[["^7H"],["^89","^8:"]],"^7:",null,"^76",2,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^7;",[["^ ","^76",1,"^75",false,"^7<","~$rewrite-clj.node.meta/MetaNode"],["^ ","^76",2,"^75",false,"^7<","^8;"]],"^8",339,"^:",339,"^77",2,"^7@",true,"^70",["^1L",[["^7H"],["^89","^8:"]]],"^6","Create a node representing a form with metadata.\n\n   When creating manually, you can specify `metadata` and `data` and spacing between the 2 elems will be included: \n\n   ```Clojure\n   (require '[rewrite-clj.node :as n]) \n\n   (-> (n/meta-node (n/keyword-node :foo)\n                    (n/vector-node [(n/token-node 1)]))\n       n/string)\n   ;; => \"^:foo [1]\"\n\n   (-> (n/meta-node (n/map-node [:foo (n/spaces 1) 42])\n                    (n/vector-node [(n/token-node 1)]))\n       n/string)\n   ;; => \"^{:foo 42} [1]\"\n   ```\n   When specifying a sequence of `children`, spacing is explicit:\n\n   ```Clojure\n   (-> (n/meta-node [(n/keyword-node :foo)\n                     (n/spaces 1)\n                     (n/vector-node [(n/token-node 1)])])\n       n/string)\n   ;; => \"^:foo [1]\"\n   ```\n   See also: [[raw-meta-node]]"],"~$whitespace-nodes",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",844,"^9",7,"^:",844,"^;",23,"^70",["^1L",["^71",["^1L",[["~$s"]]]]],"^6","Convert string `s` of whitespace to whitespace/newline nodes."],"^X","^4<","^7","rewrite_clj/node.cljc","^;",23,"^78",["^1L",[["~$s"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",844,"^7B","^7>","^:",844,"^77",1,"^7@",true,"^70",["^1L",["^71",["^1L",[["~$s"]]]]],"^6","Convert string `s` of whitespace to whitespace/newline nodes."],"~$printable-only?",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",146,"^9",7,"^:",146,"^;",22,"^70",["^1L",["^71",["^1L",[["^72"]]]]],"^6","Return true if `node` cannot be converted to an s-expression element."],"^X","^4A","^7","rewrite_clj/node.cljc","^;",22,"^78",["^1L",[["^72"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",146,"^7B","^7=","^:",146,"^77",1,"^7@",true,"^70",["^1L",["^71",["^1L",[["^72"]]]]],"^6","Return true if `node` cannot be converted to an s-expression element."],"~$map-qualifier-node",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",405,"^9",7,"^:",405,"^;",25,"^70",["^1L",["^71",["^1L",[["~$auto-resolved?","~$prefix"]]]]],"^6","Create a map qualifier node.\n   The map qualifier node is a child node of [[namespaced-map-node]].\n     \n   ```Clojure\n   (require '[rewrite-clj.node :as n]) \n   \n   ;; qualified\n   (-> (n/map-qualifier-node false \"my-prefix\")\n       n/string)\n   ;; => \":my-prefix\"\n\n   ;; auto-resolved to current ns\n   (-> (n/map-qualifier-node true nil)\n       n/string)\n   ;; => \"::\"\n\n   ;; auto-resolve to namespace with alias\n   (-> (n/map-qualifier-node true \"my-ns-alias\")\n       n/string)\n   ;; => \"::my-ns-alias\"\n   ```"],"^X","^4B","^7","rewrite_clj/node.cljc","^;",25,"^78",["^1L",[["^8?","^8@"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",405,"^7B","~$rewrite-clj.node.namespaced-map/MapQualifierNode","^:",405,"^77",2,"^7@",true,"^70",["^1L",["^71",["^1L",[["^8?","^8@"]]]]],"^6","Create a map qualifier node.\n   The map qualifier node is a child node of [[namespaced-map-node]].\n     \n   ```Clojure\n   (require '[rewrite-clj.node :as n]) \n   \n   ;; qualified\n   (-> (n/map-qualifier-node false \"my-prefix\")\n       n/string)\n   ;; => \":my-prefix\"\n\n   ;; auto-resolved to current ns\n   (-> (n/map-qualifier-node true nil)\n       n/string)\n   ;; => \"::\"\n\n   ;; auto-resolve to namespace with alias\n   (-> (n/map-qualifier-node true \"my-ns-alias\")\n       n/string)\n   ;; => \"::my-ns-alias\"\n   ```"],"~$leader-length",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",131,"^9",7,"^:",131,"^;",20,"^70",["^1L",["^71",["^1L",[["^72"]]]]],"^6","Returns number of characters before children for `node`."],"^X","^4G","^7","rewrite_clj/node.cljc","^;",20,"^78",["^1L",[["^72"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",131,"^7B","^7=","^:",131,"^77",1,"^7@",true,"^70",["^1L",["^71",["^1L",[["^72"]]]]],"^6","Returns number of characters before children for `node`."],"~$sexpr-able?",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",167,"^9",7,"^:",167,"^;",18,"^70",["^1L",["^71",["^1L",[["^72"]]]]],"^6","Return true if [[sexpr]] is supported for `node`'s element type.\n\n   See [related docs in user guide](/doc/01-user-guide.adoc#not-all-clojure-is-sexpr-able)"],"^X","^4E","^7","rewrite_clj/node.cljc","^;",18,"^78",["^1L",[["^72"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",167,"^7B","^7D","^:",167,"^77",1,"^7@",true,"^70",["^1L",["^71",["^1L",[["^72"]]]]],"^6","Return true if [[sexpr]] is supported for `node`'s element type.\n\n   See [related docs in user guide](/doc/01-user-guide.adoc#not-all-clojure-is-sexpr-able)"],"~$regex-node",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",451,"^9",7,"^:",451,"^;",17,"^70",["^1L",["^71",["^1L",[["~$pattern-string"]]]]],"^6","Create node representing a regex with `pattern-string`.\n   Use same escape rules for `pattern-string` as you would for `(re-pattern \"pattern-string\")`\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/regex-node \"my\\\\.lil.*regex\")\n       n/string)\n   ;; => \"#\\\"my\\\\.lil.*regex\\\"\"  \n   ```"],"^X","^4L","^7","rewrite_clj/node.cljc","^;",17,"^78",["^1L",[["^8E"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",451,"^7B","~$rewrite-clj.node.regex/RegexNode","^:",451,"^77",1,"^7@",true,"^70",["^1L",["^71",["^1L",[["^8E"]]]]],"^6","Create node representing a regex with `pattern-string`.\n   Use same escape rules for `pattern-string` as you would for `(re-pattern \"pattern-string\")`\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/regex-node \"my\\\\.lil.*regex\")\n       n/string)\n   ;; => \"#\\\"my\\\\.lil.*regex\\\"\"  \n   ```"],"~$list-node",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",554,"^9",7,"^:",554,"^;",16,"^70",["^1L",["^71",["^1L",[["^7H"]]]]],"^6","Create a node representing a list with `children`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/list-node [(n/token-node 1)\n                     (n/spaces 1)\n                     (n/token-node 2)\n                     (n/spaces 1)\n                     (n/token-node 3)])\n       n/string)\n   ;; => \"(1 2 3)\"\n   ```"],"^X","^4I","^7","rewrite_clj/node.cljc","^;",16,"^78",["^1L",[["^7H"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",554,"^7B","^7O","^:",554,"^77",1,"^7@",true,"^70",["^1L",["^71",["^1L",[["^7H"]]]]],"^6","Create a node representing a list with `children`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/list-node [(n/token-node 1)\n                     (n/spaces 1)\n                     (n/token-node 2)\n                     (n/spaces 1)\n                     (n/token-node 3)])\n       n/string)\n   ;; => \"(1 2 3)\"\n   ```"],"~$sexpr",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",156,"^9",7,"^:",156,"^;",12,"^70",["^1L",["^71",["^1L",[["^72"],["^72","^73"]]]]],"^6","Return `node` converted to form.\n\n  Optional `opts` can specify:\n  - `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)\n\n  See docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances).","^74",["^ ","^75",false,"^76",2,"^77",2,"^78",[["^72"],["^72","^73"]],"^70",["^1L",[["^72"],["^72","^73"]]],"^79",["^1L",[null,null]]]],"^X","^25","^7","rewrite_clj/node.cljc","^;",12,"^74",["^ ","^75",false,"^76",2,"^77",2,"^78",[["^72"],["^72","^73"]],"^70",["^1L",[["^72"],["^72","^73"]]],"^79",["^1L",[null,null]]],"^78",[["^72"],["^72","^73"]],"^7:",null,"^76",2,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^7;",[["^ ","^76",1,"^75",false,"^7<","^7="],["^ ","^76",2,"^75",false,"^7<","^7="]],"^8",156,"^:",156,"^77",2,"^7@",true,"^70",["^1L",[["^72"],["^72","^73"]]],"^6","Return `node` converted to form.\n\n  Optional `opts` can specify:\n  - `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)\n\n  See docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances)."],"~$namespaced-map-node",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",430,"^9",7,"^:",430,"^;",26,"^70",["^1L",["^71",["^1L",[["^7H"]]]]],"^6","Create a namespaced map node with `children`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n]) \n   \n   (-> (n/namespaced-map-node [(n/map-qualifier-node true \"my-ns-alias\")\n                               (n/spaces 1)\n                               (n/map-node [(n/keyword-node :a)\n                                            (n/spaces 1)\n                                            (n/token-node 1)])])\n       n/string)\n   ;; => \"#::my-ns-alias {:a 1}\"\n   ``` \n   \n   Map qualifier context is automatically applied to map keys for sexpr support.\n\n   See also [[map-qualifier-node]] and [[map-node]]."],"^X","^26","^7","rewrite_clj/node.cljc","^;",26,"^78",["^1L",[["^7H"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",430,"^7B","~$rewrite-clj.node.namespaced-map/NamespacedMapNode","^:",430,"^77",1,"^7@",true,"^70",["^1L",["^71",["^1L",[["^7H"]]]]],"^6","Create a namespaced map node with `children`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n]) \n   \n   (-> (n/namespaced-map-node [(n/map-qualifier-node true \"my-ns-alias\")\n                               (n/spaces 1)\n                               (n/map-node [(n/keyword-node :a)\n                                            (n/spaces 1)\n                                            (n/token-node 1)])])\n       n/string)\n   ;; => \"#::my-ns-alias {:a 1}\"\n   ``` \n   \n   Map qualifier context is automatically applied to map keys for sexpr support.\n\n   See also [[map-qualifier-node]] and [[map-node]]."],"^7T",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",205,"^9",30,"^:",205,"^;",35,"~:deprecated","0.4.0","^70",["^1L",["^71",["^1L",[["^72"]]]]],"^6","DEPRECATED: Get first child as a pair of tag/sexpr (if inner node),\n   or just the node's own sexpr. (use explicit analysis of `children`\n   `child-sexprs` instead) "],"^X","^27","^7","rewrite_clj/node.cljc","^;",35,"^78",["^1L",[["^72"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",205,"^8K","0.4.0","^7B",["^U",["^7=","^7?"]],"^:",205,"^77",1,"^7@",true,"^70",["^1L",["^71",["^1L",[["^72"]]]]],"^6","DEPRECATED: Get first child as a pair of tag/sexpr (if inner node),\n   or just the node's own sexpr. (use explicit analysis of `children`\n   `child-sexprs` instead) "],"~$syntax-quote-node",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",696,"^9",7,"^:",696,"^;",24,"^70",["^1L",["^71",["^1L",[["^7H"]]]]],"^6","Create node representing a single syntax-quoted form where `children`\n   is either a sequence of nodes or a single node.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n]) \n\n   (-> (n/syntax-quote-node (n/token-node 'map))\n       n/string)\n   ;; => \"`map\"\n\n   ;; specifying a sequence allows for whitespace between the \n   ;; syntax quote and the syntax quoted\n   (-> (n/syntax-quote-node [(n/spaces 3)\n                             (n/token-node 'map)])\n       n/string)\n   ;; => \"`   map\"\n   ```"],"^X","^24","^7","rewrite_clj/node.cljc","^;",24,"^78",["^1L",[["^7H"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",696,"^7B","~$rewrite-clj.node.quote/QuoteNode","^:",696,"^77",1,"^7@",true,"^70",["^1L",["^71",["^1L",[["^7H"]]]]],"^6","Create node representing a single syntax-quoted form where `children`\n   is either a sequence of nodes or a single node.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n]) \n\n   (-> (n/syntax-quote-node (n/token-node 'map))\n       n/string)\n   ;; => \"`map\"\n\n   ;; specifying a sequence allows for whitespace between the \n   ;; syntax quote and the syntax quoted\n   (-> (n/syntax-quote-node [(n/spaces 3)\n                             (n/token-node 'map)])\n       n/string)\n   ;; => \"`   map\"\n   ```"],"~$comma-node",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",834,"^9",7,"^:",834,"^;",17,"^70",["^1L",["^71",["^1L",[["~$s"]]]]],"^6","Create comma node of string `s`, where `s` is one or more comma characters."],"^X","^2:","^7","rewrite_clj/node.cljc","^;",17,"^78",["^1L",[["~$s"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",834,"^7B","~$rewrite-clj.node.whitespace/CommaNode","^:",834,"^77",1,"^7@",true,"^70",["^1L",["^71",["^1L",[["~$s"]]]]],"^6","Create comma node of string `s`, where `s` is one or more comma characters."],"~$newline-node",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",814,"^9",7,"^:",814,"^;",19,"^70",["^1L",["^71",["^1L",[["~$s"]]]]],"^6","Create newline node of string `s`, where `s` is one or more linebreak characters."],"^X","^2;","^7","rewrite_clj/node.cljc","^;",19,"^78",["^1L",[["~$s"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",814,"^7B","^7Z","^:",814,"^77",1,"^7@",true,"^70",["^1L",["^71",["^1L",[["~$s"]]]]],"^6","Create newline node of string `s`, where `s` is one or more linebreak characters."],"~$unquote-splicing-node",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",738,"^9",7,"^:",738,"^;",28,"^70",["^1L",["^71",["^1L",[["^7H"]]]]],"^6","Create node representing a single unquote-spliced form where `children`\n   is either a sequence of nodes or a single node.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n]) \n\n   (-> (n/unquote-splicing-node (n/token-node 'my-var))\n       n/string)\n   ;; => \"~@my-var\"\n\n   ;; specifying a sequence allows for whitespace between the \n   ;; splicing unquote and the splicing unquoted\n   (-> (n/unquote-splicing-node [(n/spaces 2)\n                                 (n/token-node 'my-var)])\n       n/string)\n   ;; => \"~@  my-var\"   \n   ```"],"^X","^2?","^7","rewrite_clj/node.cljc","^;",28,"^78",["^1L",[["^7H"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",738,"^7B","^8M","^:",738,"^77",1,"^7@",true,"^70",["^1L",["^71",["^1L",[["^7H"]]]]],"^6","Create node representing a single unquote-spliced form where `children`\n   is either a sequence of nodes or a single node.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n]) \n\n   (-> (n/unquote-splicing-node (n/token-node 'my-var))\n       n/string)\n   ;; => \"~@my-var\"\n\n   ;; specifying a sequence allows for whitespace between the \n   ;; splicing unquote and the splicing unquoted\n   (-> (n/unquote-splicing-node [(n/spaces 2)\n                                 (n/token-node 'my-var)])\n       n/string)\n   ;; => \"~@  my-var\"   \n   ```"],"~$map-node",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",571,"^9",7,"^:",571,"^;",15,"^70",["^1L",["^71",["^1L",[["^7H"]]]]],"^6","Create a node representing a map with `children`.\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/map-node [(n/keyword-node :a)\n                    (n/spaces 1)\n                    (n/token-node 1)\n                    (n/spaces 1)\n                    (n/keyword-node :b)\n                    (n/spaces 1)\n                    (n/token-node 2)])\n       (n/string))\n   ;; => \"{:a 1 :b 2}\"\n   ```\n\n   Note that rewrite-clj allows the, technically illegal, unbalanced map:\n   ```Clojure\n   (-> (n/map-node [(n/keyword-node :a)])\n       (n/string))\n   ;; => \"{:a}\"\n   ```\n   See [docs on unbalanced maps](/doc/01-user-guide.adoc#unbalanced-maps).\n\n   Rewrite-clj also allows the, also technically illegal, map with duplicate keys:\n   ```Clojure\n   (-> (n/map-node [(n/keyword-node :a)\n                    (n/spaces 1)\n                    (n/token-node 1)\n                    (n/spaces 1)\n                    (n/keyword-node :a)\n                    (n/spaces 1)\n                    (n/token-node 2)])\n       (n/string))\n   ;; => \"{:a 1 :a 2}\"\n   ```\n   See [docs on maps with duplicate keys](/doc/01-user-guide.adoc#maps-with-duplicate-keys)."],"^X","^2E","^7","rewrite_clj/node.cljc","^;",15,"^78",["^1L",[["^7H"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",571,"^7B","^7O","^:",571,"^77",1,"^7@",true,"^70",["^1L",["^71",["^1L",[["^7H"]]]]],"^6","Create a node representing a map with `children`.\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/map-node [(n/keyword-node :a)\n                    (n/spaces 1)\n                    (n/token-node 1)\n                    (n/spaces 1)\n                    (n/keyword-node :b)\n                    (n/spaces 1)\n                    (n/token-node 2)])\n       (n/string))\n   ;; => \"{:a 1 :b 2}\"\n   ```\n\n   Note that rewrite-clj allows the, technically illegal, unbalanced map:\n   ```Clojure\n   (-> (n/map-node [(n/keyword-node :a)])\n       (n/string))\n   ;; => \"{:a}\"\n   ```\n   See [docs on unbalanced maps](/doc/01-user-guide.adoc#unbalanced-maps).\n\n   Rewrite-clj also allows the, also technically illegal, map with duplicate keys:\n   ```Clojure\n   (-> (n/map-node [(n/keyword-node :a)\n                    (n/spaces 1)\n                    (n/token-node 1)\n                    (n/spaces 1)\n                    (n/keyword-node :a)\n                    (n/spaces 1)\n                    (n/token-node 2)])\n       (n/string))\n   ;; => \"{:a 1 :a 2}\"\n   ```\n   See [docs on maps with duplicate keys](/doc/01-user-guide.adoc#maps-with-duplicate-keys)."],"^V",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",195,"^9",7,"^:",195,"^;",13,"^70",["^1L",["^71",["^1L",[["^72"]]]]],"^6","Return the string version of `node`."],"^X","^2B","^7","rewrite_clj/node.cljc","^;",13,"^78",["^1L",[["^72"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",195,"^7B","^7=","^:",195,"^77",1,"^7@",true,"^70",["^1L",["^71",["^1L",[["^72"]]]]],"^6","Return the string version of `node`."],"~$map-context-apply",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",185,"^9",7,"^:",185,"^;",24,"^70",["^1L",["^71",["^1L",[["^72","~$map-qualifier"]]]]],"^6","Applies `map-qualifier` context to `node`"],"^X","^2G","^7","rewrite_clj/node.cljc","^;",24,"^78",["^1L",[["^72","^8T"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",185,"^7B","^7=","^:",185,"^77",2,"^7@",true,"^70",["^1L",["^71",["^1L",[["^72","^8T"]]]]],"^6","Applies `map-qualifier` context to `node`"],"~$reader-macro-node",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",510,"^9",7,"^:",510,"^;",24,"^70",["^1L",["^71",["^1L",[["^7H"],["~$macro-node","~$form-node"]]]]],"^6","Create node representing a reader macro with `macro-node` and `form-node` or `children`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])  \n\n   ;; here we call with macro-node and form-node\n   (-> (n/reader-macro-node (n/token-node 'my-macro) \n                            (n/token-node 42))\n       n/string)\n   ;; => \"#my-macro 42\"\n\n   ;; calling with a sequence of children gives us control over whitespace\n   (-> (n/reader-macro-node [(n/token-node 'my-macro)\n                             (n/spaces 4)\n                             (n/token-node 42)])\n       n/string)\n   ;; => \"#my-macro    42\" \n   ```","^74",["^ ","^75",false,"^76",2,"^77",2,"^78",[["^7H"],["^8V","^8W"]],"^70",["^1L",[["^7H"],["^8V","^8W"]]],"^79",["^1L",[null,null]]]],"^X","^2M","^7","rewrite_clj/node.cljc","^;",24,"^74",["^ ","^75",false,"^76",2,"^77",2,"^78",[["^7H"],["^8V","^8W"]],"^70",["^1L",[["^7H"],["^8V","^8W"]]],"^79",["^1L",[null,null]]],"^78",[["^7H"],["^8V","^8W"]],"^7:",null,"^76",2,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^7;",[["^ ","^76",1,"^75",false,"^7<","~$rewrite-clj.node.reader-macro/ReaderMacroNode"],["^ ","^76",2,"^75",false,"^7<","^8X"]],"^8",510,"^:",510,"^77",2,"^7@",true,"^70",["^1L",[["^7H"],["^8V","^8W"]]],"^6","Create node representing a reader macro with `macro-node` and `form-node` or `children`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])  \n\n   ;; here we call with macro-node and form-node\n   (-> (n/reader-macro-node (n/token-node 'my-macro) \n                            (n/token-node 42))\n       n/string)\n   ;; => \"#my-macro 42\"\n\n   ;; calling with a sequence of children gives us control over whitespace\n   (-> (n/reader-macro-node [(n/token-node 'my-macro)\n                             (n/spaces 4)\n                             (n/token-node 42)])\n       n/string)\n   ;; => \"#my-macro    42\" \n   ```"],"~$comment?",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",236,"^9",7,"^:",236,"^;",15,"^70",["^1L",["^71",["^1L",[["^72"]]]]],"^6","Returns true if `node` is a comment."],"^X","^2N","^7","rewrite_clj/node.cljc","^;",15,"^78",["^1L",[["^72"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",236,"^7B","^7D","^:",236,"^77",1,"^7@",true,"^70",["^1L",["^71",["^1L",[["^72"]]]]],"^6","Returns true if `node` is a comment."],"~$spaces",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",819,"^9",7,"^:",819,"^;",13,"^70",["^1L",["^71",["^1L",[["~$n"]]]]],"^6","Create node representing `n` spaces."],"^X","^2R","^7","rewrite_clj/node.cljc","^;",13,"^78",["^1L",[["~$n"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",819,"^7B","^7F","^:",819,"^77",1,"^7@",true,"^70",["^1L",["^71",["^1L",[["~$n"]]]]],"^6","Create node representing `n` spaces."],"~$raw-meta-node",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",371,"^9",7,"^:",371,"^;",20,"^70",["^1L",["^71",["^1L",[["^7H"],["^89","^8:"]]]]],"^6","Create a node representing a form with metadata that renders to the reader syntax.\n   \n   When creating manually, you can specify `metadata` and `data` and spacing between the 2 elems will be included: \n\n   ```Clojure\n   (require '[rewrite-clj.node :as n]) \n\n   (-> (n/raw-meta-node (n/keyword-node :foo)\n                        (n/vector-node [(n/token-node 2)]))\n        n/string)\n   ;; => \"#^:foo [2]\"\n   \n   (-> (n/raw-meta-node (n/map-node [:foo (n/spaces 1) 42])\n                        (n/vector-node [(n/token-node 2)]))\n       n/string)\n   ;; => \"#^{:foo 42} [2]\"\n   ``` \n   When specifying a sequence of `children`, spacing is explicit:\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n]) \n   \n   (-> (n/raw-meta-node [(n/keyword-node :foo)\n                         (n/spaces 1)\n                         (n/vector-node [(n/token-node 2)])])\n       n/string)\n   ;; => \"#^:foo [2]\"\n   ```\n   See also: [[meta-node]]","^74",["^ ","^75",false,"^76",2,"^77",2,"^78",[["^7H"],["^89","^8:"]],"^70",["^1L",[["^7H"],["^89","^8:"]]],"^79",["^1L",[null,null]]]],"^X","^2W","^7","rewrite_clj/node.cljc","^;",20,"^74",["^ ","^75",false,"^76",2,"^77",2,"^78",[["^7H"],["^89","^8:"]],"^70",["^1L",[["^7H"],["^89","^8:"]]],"^79",["^1L",[null,null]]],"^78",[["^7H"],["^89","^8:"]],"^7:",null,"^76",2,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^7;",[["^ ","^76",1,"^75",false,"^7<","^8;"],["^ ","^76",2,"^75",false,"^7<","^8;"]],"^8",371,"^:",371,"^77",2,"^7@",true,"^70",["^1L",[["^7H"],["^89","^8:"]]],"^6","Create a node representing a form with metadata that renders to the reader syntax.\n   \n   When creating manually, you can specify `metadata` and `data` and spacing between the 2 elems will be included: \n\n   ```Clojure\n   (require '[rewrite-clj.node :as n]) \n\n   (-> (n/raw-meta-node (n/keyword-node :foo)\n                        (n/vector-node [(n/token-node 2)]))\n        n/string)\n   ;; => \"#^:foo [2]\"\n   \n   (-> (n/raw-meta-node (n/map-node [:foo (n/spaces 1) 42])\n                        (n/vector-node [(n/token-node 2)]))\n       n/string)\n   ;; => \"#^{:foo 42} [2]\"\n   ``` \n   When specifying a sequence of `children`, spacing is explicit:\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n]) \n   \n   (-> (n/raw-meta-node [(n/keyword-node :foo)\n                         (n/spaces 1)\n                         (n/vector-node [(n/token-node 2)])])\n       n/string)\n   ;; => \"#^:foo [2]\"\n   ```\n   See also: [[meta-node]]"],"~$comment-node",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",212,"^9",7,"^:",212,"^;",19,"^70",["^1L",["^71",["^1L",[["~$s"],["^8@","~$s"]]]]],"^6","Create node representing a comment with text `s`.\n\n   You may optionally specify a `prefix` of `\";\"` or `\"#!\"`, defaults is `\";\"`.\n\n   Argument `s`:\n   - must not include the `prefix`\n   - usually includes the trailing newline character, otherwise subsequent nodes will be on the comment line\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/comment-node \"; my comment\\n\")\n       n/string)\n   ;; => \";; my comment\\n\"\n\n   (-> (n/comment-node \"#!\" \"/usr/bin/env bb\\n\")\n       n/string)\n   ;; => \"#!/usr/bin/env bb\\n\"\n   ```","^74",["^ ","^75",false,"^76",2,"^77",2,"^78",[["~$s"],["^8@","~$s"]],"^70",["^1L",[["~$s"],["^8@","~$s"]]],"^79",["^1L",[null,null]]]],"^X","^2V","^7","rewrite_clj/node.cljc","^;",19,"^74",["^ ","^75",false,"^76",2,"^77",2,"^78",[["~$s"],["^8@","~$s"]],"^70",["^1L",[["~$s"],["^8@","~$s"]]],"^79",["^1L",[null,null]]],"^78",[["~$s"],["^8@","~$s"]],"^7:",null,"^76",2,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^7;",[["^ ","^76",1,"^75",false,"^7<","^7="],["^ ","^76",2,"^75",false,"^7<","~$rewrite-clj.node.comment/CommentNode"]],"^8",212,"^:",212,"^77",2,"^7@",true,"^70",["^1L",[["~$s"],["^8@","~$s"]]],"^6","Create node representing a comment with text `s`.\n\n   You may optionally specify a `prefix` of `\";\"` or `\"#!\"`, defaults is `\";\"`.\n\n   Argument `s`:\n   - must not include the `prefix`\n   - usually includes the trailing newline character, otherwise subsequent nodes will be on the comment line\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/comment-node \"; my comment\\n\")\n       n/string)\n   ;; => \";; my comment\\n\"\n\n   (-> (n/comment-node \"#!\" \"/usr/bin/env bb\\n\")\n       n/string)\n   ;; => \"#!/usr/bin/env bb\\n\"\n   ```"],"~$set-node",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",611,"^9",7,"^:",611,"^;",15,"^70",["^1L",["^71",["^1L",[["^7H"]]]]],"^6","Create a node representing a set with `children`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/set-node [(n/token-node 1)\n                    (n/spaces 1)\n                    (n/token-node 2)\n                    (n/spaces 1)\n                    (n/token-node 3)])\n       n/string)\n   ;; => \"#{1 2 3}\"\n   ```\n\n   Note that rewrite-clj allows the, technically illegal, set with duplicate values:\n   ```Clojure\n   (-> (n/set-node [(n/token-node 1)\n                    (n/spaces 1)\n                    (n/token-node 1)])\n       (n/string))\n   ;; => \"#{1 1}\"\n   ```\n\n   See [docs on sets with duplicate values](/doc/01-user-guide.adoc#sets-with-duplicate-values)."],"^X","^2Q","^7","rewrite_clj/node.cljc","^;",15,"^78",["^1L",[["^7H"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",611,"^7B","^7O","^:",611,"^77",1,"^7@",true,"^70",["^1L",["^71",["^1L",[["^7H"]]]]],"^6","Create a node representing a set with `children`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/set-node [(n/token-node 1)\n                    (n/spaces 1)\n                    (n/token-node 2)\n                    (n/spaces 1)\n                    (n/token-node 3)])\n       n/string)\n   ;; => \"#{1 2 3}\"\n   ```\n\n   Note that rewrite-clj allows the, technically illegal, set with duplicate values:\n   ```Clojure\n   (-> (n/set-node [(n/token-node 1)\n                    (n/spaces 1)\n                    (n/token-node 1)])\n       (n/string))\n   ;; => \"#{1 1}\"\n   ```\n\n   See [docs on sets with duplicate values](/doc/01-user-guide.adoc#sets-with-duplicate-values)."],"~$keyword-node",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",302,"^9",7,"^:",302,"^;",19,"^70",["^1L",["^71",["^1L",[["~$k","^8?"],["~$k"]]]]],"^6","Create a node representing a keyword `k`. \n\n   Optionally include `auto-resolved?`, which defaults to `false`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n]) \n\n   ;; unqualified keyword\n   (-> (n/keyword-node :kw)\n       n/string)\n   ;; => \":kw\"\n\n   ;; qualified keyword\n   (-> (n/keyword-node :my-prefix/kw)\n       n/string)\n   ;; => \":my-prefix/kw\"\n\n   ;; keyword auto-resolved to current ns\n   (-> (n/keyword-node :kw true)\n       n/string)\n   ;; => \"::kw\"\n\n   ;; keyword auto-resolved to a namespace with given alias\n   (-> (n/keyword-node :ns-alias/kw true)\n       n/string)\n   ;; => \"::ns-alias/kw\"\n   ```","^74",["^ ","^75",false,"^76",2,"^77",2,"^78",[["~$k","^8?"],["~$k"]],"^70",["^1L",[["~$k","^8?"],["~$k"]]],"^79",["^1L",[null,null]]]],"^X","^2T","^7","rewrite_clj/node.cljc","^;",19,"^74",["^ ","^75",false,"^76",2,"^77",2,"^78",[["~$k","^8?"],["~$k"]],"^70",["^1L",[["~$k","^8?"],["~$k"]]],"^79",["^1L",[null,null]]],"^78",[["~$k","^8?"],["~$k"]],"^7:",null,"^76",2,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^7;",[["^ ","^76",2,"^75",false,"^7<","~$rewrite-clj.node.keyword/KeywordNode"],["^ ","^76",1,"^75",false,"^7<","^94"]],"^8",302,"^:",302,"^77",2,"^7@",true,"^70",["^1L",[["~$k","^8?"],["~$k"]]],"^6","Create a node representing a keyword `k`. \n\n   Optionally include `auto-resolved?`, which defaults to `false`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n]) \n\n   ;; unqualified keyword\n   (-> (n/keyword-node :kw)\n       n/string)\n   ;; => \":kw\"\n\n   ;; qualified keyword\n   (-> (n/keyword-node :my-prefix/kw)\n       n/string)\n   ;; => \":my-prefix/kw\"\n\n   ;; keyword auto-resolved to current ns\n   (-> (n/keyword-node :kw true)\n       n/string)\n   ;; => \"::kw\"\n\n   ;; keyword auto-resolved to a namespace with given alias\n   (-> (n/keyword-node :ns-alias/kw true)\n       n/string)\n   ;; => \"::ns-alias/kw\"\n   ```"],"~$symbol-node?",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",775,"^9",7,"^:",775,"^;",19,"^70",["^1L",["^71",["^1L",[["~$n"]]]]],"^6","Returns true if `n` is a node representing a symbol."],"^X","^2Z","^7","rewrite_clj/node.cljc","^;",19,"^78",["^1L",[["~$n"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",775,"^7B","^7D","^:",775,"^77",1,"^7@",true,"^70",["^1L",["^71",["^1L",[["~$n"]]]]],"^6","Returns true if `n` is a node representing a symbol."],"~$length",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",136,"^9",7,"^:",136,"^;",13,"^70",["^1L",["^71",["^1L",[["^72"]]]]],"^6","Return number of characters for the string version of `node`."],"^X","^30","^7","rewrite_clj/node.cljc","^;",13,"^78",["^1L",[["^72"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",136,"^7B","^7=","^:",136,"^77",1,"^7@",true,"^70",["^1L",["^71",["^1L",[["^72"]]]]],"^6","Return number of characters for the string version of `node`."],"~$quote-node",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",675,"^9",7,"^:",675,"^;",17,"^70",["^1L",["^71",["^1L",[["^7H"]]]]],"^6","Create node representing a single quoted form where `children`\n   is either a sequence of nodes or a single node.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n]) \n\n   (-> (n/quote-node (n/token-node 'sym))\n       (n/string))\n   ;; => \"'sym\"\n\n   ;; specifying a sequence allows for whitespace between the \n   ;; quote and the quoted\n   (-> (n/quote-node [(n/spaces 10)\n                      (n/token-node 'sym1) ])\n       n/string)\n   ;; => \"'          sym1\"\n   ```"],"^X","^32","^7","rewrite_clj/node.cljc","^;",17,"^78",["^1L",[["^7H"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",675,"^7B","^8M","^:",675,"^77",1,"^7@",true,"^70",["^1L",["^71",["^1L",[["^7H"]]]]],"^6","Create node representing a single quoted form where `children`\n   is either a sequence of nodes or a single node.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n]) \n\n   (-> (n/quote-node (n/token-node 'sym))\n       (n/string))\n   ;; => \"'sym\"\n\n   ;; specifying a sequence allows for whitespace between the \n   ;; quote and the quoted\n   (-> (n/quote-node [(n/spaces 10)\n                      (n/token-node 'sym1) ])\n       n/string)\n   ;; => \"'          sym1\"\n   ```"],"~$unquote-node",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",717,"^9",7,"^:",717,"^;",19,"^70",["^1L",["^71",["^1L",[["^7H"]]]]],"^6","Create node representing a single unquoted form where `children`\n   is either a sequence of nodes or a single node.\n   \n   ```Clojure\n   (require '[rewrite-clj.node :as n]) \n\n   (-> (n/unquote-node (n/token-node 'my-var))\n       n/string)\n   ;; => \"~my-var\"\n\n   ;; specifying a sequence allows for whitespace between the \n   ;; unquote and the uquoted\n   (-> (n/unquote-node [(n/spaces 4)\n                        (n/token-node 'my-var)])\n       n/string)\n   ;; => \"~    my-var\"\n   ```"],"^X","^31","^7","rewrite_clj/node.cljc","^;",19,"^78",["^1L",[["^7H"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",717,"^7B","^8M","^:",717,"^77",1,"^7@",true,"^70",["^1L",["^71",["^1L",[["^7H"]]]]],"^6","Create node representing a single unquoted form where `children`\n   is either a sequence of nodes or a single node.\n   \n   ```Clojure\n   (require '[rewrite-clj.node :as n]) \n\n   (-> (n/unquote-node (n/token-node 'my-var))\n       n/string)\n   ;; => \"~my-var\"\n\n   ;; specifying a sequence allows for whitespace between the \n   ;; unquote and the uquoted\n   (-> (n/unquote-node [(n/spaces 4)\n                        (n/token-node 'my-var)])\n       n/string)\n   ;; => \"~    my-var\"\n   ```"],"~$node?",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",141,"^9",7,"^:",141,"^;",12,"^70",["^1L",["^71",["^1L",[["~$x"]]]]],"^6","Returns true if `x` is a rewrite-clj created node."],"^X","^34","^7","rewrite_clj/node.cljc","^;",12,"^78",["^1L",[["~$x"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",141,"^7B","^7D","^:",141,"^77",1,"^7@",true,"^70",["^1L",["^71",["^1L",[["~$x"]]]]],"^6","Returns true if `x` is a rewrite-clj created node."],"~$uneval-node",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",780,"^9",7,"^:",780,"^;",18,"^70",["^1L",["^71",["^1L",[["^7H"]]]]],"^6","Create node representing an unevaled form with `children`.\n   \n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/uneval-node [(n/spaces 1)\n                       (n/token-node 42)])\n       n/string)\n   ;; => \"#_ 42\"\n   ```"],"^X","^33","^7","rewrite_clj/node.cljc","^;",18,"^78",["^1L",[["^7H"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",780,"^7B","~$rewrite-clj.node.uneval/UnevalNode","^:",780,"^77",1,"^7@",true,"^70",["^1L",["^71",["^1L",[["^7H"]]]]],"^6","Create node representing an unevaled form with `children`.\n   \n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/uneval-node [(n/spaces 1)\n                       (n/token-node 42)])\n       n/string)\n   ;; => \"#_ 42\"\n   ```"],"~$keyword-node?",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",334,"^9",7,"^:",334,"^;",20,"^70",["^1L",["^71",["^1L",[["~$n"]]]]],"^6","Returns true if `n` is a node representing a keyword."],"^X","^36","^7","rewrite_clj/node.cljc","^;",20,"^78",["^1L",[["~$n"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",334,"^7B","^7D","^:",334,"^77",1,"^7@",true,"^70",["^1L",["^71",["^1L",[["~$n"]]]]],"^6","Returns true if `n` is a node representing a keyword."],"~$line-separated",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",799,"^9",7,"^:",799,"^;",21,"^70",["^1L",["^71",["^1L",[["^7X"]]]]],"^6","Interleave `nodes` with newline nodes."],"^X","^3<","^7","rewrite_clj/node.cljc","^;",21,"^78",["^1L",[["^7X"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",799,"^7B","~$seq","^:",799,"^77",1,"^7@",true,"^70",["^1L",["^71",["^1L",[["^7X"]]]]],"^6","Interleave `nodes` with newline nodes."],"~$token-node",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",759,"^9",7,"^:",759,"^;",17,"^70",["^1L",["^71",["^1L",[["^7T"],["^7T","~$string-value"]]]]],"^6","Create node for an unspecified token of `value`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/token-node 'sym) n/string)\n   ;; => \"sym\"\n\n   (-> (n/token-node 42) n/string)\n   ;; => \"42\"\n   ```","^74",["^ ","^75",false,"^76",2,"^77",2,"^78",[["^7T"],["^7T","^9@"]],"^70",["^1L",[["^7T"],["^7T","^9@"]]],"^79",["^1L",[null,null]]]],"^X","^38","^7","rewrite_clj/node.cljc","^;",17,"^74",["^ ","^75",false,"^76",2,"^77",2,"^78",[["^7T"],["^7T","^9@"]],"^70",["^1L",[["^7T"],["^7T","^9@"]]],"^79",["^1L",[null,null]]],"^78",[["^7T"],["^7T","^9@"]],"^7:",null,"^76",2,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^7;",[["^ ","^76",1,"^75",false,"^7<","^7="],["^ ","^76",2,"^75",false,"^7<","~$clj"]],"^8",759,"^:",759,"^77",2,"^7@",true,"^70",["^1L",[["^7T"],["^7T","^9@"]]],"^6","Create node for an unspecified token of `value`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/token-node 'sym) n/string)\n   ;; => \"sym\"\n\n   (-> (n/token-node 42) n/string)\n   ;; => \"42\"\n   ```"],"~$whitespace-or-comment?",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",241,"^9",7,"^:",241,"^;",29,"^70",["^1L",["^71",["^1L",[["^72"]]]]],"^6","Check whether the given node represents whitespace or comment."],"^X","^39","^7","rewrite_clj/node.cljc","^;",29,"^78",["^1L",[["^72"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",241,"^7B","^7D","^:",241,"^77",1,"^7@",true,"^70",["^1L",["^71",["^1L",[["^72"]]]]],"^6","Check whether the given node represents whitespace or comment."],"^W",["^ ","^6[",null,"^5",["^ ","^7","rewrite_clj/node.cljc","^8",107,"^9",7,"^:",107,"^;",13,"^70",["^1L",["^71",["^1L",[["~$form"]]]]],"^6","Coerce `form` to node."],"^X","^3:","^7","rewrite_clj/node.cljc","^;",13,"^78",["^1L",[["^9C"]]],"^7:",null,"^79",["^1L",[null,null]],"^9",1,"^75",false,"^8",107,"^7B","^7=","^:",107,"^77",1,"^7@",true,"^70",["^1L",["^71",["^1L",[["^9C"]]]]],"^6","Coerce `form` to node."]],"^1J",["^ ","^19","^19","^1C","^1C"],"^1P",["^ ","^1H",["^U",[]]],"^1Q",["^ "],"^1R",["^1:","^19","^1F","^1>","^18","^1;","^1E","^15","^1=","^14","^1D","^1@","^1?","^1<","^1B","^17","^13","^16","^1A","^1C"]],"^10","^Y","~:ns-specs",["^ "],"~:ns-spec-vars",["^U",[]],"~:compiler-options",["^4P",[["^9F","~:static-fns"],true,["^9F","~:shadow-tweaks"],null,["^9F","~:source-map-inline"],null,["^9F","~:elide-asserts"],false,["^9F","~:optimize-constants"],null,["^9F","^1W"],null,["^9F","~:external-config"],null,["^9F","~:tooling-config"],null,["^9F","~:emit-constants"],null,["^9F","~:load-tests"],null,["^9F","~:form-size-threshold"],null,["^9F","~:global-goog-object&array"],null,["^9F","~:data-readers"],null,["^9F","~:infer-externs"],"~:auto",["^9F","^1Y"],null,["~:js-options","~:js-provider"],"~:shadow",["~:mode"],"~:dev",["^9F","~:fn-invoke-direct"],null,["^9F","~:source-map"],"/dev/null"]]]