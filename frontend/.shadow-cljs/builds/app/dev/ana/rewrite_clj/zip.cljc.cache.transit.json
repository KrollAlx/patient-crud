["^ ","~:output",["^ ","~:js","goog.provide('rewrite_clj.zip');\n/**\n * Returns the current node in `zloc`.\n */\nrewrite_clj.zip.node = (function rewrite_clj$zip$node(zloc){\nreturn rewrite_clj.custom_zipper.core.node(zloc);\n});\n/**\n * Returns the ones-based `[row col]` of the start of the current node in `zloc`.\n * \n *   Throws if `zloc` was not created with [position tracking](/doc/01-user-guide.adoc#position-tracking).\n */\nrewrite_clj.zip.position = (function rewrite_clj$zip$position(zloc){\nreturn rewrite_clj.custom_zipper.core.position(zloc);\n});\n/**\n * Returns the ones-based `[[start-row start-col] [end-row end-col]]` of the current node in `zloc`.\n *   `end-col` is exclusive.\n * \n *   Throws if `zloc` was not created with [position tracking](/doc/01-user-guide.adoc#position-tracking).\n */\nrewrite_clj.zip.position_span = (function rewrite_clj$zip$position_span(zloc){\nreturn rewrite_clj.custom_zipper.core.position_span(zloc);\n});\n/**\n * Zips all the way up `zloc` and returns the root node, reflecting any changes.\n */\nrewrite_clj.zip.root = (function rewrite_clj$zip$root(zloc){\nreturn rewrite_clj.custom_zipper.core.root(zloc);\n});\n/**\n * Return s-expression (the Clojure forms) of children of current node in `zloc`.\n * \n *   See docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances).\n */\nrewrite_clj.zip.child_sexprs = (function rewrite_clj$zip$child_sexprs(zloc){\nreturn rewrite_clj.zip.base.child_sexprs(zloc);\n});\n/**\n * Create and return zipper from Clojure/ClojureScript/EDN `node` (likely parsed by [[rewrite-clj.parse]]).\n * \n *   Optional `opts` can specify:\n *   - `:track-position?` set to `true` to enable ones-based row/column tracking, see [docs on position tracking](/doc/01-user-guide.adoc#position-tracking).\n *   - `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)\n */\nrewrite_clj.zip.edn_STAR_ = (function rewrite_clj$zip$edn_STAR_(var_args){\nvar G__41263 = arguments.length;\nswitch (G__41263) {\ncase 1:\nreturn rewrite_clj.zip.edn_STAR_.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn rewrite_clj.zip.edn_STAR_.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(rewrite_clj.zip.edn_STAR_.cljs$core$IFn$_invoke$arity$1 = (function (node){\nreturn rewrite_clj.zip.base.edn_STAR_.cljs$core$IFn$_invoke$arity$1(node);\n}));\n\n(rewrite_clj.zip.edn_STAR_.cljs$core$IFn$_invoke$arity$2 = (function (node,opts){\nreturn rewrite_clj.zip.base.edn_STAR_.cljs$core$IFn$_invoke$arity$2(node,opts);\n}));\n\n(rewrite_clj.zip.edn_STAR_.cljs$lang$maxFixedArity = 2);\n\n/**\n * Create and return zipper from Clojure/ClojureScript/EDN `node` (likely parsed by [[rewrite-clj.parse]]),\n *   and move to the first non-whitespace/non-comment child. If node is not forms node, is wrapped in forms node\n *   for a consistent root.\n * \n *   Optional `opts` can specify:\n *   - `:track-position?` set to `true` to enable ones-based row/column tracking, see [docs on position tracking](/doc/01-user-guide.adoc#position-tracking).\n *   - `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)\n */\nrewrite_clj.zip.edn = (function rewrite_clj$zip$edn(var_args){\nvar G__41269 = arguments.length;\nswitch (G__41269) {\ncase 1:\nreturn rewrite_clj.zip.edn.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn rewrite_clj.zip.edn.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(rewrite_clj.zip.edn.cljs$core$IFn$_invoke$arity$1 = (function (node){\nreturn rewrite_clj.zip.base.edn.cljs$core$IFn$_invoke$arity$1(node);\n}));\n\n(rewrite_clj.zip.edn.cljs$core$IFn$_invoke$arity$2 = (function (node,opts){\nreturn rewrite_clj.zip.base.edn.cljs$core$IFn$_invoke$arity$2(node,opts);\n}));\n\n(rewrite_clj.zip.edn.cljs$lang$maxFixedArity = 2);\n\n/**\n * Return tag of current node in `zloc`.\n */\nrewrite_clj.zip.tag = (function rewrite_clj$zip$tag(zloc){\nreturn rewrite_clj.zip.base.tag(zloc);\n});\n/**\n * Return s-expression (the Clojure form) of current node in `zloc`.\n * \n *   See docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances).\n */\nrewrite_clj.zip.sexpr = (function rewrite_clj$zip$sexpr(zloc){\nreturn rewrite_clj.zip.base.sexpr(zloc);\n});\n/**\n * Return true if current node's element type in `zloc` can be [[sexpr]]-ed.\n * \n * See [related docs in user guide](/doc/01-user-guide.adoc#not-all-clojure-is-sexpr-able)\n */\nrewrite_clj.zip.sexpr_able_QMARK_ = (function rewrite_clj$zip$sexpr_able_QMARK_(zloc){\nreturn rewrite_clj.zip.base.sexpr_able_QMARK_(zloc);\n});\n/**\n * Return length of printable [[string]] of current node in `zloc`.\n */\nrewrite_clj.zip.length = (function rewrite_clj$zip$length(zloc){\nreturn rewrite_clj.zip.base.length(zloc);\n});\n/**\n * DEPRECATED. Return a tag/s-expression pair for inner nodes, or\n * the s-expression itself for leaves.\n */\nrewrite_clj.zip.value = (function rewrite_clj$zip$value(zloc){\nreturn rewrite_clj.zip.base.value(zloc);\n});\n/**\n * Create and return zipper from all forms in Clojure/ClojureScript/EDN string `s`.\n * \n *   Optional `opts` can specify:\n *   - `:track-position?` set to `true` to enable ones-based row/column tracking, see [docs on position tracking](/doc/01-user-guide.adoc#position-tracking).\n *   - `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)\n */\nrewrite_clj.zip.of_string = (function rewrite_clj$zip$of_string(var_args){\nvar G__41273 = arguments.length;\nswitch (G__41273) {\ncase 1:\nreturn rewrite_clj.zip.of_string.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn rewrite_clj.zip.of_string.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(rewrite_clj.zip.of_string.cljs$core$IFn$_invoke$arity$1 = (function (s){\nreturn rewrite_clj.zip.base.of_string.cljs$core$IFn$_invoke$arity$1(s);\n}));\n\n(rewrite_clj.zip.of_string.cljs$core$IFn$_invoke$arity$2 = (function (s,opts){\nreturn rewrite_clj.zip.base.of_string.cljs$core$IFn$_invoke$arity$2(s,opts);\n}));\n\n(rewrite_clj.zip.of_string.cljs$lang$maxFixedArity = 2);\n\n/**\n * Return string representing the current node in `zloc`.\n */\nrewrite_clj.zip.string = (function rewrite_clj$zip$string(zloc){\nreturn rewrite_clj.zip.base.string(zloc);\n});\n/**\n * DEPRECATED. Renamed to [[string]].\n */\nrewrite_clj.zip.__GT_string = (function rewrite_clj$zip$__GT_string(zloc){\nreturn rewrite_clj.zip.base.__GT_string(zloc);\n});\n/**\n * Return string representing the zipped-up `zloc` zipper.\n */\nrewrite_clj.zip.root_string = (function rewrite_clj$zip$root_string(zloc){\nreturn rewrite_clj.zip.base.root_string(zloc);\n});\n/**\n * DEPRECATED. Renamed to [[root-string]].\n */\nrewrite_clj.zip.__GT_root_string = (function rewrite_clj$zip$__GT_root_string(zloc){\nreturn rewrite_clj.zip.base.__GT_root_string(zloc);\n});\n/**\n * Print current node in `zloc`.\n * \n * NOTE: Optional `writer` is currently ignored for ClojureScript.\n */\nrewrite_clj.zip.print = (function rewrite_clj$zip$print(var_args){\nvar G__41277 = arguments.length;\nswitch (G__41277) {\ncase 2:\nreturn rewrite_clj.zip.print.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 1:\nreturn rewrite_clj.zip.print.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(rewrite_clj.zip.print.cljs$core$IFn$_invoke$arity$2 = (function (zloc,writer){\nreturn rewrite_clj.zip.base.print.cljs$core$IFn$_invoke$arity$2(zloc,writer);\n}));\n\n(rewrite_clj.zip.print.cljs$core$IFn$_invoke$arity$1 = (function (zloc){\nreturn rewrite_clj.zip.base.print.cljs$core$IFn$_invoke$arity$1(zloc);\n}));\n\n(rewrite_clj.zip.print.cljs$lang$maxFixedArity = 2);\n\n/**\n * Zip up and print `zloc` from root node.\n * \n * NOTE: Optional `writer` is currently ignored for ClojureScript.\n */\nrewrite_clj.zip.print_root = (function rewrite_clj$zip$print_root(var_args){\nvar G__41279 = arguments.length;\nswitch (G__41279) {\ncase 2:\nreturn rewrite_clj.zip.print_root.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 1:\nreturn rewrite_clj.zip.print_root.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(rewrite_clj.zip.print_root.cljs$core$IFn$_invoke$arity$2 = (function (zloc,writer){\nreturn rewrite_clj.zip.base.print_root.cljs$core$IFn$_invoke$arity$2(zloc,writer);\n}));\n\n(rewrite_clj.zip.print_root.cljs$core$IFn$_invoke$arity$1 = (function (zloc){\nreturn rewrite_clj.zip.base.print_root.cljs$core$IFn$_invoke$arity$1(zloc);\n}));\n\n(rewrite_clj.zip.print_root.cljs$lang$maxFixedArity = 2);\n\n/**\n * Return `zloc` with the current node replaced by `value`.\n *   If `value` is not already a node, an attempt will be made to coerce it to one.\n */\nrewrite_clj.zip.replace = (function rewrite_clj$zip$replace(zloc,value){\nreturn rewrite_clj.zip.editz.replace(zloc,value);\n});\n/**\n * Return `zloc` with the current node replaced with the result of:\n * \n * `(apply f (s-expr current-node) args)`\n * \n *   The result of `f`, if not already a node, will be coerced to a node if possible.\n * \n *   See docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances).\n */\nrewrite_clj.zip.edit = (function rewrite_clj$zip$edit(var_args){\nvar args__5775__auto__ = [];\nvar len__5769__auto___41437 = arguments.length;\nvar i__5770__auto___41440 = (0);\nwhile(true){\nif((i__5770__auto___41440 < len__5769__auto___41437)){\nargs__5775__auto__.push((arguments[i__5770__auto___41440]));\n\nvar G__41443 = (i__5770__auto___41440 + (1));\ni__5770__auto___41440 = G__41443;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__5776__auto__ = ((((2) < args__5775__auto__.length))?(new cljs.core.IndexedSeq(args__5775__auto__.slice((2)),(0),null)):null);\nreturn rewrite_clj.zip.edit.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__5776__auto__);\n});\n\n(rewrite_clj.zip.edit.cljs$core$IFn$_invoke$arity$variadic = (function (zloc,f,args){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$4(rewrite_clj.zip.editz.edit,zloc,f,args);\n}));\n\n(rewrite_clj.zip.edit.cljs$lang$maxFixedArity = (2));\n\n/** @this {Function} */\n(rewrite_clj.zip.edit.cljs$lang$applyTo = (function (seq41282){\nvar G__41283 = cljs.core.first(seq41282);\nvar seq41282__$1 = cljs.core.next(seq41282);\nvar G__41284 = cljs.core.first(seq41282__$1);\nvar seq41282__$2 = cljs.core.next(seq41282__$1);\nvar self__5754__auto__ = this;\nreturn self__5754__auto__.cljs$core$IFn$_invoke$arity$variadic(G__41283,G__41284,seq41282__$2);\n}));\n\n/**\n * Return zipper with the children of the current node in `zloc` merged into itself.\n * (akin to Clojure's `unquote-splicing` macro: `~@...`).\n * - if the node is not one that can have children, no modification will\n *   be performed.\n * - if the node has no or only whitespace children, it will be removed.\n * - otherwise, splicing will be performed, moving the zipper to the first\n *   non-whitespace spliced child node.\n * \n *   For example, given `[[1 2 3] 4 5 6]`, if zloc is located at vector `[1 2 3]`, a splice will result in raising the vector's children up `[1 2 3 4 5 6]` and locating the zipper at node `1`.\n */\nrewrite_clj.zip.splice = (function rewrite_clj$zip$splice(zloc){\nreturn rewrite_clj.zip.editz.splice(zloc);\n});\n/**\n * Return zipper with the current node in `zloc` prefixed with string `s`.\n * Operates on token node or a multi-line node, else exception is thrown.\n * When multi-line, first line is prefixed.\n */\nrewrite_clj.zip.prefix = (function rewrite_clj$zip$prefix(zloc,s){\nreturn rewrite_clj.zip.editz.prefix(zloc,s);\n});\n/**\n * Return zipper with the current node in `zloc` suffixed with string `s`.\n * Operates on token node or a multi-line node, else exception is thrown.\n * When multi-line, last line is suffixed.\n */\nrewrite_clj.zip.suffix = (function rewrite_clj$zip$suffix(zloc,s){\nreturn rewrite_clj.zip.editz.suffix(zloc,s);\n});\n/**\n * Returns `zloc` with namespaced map sexpr context to all symbols and keywords reapplied from current location downward.\n * \n *   Keywords and symbols:\n *   * that are keys in a namespaced map will have namespaced map context applied\n *   * otherwise will have any namespaced map context removed\n * \n *   You should only need to use this function if:\n *   * you care about `sexpr` on keywords and symbols\n *   * and you are moving keywords and symbols from a namespaced map to some other location.\n */\nrewrite_clj.zip.reapply_context = (function rewrite_clj$zip$reapply_context(zloc){\nreturn rewrite_clj.zip.context.reapply_context(zloc);\n});\n/**\n * Return `zloc` located to the first node satisfying predicate `p?` else nil.\n * Search starts at the current node and continues via movement function `f`.\n * \n * `f` defaults to [[rewrite-clj.zip/right]]\n */\nrewrite_clj.zip.find = (function rewrite_clj$zip$find(var_args){\nvar G__41293 = arguments.length;\nswitch (G__41293) {\ncase 2:\nreturn rewrite_clj.zip.find.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn rewrite_clj.zip.find.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(rewrite_clj.zip.find.cljs$core$IFn$_invoke$arity$2 = (function (zloc,p_QMARK_){\nreturn rewrite_clj.zip.findz.find.cljs$core$IFn$_invoke$arity$2(zloc,p_QMARK_);\n}));\n\n(rewrite_clj.zip.find.cljs$core$IFn$_invoke$arity$3 = (function (zloc,f,p_QMARK_){\nreturn rewrite_clj.zip.findz.find.cljs$core$IFn$_invoke$arity$3(zloc,f,p_QMARK_);\n}));\n\n(rewrite_clj.zip.find.cljs$lang$maxFixedArity = 3);\n\n/**\n * Return `zloc` located to the next node satisfying predicate `p?` else `nil`.\n * Search starts one movement `f` from the current node and continues via `f`.\n * \n * `f` defaults to [[rewrite-clj.zip/right]]\n */\nrewrite_clj.zip.find_next = (function rewrite_clj$zip$find_next(var_args){\nvar G__41307 = arguments.length;\nswitch (G__41307) {\ncase 2:\nreturn rewrite_clj.zip.find_next.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn rewrite_clj.zip.find_next.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(rewrite_clj.zip.find_next.cljs$core$IFn$_invoke$arity$2 = (function (zloc,p_QMARK_){\nreturn rewrite_clj.zip.findz.find_next.cljs$core$IFn$_invoke$arity$2(zloc,p_QMARK_);\n}));\n\n(rewrite_clj.zip.find_next.cljs$core$IFn$_invoke$arity$3 = (function (zloc,f,p_QMARK_){\nreturn rewrite_clj.zip.findz.find_next.cljs$core$IFn$_invoke$arity$3(zloc,f,p_QMARK_);\n}));\n\n(rewrite_clj.zip.find_next.cljs$lang$maxFixedArity = 3);\n\n/**\n * Return `zloc` located to the first node satisfying predicate `p?` else `nil`.\n * Search is depth-first from the current node.\n */\nrewrite_clj.zip.find_depth_first = (function rewrite_clj$zip$find_depth_first(zloc,p_QMARK_){\nreturn rewrite_clj.zip.findz.find_depth_first(zloc,p_QMARK_);\n});\n/**\n * Return `zloc` located to next node satisfying predicate `p?` else `nil`.\n * Search starts depth-first after the current node.\n */\nrewrite_clj.zip.find_next_depth_first = (function rewrite_clj$zip$find_next_depth_first(zloc,p_QMARK_){\nreturn rewrite_clj.zip.findz.find_next_depth_first(zloc,p_QMARK_);\n});\n/**\n * Return `zloc` located to the first node with tag `t` else `nil`.\n * Search starts at the current node and continues via movement function `f`.\n * \n * `f` defaults to [[rewrite-clj.zip/right]]\n */\nrewrite_clj.zip.find_tag = (function rewrite_clj$zip$find_tag(var_args){\nvar G__41315 = arguments.length;\nswitch (G__41315) {\ncase 2:\nreturn rewrite_clj.zip.find_tag.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn rewrite_clj.zip.find_tag.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(rewrite_clj.zip.find_tag.cljs$core$IFn$_invoke$arity$2 = (function (zloc,t){\nreturn rewrite_clj.zip.findz.find_tag.cljs$core$IFn$_invoke$arity$2(zloc,t);\n}));\n\n(rewrite_clj.zip.find_tag.cljs$core$IFn$_invoke$arity$3 = (function (zloc,f,t){\nreturn rewrite_clj.zip.findz.find_tag.cljs$core$IFn$_invoke$arity$3(zloc,f,t);\n}));\n\n(rewrite_clj.zip.find_tag.cljs$lang$maxFixedArity = 3);\n\n/**\n * Return `zloc` located to the next node with tag `t` else `nil`.\n *   Search starts one movement `f` after the current node and continues via `f`.\n * \n * `f` defaults to [[rewrite-clj.zip/right]]\n */\nrewrite_clj.zip.find_next_tag = (function rewrite_clj$zip$find_next_tag(var_args){\nvar G__41320 = arguments.length;\nswitch (G__41320) {\ncase 2:\nreturn rewrite_clj.zip.find_next_tag.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn rewrite_clj.zip.find_next_tag.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(rewrite_clj.zip.find_next_tag.cljs$core$IFn$_invoke$arity$2 = (function (zloc,t){\nreturn rewrite_clj.zip.findz.find_next_tag.cljs$core$IFn$_invoke$arity$2(zloc,t);\n}));\n\n(rewrite_clj.zip.find_next_tag.cljs$core$IFn$_invoke$arity$3 = (function (zloc,f,t){\nreturn rewrite_clj.zip.findz.find_next_tag.cljs$core$IFn$_invoke$arity$3(zloc,f,t);\n}));\n\n(rewrite_clj.zip.find_next_tag.cljs$lang$maxFixedArity = 3);\n\n/**\n * Return `zloc` located to the first token node that `sexpr`esses to `v` else `nil`.\n * Search starts from the current node and continues via movement function `f`.\n * \n * `v` can be a single value or a set. When `v` is a set, matches on any value in set.\n * \n * `f` defaults to [[rewrite-clj.zip/right]] in short form call.\n * \n *   See docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances).\n */\nrewrite_clj.zip.find_value = (function rewrite_clj$zip$find_value(var_args){\nvar G__41323 = arguments.length;\nswitch (G__41323) {\ncase 2:\nreturn rewrite_clj.zip.find_value.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn rewrite_clj.zip.find_value.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(rewrite_clj.zip.find_value.cljs$core$IFn$_invoke$arity$2 = (function (zloc,v){\nreturn rewrite_clj.zip.findz.find_value.cljs$core$IFn$_invoke$arity$2(zloc,v);\n}));\n\n(rewrite_clj.zip.find_value.cljs$core$IFn$_invoke$arity$3 = (function (zloc,f,v){\nreturn rewrite_clj.zip.findz.find_value.cljs$core$IFn$_invoke$arity$3(zloc,f,v);\n}));\n\n(rewrite_clj.zip.find_value.cljs$lang$maxFixedArity = 3);\n\n/**\n * Return `zloc` located to the next token node that `sexpr`esses to `v` else `nil`.\n * Search starts one movement `f` from the current location, and continues via `f`.\n * \n * `v` can be a single value or a set. When `v` is a set matches on any value in set.\n * \n * `f` defaults to [[rewrite-clj.zip/right]] in short form call.\n * \n *   See docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances).\n */\nrewrite_clj.zip.find_next_value = (function rewrite_clj$zip$find_next_value(var_args){\nvar G__41327 = arguments.length;\nswitch (G__41327) {\ncase 2:\nreturn rewrite_clj.zip.find_next_value.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn rewrite_clj.zip.find_next_value.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(rewrite_clj.zip.find_next_value.cljs$core$IFn$_invoke$arity$2 = (function (zloc,v){\nreturn rewrite_clj.zip.findz.find_next_value.cljs$core$IFn$_invoke$arity$2(zloc,v);\n}));\n\n(rewrite_clj.zip.find_next_value.cljs$core$IFn$_invoke$arity$3 = (function (zloc,f,v){\nreturn rewrite_clj.zip.findz.find_next_value.cljs$core$IFn$_invoke$arity$3(zloc,f,v);\n}));\n\n(rewrite_clj.zip.find_next_value.cljs$lang$maxFixedArity = 3);\n\n/**\n * Return `zloc` located to the the first token node satisfying predicate `p?`.\n *   Search starts at the current node and continues via movement function `f`.\n * \n * `f` defaults to [[rewrite-clj.zip/right]]\n */\nrewrite_clj.zip.find_token = (function rewrite_clj$zip$find_token(var_args){\nvar G__41333 = arguments.length;\nswitch (G__41333) {\ncase 2:\nreturn rewrite_clj.zip.find_token.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn rewrite_clj.zip.find_token.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(rewrite_clj.zip.find_token.cljs$core$IFn$_invoke$arity$2 = (function (zloc,p_QMARK_){\nreturn rewrite_clj.zip.findz.find_token.cljs$core$IFn$_invoke$arity$2(zloc,p_QMARK_);\n}));\n\n(rewrite_clj.zip.find_token.cljs$core$IFn$_invoke$arity$3 = (function (zloc,f,p_QMARK_){\nreturn rewrite_clj.zip.findz.find_token.cljs$core$IFn$_invoke$arity$3(zloc,f,p_QMARK_);\n}));\n\n(rewrite_clj.zip.find_token.cljs$lang$maxFixedArity = 3);\n\n/**\n * Return `zloc` located to the next token node satisfying predicate `p?` else `nil`.\n *   Search starts one movement `f` after the current node and continues via `f`.\n * \n * `f` defaults to [[rewrite-clj.zip/right]]\n */\nrewrite_clj.zip.find_next_token = (function rewrite_clj$zip$find_next_token(var_args){\nvar G__41338 = arguments.length;\nswitch (G__41338) {\ncase 2:\nreturn rewrite_clj.zip.find_next_token.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn rewrite_clj.zip.find_next_token.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(rewrite_clj.zip.find_next_token.cljs$core$IFn$_invoke$arity$2 = (function (zloc,p_QMARK_){\nreturn rewrite_clj.zip.findz.find_next_token.cljs$core$IFn$_invoke$arity$2(zloc,p_QMARK_);\n}));\n\n(rewrite_clj.zip.find_next_token.cljs$core$IFn$_invoke$arity$3 = (function (zloc,f,p_QMARK_){\nreturn rewrite_clj.zip.findz.find_next_token.cljs$core$IFn$_invoke$arity$3(zloc,f,p_QMARK_);\n}));\n\n(rewrite_clj.zip.find_next_token.cljs$lang$maxFixedArity = 3);\n\n/**\n * Return `zloc` located to the last node spanning position `pos` that satisfies predicate `p?` else `nil`.\n * Search is depth-first from the current node.\n * \n *   NOTE: Does not ignore whitespace/comment nodes.\n */\nrewrite_clj.zip.find_last_by_pos = (function rewrite_clj$zip$find_last_by_pos(var_args){\nvar G__41343 = arguments.length;\nswitch (G__41343) {\ncase 2:\nreturn rewrite_clj.zip.find_last_by_pos.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn rewrite_clj.zip.find_last_by_pos.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(rewrite_clj.zip.find_last_by_pos.cljs$core$IFn$_invoke$arity$2 = (function (zloc,pos){\nreturn rewrite_clj.zip.findz.find_last_by_pos.cljs$core$IFn$_invoke$arity$2(zloc,pos);\n}));\n\n(rewrite_clj.zip.find_last_by_pos.cljs$core$IFn$_invoke$arity$3 = (function (zloc,pos,p_QMARK_){\nreturn rewrite_clj.zip.findz.find_last_by_pos.cljs$core$IFn$_invoke$arity$3(zloc,pos,p_QMARK_);\n}));\n\n(rewrite_clj.zip.find_last_by_pos.cljs$lang$maxFixedArity = 3);\n\n/**\n * Return `zloc` located to the last node spanning position `pos` with tag `t` else `nil`.\n *   Search is depth-first from the current node.\n */\nrewrite_clj.zip.find_tag_by_pos = (function rewrite_clj$zip$find_tag_by_pos(zloc,pos,t){\nreturn rewrite_clj.zip.findz.find_tag_by_pos(zloc,pos,t);\n});\n/**\n * Return zipper with `item` inserted to the right of the current node in `zloc`, without moving location.\n *   Will insert a space if necessary.\n */\nrewrite_clj.zip.insert_right = (function rewrite_clj$zip$insert_right(zloc,item){\nreturn rewrite_clj.zip.insert.insert_right(zloc,item);\n});\n/**\n * Return zipper with `item` inserted to the left of the current node in `zloc`, without moving location.\n *   Will insert a space if necessary.\n */\nrewrite_clj.zip.insert_left = (function rewrite_clj$zip$insert_left(zloc,item){\nreturn rewrite_clj.zip.insert.insert_left(zloc,item);\n});\n/**\n * Return zipper with `item` inserted as the first child of the current node in `zloc`, without moving location.\n */\nrewrite_clj.zip.insert_child = (function rewrite_clj$zip$insert_child(zloc,item){\nreturn rewrite_clj.zip.insert.insert_child(zloc,item);\n});\n/**\n * Return zipper with `item` inserted as the last child of the current node in `zloc`, without moving.\n *   Will insert a space if necessary.\n */\nrewrite_clj.zip.append_child = (function rewrite_clj$zip$append_child(zloc,item){\nreturn rewrite_clj.zip.insert.append_child(zloc,item);\n});\n/**\n * Return zipper with location moved left to next non-whitespace/non-comment sibling of current node in `zloc`.\n */\nrewrite_clj.zip.left = (function rewrite_clj$zip$left(zloc){\nreturn rewrite_clj.zip.move.left(zloc);\n});\n/**\n * Return zipper with location moved right to next non-whitespace/non-comment sibling of current node in `zloc`.\n */\nrewrite_clj.zip.right = (function rewrite_clj$zip$right(zloc){\nreturn rewrite_clj.zip.move.right(zloc);\n});\n/**\n * Return zipper with location moved up to next non-whitespace/non-comment parent of current node in `zloc`, or `nil` if at the top.\n */\nrewrite_clj.zip.up = (function rewrite_clj$zip$up(zloc){\nreturn rewrite_clj.zip.move.up(zloc);\n});\n/**\n * Return zipper with location moved down to the first non-whitespace/non-comment child node of the current node in `zloc`, or nil if no applicable children.\n */\nrewrite_clj.zip.down = (function rewrite_clj$zip$down(zloc){\nreturn rewrite_clj.zip.move.down(zloc);\n});\n/**\n * Return zipper with location moved to the previous depth-first non-whitespace/non-comment node in `zloc`. If already at root, returns nil.\n */\nrewrite_clj.zip.prev = (function rewrite_clj$zip$prev(zloc){\nreturn rewrite_clj.zip.move.prev(zloc);\n});\n/**\n * Return zipper with location moved to the next depth-first non-whitespace/non-comment node in `zloc`.\n * End can be detected with [[end?]], if already at end, stays there.\n */\nrewrite_clj.zip.next = (function rewrite_clj$zip$next(zloc){\nreturn rewrite_clj.zip.move.next(zloc);\n});\n/**\n * Return zipper with location moved to the leftmost non-whitespace/non-comment sibling of current node in `zloc`.\n */\nrewrite_clj.zip.leftmost = (function rewrite_clj$zip$leftmost(zloc){\nreturn rewrite_clj.zip.move.leftmost(zloc);\n});\n/**\n * Return zipper with location moved to the rightmost non-whitespace/non-comment sibling of current node in `zloc`.\n */\nrewrite_clj.zip.rightmost = (function rewrite_clj$zip$rightmost(zloc){\nreturn rewrite_clj.zip.move.rightmost(zloc);\n});\n/**\n * Return true if at leftmost non-whitespace/non-comment sibling node in `zloc`.\n */\nrewrite_clj.zip.leftmost_QMARK_ = (function rewrite_clj$zip$leftmost_QMARK_(zloc){\nreturn rewrite_clj.zip.move.leftmost_QMARK_(zloc);\n});\n/**\n * Return true if at rightmost non-whitespace/non-comment sibling node in `zloc`.\n */\nrewrite_clj.zip.rightmost_QMARK_ = (function rewrite_clj$zip$rightmost_QMARK_(zloc){\nreturn rewrite_clj.zip.move.rightmost_QMARK_(zloc);\n});\n/**\n * Return true if `zloc` is at end of depth-first traversal.\n */\nrewrite_clj.zip.end_QMARK_ = (function rewrite_clj$zip$end_QMARK_(zloc){\nreturn rewrite_clj.zip.move.end_QMARK_(zloc);\n});\n/**\n * Return `zloc` with current node removed. Returned zipper location\n * is moved to the first non-whitespace node preceding removed node in a depth-first walk.\n * Removes whitespace appropriately.\n * \n *   - `[1 |2  3]    => [|1 3]`\n *   - `[1 |2]       => [|1]`\n *   - `[|1 2]       => |[2]`\n *   - `[|1]         => |[]`\n *   - `[  |1  ]     => |[]`\n *   - `[1 [2 3] |4] => [1 [2 |3]]`\n *   - `[|1 [2 3] 4] => |[[2 3] 4]`\n * \n * If the removed node is a rightmost sibling, both leading and trailing whitespace\n * is removed, otherwise only trailing whitespace is removed.\n * \n * The result is that a following element (no matter whether it is on the same line\n * or not) will end up at same positon (line/column) as the removed one.\n * If a comment lies betwen the original node and the neighbour this will not hold true.\n * \n * If the removed node is at end of input and is trailed by 1 or more newlines, \n * a single trailing newline will be preserved.\n */\nrewrite_clj.zip.remove = (function rewrite_clj$zip$remove(zloc){\nreturn rewrite_clj.zip.removez.remove(zloc);\n});\n/**\n * Same as [[remove]] but preserves newlines.\n * Specifically: will trim all whitespace - or whitespace up to first linebreak if present.\n */\nrewrite_clj.zip.remove_preserve_newline = (function rewrite_clj$zip$remove_preserve_newline(zloc){\nreturn rewrite_clj.zip.removez.remove_preserve_newline(zloc);\n});\n/**\n * Returns true if current node in `zloc` is a sequence.\n */\nrewrite_clj.zip.seq_QMARK_ = (function rewrite_clj$zip$seq_QMARK_(zloc){\nreturn rewrite_clj.zip.seqz.seq_QMARK_(zloc);\n});\n/**\n * Returns true if current node in `zloc` is a list.\n */\nrewrite_clj.zip.list_QMARK_ = (function rewrite_clj$zip$list_QMARK_(zloc){\nreturn rewrite_clj.zip.seqz.list_QMARK_(zloc);\n});\n/**\n * Returns true if current node in `zloc` is a vector.\n */\nrewrite_clj.zip.vector_QMARK_ = (function rewrite_clj$zip$vector_QMARK_(zloc){\nreturn rewrite_clj.zip.seqz.vector_QMARK_(zloc);\n});\n/**\n * Returns true if current node in `zloc` is a set.\n */\nrewrite_clj.zip.set_QMARK_ = (function rewrite_clj$zip$set_QMARK_(zloc){\nreturn rewrite_clj.zip.seqz.set_QMARK_(zloc);\n});\n/**\n * Returns true if current node in `zloc` is a map.\n */\nrewrite_clj.zip.map_QMARK_ = (function rewrite_clj$zip$map_QMARK_(zloc){\nreturn rewrite_clj.zip.seqz.map_QMARK_(zloc);\n});\n/**\n * Returns true if the current node in `zloc` is a namespaced map.\n */\nrewrite_clj.zip.namespaced_map_QMARK_ = (function rewrite_clj$zip$namespaced_map_QMARK_(zloc){\nreturn rewrite_clj.zip.seqz.namespaced_map_QMARK_(zloc);\n});\n/**\n * Returns `zloc` with function `f` applied to all nodes of the current node.\n *   Current node must be a sequence node. Equivalent to [[rewrite-clj.zip/map-vals]] for maps.\n * \n *   `zloc` location is unchanged.\n * \n *   `f` arg is zloc positioned at\n *   - value nodes for maps\n *   - each element of a seq\n *   and is should return:\n *   - an updated zloc with zloc positioned at edited node\n *   - a falsey value to leave value node unchanged\n * \n *   Folks typically use [[rewrite-clj.zip/edit]] for `f`.\n */\nrewrite_clj.zip.map = (function rewrite_clj$zip$map(f,zloc){\nreturn rewrite_clj.zip.seqz.map(f,zloc);\n});\n/**\n * Returns `zloc` with function `f` applied to all key nodes of the current node.\n * Current node must be map node.\n * \n *   `zloc` location is unchanged.\n * \n *   `f` arg is zloc positioned at key node and should return:\n *   - an updated zloc with zloc positioned at key node\n *   - a falsey value to leave value node unchanged\n * \n *   Folks typically use [[rewrite-clj.zip/edit]] for `f`.\n */\nrewrite_clj.zip.map_keys = (function rewrite_clj$zip$map_keys(f,zloc){\nreturn rewrite_clj.zip.seqz.map_keys(f,zloc);\n});\n/**\n * Returns `zloc` with function `f` applied to each value node of the current node.\n * Current node must be map node.\n * \n *   `zloc` location is unchanged.\n * \n *   `f` arg is zloc positioned at value node and should return:\n *   - an updated zloc with zloc positioned at value node\n *   - a falsey value to leave value node unchanged\n * \n *   Folks typically use [[rewrite-clj.zip/edit]] for `f`.\n */\nrewrite_clj.zip.map_vals = (function rewrite_clj$zip$map_vals(f,zloc){\nreturn rewrite_clj.zip.seqz.map_vals(f,zloc);\n});\n/**\n * Returns `zloc` located to map key node's sexpr value matching `k` else `nil`.\n * \n *   `k` should be:\n *   - a key for maps\n *   - a zero-based index for sequences\n * \n *   NOTE: `k` will be compared against resolved keywords in maps.\n *   See docs for sexpr behavior on [namespaced elements](/doc/01-user-guide.adoc#namespaced-elements).\n */\nrewrite_clj.zip.get = (function rewrite_clj$zip$get(zloc,k){\nreturn rewrite_clj.zip.seqz.get(zloc,k);\n});\n/**\n * Returns `zloc` with current node's `k` set to value `v`.\n * \n *   `zloc` location is unchanged.\n * \n *   `k` should be:\n *   - a key for maps\n *   - a zero-based index for sequences, an exception is thrown if index is out of bounds\n * \n *   NOTE: `k` will be compared against resolved keywords in maps.\n *   See docs for sexpr behavior on [namespaced elements](/doc/01-user-guide.adoc#namespaced-elements).\n */\nrewrite_clj.zip.assoc = (function rewrite_clj$zip$assoc(zloc,k,v){\nreturn rewrite_clj.zip.seqz.assoc(zloc,k,v);\n});\n/**\n * Return zipper applying function `f` to `zloc`. The resulting\n * zipper will be located at the same path (i.e. the same number of\n * downwards and right movements from the root) incoming `zloc`.\n * \n * See also [[subedit-node]] for an isolated edit.\n */\nrewrite_clj.zip.edit_node = (function rewrite_clj$zip$edit_node(zloc,f){\nreturn rewrite_clj.zip.subedit.edit_node(zloc,f);\n});\n/**\n * Return zipper replacing current node in `zloc` with result of `f` applied to said node as an isolated sub-tree.\n * The resulting zipper will be located on the root of the modified sub-tree.\n * \n * See [docs on sub editing](/doc/01-user-guide.adoc#sub-editing).\n */\nrewrite_clj.zip.subedit_node = (function rewrite_clj$zip$subedit_node(zloc,f){\nreturn rewrite_clj.zip.subedit.subedit_node(zloc,f);\n});\n/**\n * Create and return a zipper whose root is the current node in `zloc`.\n * \n * See [docs on sub editing](/doc/01-user-guide.adoc#sub-editing).\n */\nrewrite_clj.zip.subzip = (function rewrite_clj$zip$subzip(zloc){\nreturn rewrite_clj.zip.subedit.subzip(zloc);\n});\n/**\n * Return zipper modified by an isolated depth-first pre-order traversal.\n * \n * Pre-order traversal visits root before children.\n * For example, traversal order of `(1 (2 3 (4 5) 6 (7 8)) 9)` is:\n * \n * 1. `(1 (2 3 (4 5) 6 (7 8)) 9)`\n * 2. `1`\n * 3. `(2 3 (4 5) 6 (7 8))`\n * 4. `2`\n * 5. `3`\n * 6. `(4 5)`\n * 7. `4`\n * 8. `5`\n * 9. `6`\n * 10. `(7 8)`\n * 11. `7`\n * 12. `8`\n * 13. `9`\n * \n * Traversal starts at the current node in `zloc` and continues to the end of the isolated sub-tree.\n * \n * Function `f` is called on the zipper locations satisfying predicate `p?` and must return either\n * - nil to indicate no changes\n * - or a valid zipper\n * WARNING: when function `f` changes the location in the zipper, normal traversal will be affected.\n * \n * When `p?` is not specified `f` is called on all locations.\n * \n * Note that by default a newly created zipper automatically navigates to the first non-whitespace\n * node. If you want to be sure to walk all forms in a zipper, you'll want to navigate one up prior to your walk:\n * \n * ```Clojure\n * (-> (zip/of-string \"my clojure forms\")\n *     zip/up\n *     (zip/prewalk ...))\n * ```\n * \n * See [docs on sub editing](/doc/01-user-guide.adoc#sub-editing).\n */\nrewrite_clj.zip.prewalk = (function rewrite_clj$zip$prewalk(var_args){\nvar G__41370 = arguments.length;\nswitch (G__41370) {\ncase 2:\nreturn rewrite_clj.zip.prewalk.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn rewrite_clj.zip.prewalk.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(rewrite_clj.zip.prewalk.cljs$core$IFn$_invoke$arity$2 = (function (zloc,f){\nreturn rewrite_clj.zip.walk.prewalk.cljs$core$IFn$_invoke$arity$2(zloc,f);\n}));\n\n(rewrite_clj.zip.prewalk.cljs$core$IFn$_invoke$arity$3 = (function (zloc,p_QMARK_,f){\nreturn rewrite_clj.zip.walk.prewalk.cljs$core$IFn$_invoke$arity$3(zloc,p_QMARK_,f);\n}));\n\n(rewrite_clj.zip.prewalk.cljs$lang$maxFixedArity = 3);\n\n/**\n * Return zipper modified by an isolated depth-first post-order traversal.\n * \n * Pre-order traversal visits children before root.\n * For example, traversal order of `(1 (2 3 (4 5) 6 (7 8)) 9)` is:\n * \n * 1. `1`\n * 2. `2`\n * 3. `3`\n * 4. `4`\n * 5. `5`\n * 6. `(4 5)`\n * 7. `6`\n * 8. `7`\n * 9. `8`\n * 10. `(7 8)`\n * 11. `(2 3 (4 5) 6 (7 8))`\n * 12. `9`\n * 13. `(1 (2 3 (4 5) 6 (7 8)) 9)`\n * \n * Traversal starts at the current node in `zloc` and continues to the end of the isolated sub-tree.\n * \n * Function `f` is called on the zipper locations satisfying predicate `p?` and must return either\n * - nil to indicate no changes\n * - or a valid zipper\n * WARNING: when function `f` changes the location in the zipper, normal traversal will be affected.\n * \n * When `p?` is not specified `f` is called on all locations.\n * \n * Note that by default a newly created zipper automatically navigates to the first non-whitespace\n * node. If you want to be sure to walk all forms in a zipper, you'll want to navigate one up prior to your walk:\n * \n * ```Clojure\n * (-> (zip/of-string \"my clojure forms\")\n *     zip/up\n *     (zip/postwalk ...))\n * ```\n * \n * See [docs on sub editing](/doc/01-user-guide.adoc#sub-editing).\n */\nrewrite_clj.zip.postwalk = (function rewrite_clj$zip$postwalk(var_args){\nvar G__41380 = arguments.length;\nswitch (G__41380) {\ncase 2:\nreturn rewrite_clj.zip.postwalk.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn rewrite_clj.zip.postwalk.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(rewrite_clj.zip.postwalk.cljs$core$IFn$_invoke$arity$2 = (function (zloc,f){\nreturn rewrite_clj.zip.walk.postwalk.cljs$core$IFn$_invoke$arity$2(zloc,f);\n}));\n\n(rewrite_clj.zip.postwalk.cljs$core$IFn$_invoke$arity$3 = (function (zloc,p_QMARK_,f){\nreturn rewrite_clj.zip.walk.postwalk.cljs$core$IFn$_invoke$arity$3(zloc,p_QMARK_,f);\n}));\n\n(rewrite_clj.zip.postwalk.cljs$lang$maxFixedArity = 3);\n\n/**\n * Returns true when the current the node in `zloc` is a Clojure whitespace (which includes the comma).\n */\nrewrite_clj.zip.whitespace_QMARK_ = (function rewrite_clj$zip$whitespace_QMARK_(zloc){\nreturn rewrite_clj.zip.whitespace.whitespace_QMARK_(zloc);\n});\n/**\n * Returns true when the current node in `zloc` is a linebreak.\n */\nrewrite_clj.zip.linebreak_QMARK_ = (function rewrite_clj$zip$linebreak_QMARK_(zloc){\nreturn rewrite_clj.zip.whitespace.linebreak_QMARK_(zloc);\n});\n/**\n * Returns true when current node in `zloc` is whitespace or a comment.\n */\nrewrite_clj.zip.whitespace_or_comment_QMARK_ = (function rewrite_clj$zip$whitespace_or_comment_QMARK_(zloc){\nreturn rewrite_clj.zip.whitespace.whitespace_or_comment_QMARK_(zloc);\n});\n/**\n * Return zipper with location moved to first location not satisfying predicate `p?` starting from the node in\n * `zloc` and traversing by function `f`.\n */\nrewrite_clj.zip.skip = (function rewrite_clj$zip$skip(f,p_QMARK_,zloc){\nreturn rewrite_clj.zip.whitespace.skip(f,p_QMARK_,zloc);\n});\n/**\n * Return zipper with location moved to first non-whitespace/non-comment starting from current node in `zloc`\n * and traversing by function `f`.\n * \n * `f` defaults to [[rewrite-clj.zip/right]]\n */\nrewrite_clj.zip.skip_whitespace = (function rewrite_clj$zip$skip_whitespace(var_args){\nvar G__41385 = arguments.length;\nswitch (G__41385) {\ncase 1:\nreturn rewrite_clj.zip.skip_whitespace.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn rewrite_clj.zip.skip_whitespace.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(rewrite_clj.zip.skip_whitespace.cljs$core$IFn$_invoke$arity$1 = (function (zloc){\nreturn rewrite_clj.zip.whitespace.skip_whitespace.cljs$core$IFn$_invoke$arity$1(zloc);\n}));\n\n(rewrite_clj.zip.skip_whitespace.cljs$core$IFn$_invoke$arity$2 = (function (f,zloc){\nreturn rewrite_clj.zip.whitespace.skip_whitespace.cljs$core$IFn$_invoke$arity$2(f,zloc);\n}));\n\n(rewrite_clj.zip.skip_whitespace.cljs$lang$maxFixedArity = 2);\n\n/**\n * Return zipper with location moved to first non-whitespace/non-comment starting from current node in `zloc` traversing left.\n */\nrewrite_clj.zip.skip_whitespace_left = (function rewrite_clj$zip$skip_whitespace_left(zloc){\nreturn rewrite_clj.zip.whitespace.skip_whitespace_left(zloc);\n});\n/**\n * Return zipper with `n` space whitespace node inserted to the left of the current node in `zloc`, without moving location.\n * `n` defaults to 1.\n */\nrewrite_clj.zip.insert_space_left = (function rewrite_clj$zip$insert_space_left(var_args){\nvar G__41390 = arguments.length;\nswitch (G__41390) {\ncase 1:\nreturn rewrite_clj.zip.insert_space_left.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn rewrite_clj.zip.insert_space_left.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(rewrite_clj.zip.insert_space_left.cljs$core$IFn$_invoke$arity$1 = (function (zloc){\nreturn rewrite_clj.zip.whitespace.insert_space_left.cljs$core$IFn$_invoke$arity$1(zloc);\n}));\n\n(rewrite_clj.zip.insert_space_left.cljs$core$IFn$_invoke$arity$2 = (function (zloc,n){\nreturn rewrite_clj.zip.whitespace.insert_space_left.cljs$core$IFn$_invoke$arity$2(zloc,n);\n}));\n\n(rewrite_clj.zip.insert_space_left.cljs$lang$maxFixedArity = 2);\n\n/**\n * Return zipper with `n` space whitespace node inserted to the right of the current node in `zloc`, without moving location.\n * `n` defaults to 1.\n */\nrewrite_clj.zip.insert_space_right = (function rewrite_clj$zip$insert_space_right(var_args){\nvar G__41397 = arguments.length;\nswitch (G__41397) {\ncase 1:\nreturn rewrite_clj.zip.insert_space_right.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn rewrite_clj.zip.insert_space_right.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(rewrite_clj.zip.insert_space_right.cljs$core$IFn$_invoke$arity$1 = (function (zloc){\nreturn rewrite_clj.zip.whitespace.insert_space_right.cljs$core$IFn$_invoke$arity$1(zloc);\n}));\n\n(rewrite_clj.zip.insert_space_right.cljs$core$IFn$_invoke$arity$2 = (function (zloc,n){\nreturn rewrite_clj.zip.whitespace.insert_space_right.cljs$core$IFn$_invoke$arity$2(zloc,n);\n}));\n\n(rewrite_clj.zip.insert_space_right.cljs$lang$maxFixedArity = 2);\n\n/**\n * Return zipper with `n` newlines node inserted to the left of the current node in `zloc`, without moving location.\n * `n` defaults to 1.\n */\nrewrite_clj.zip.insert_newline_left = (function rewrite_clj$zip$insert_newline_left(var_args){\nvar G__41399 = arguments.length;\nswitch (G__41399) {\ncase 1:\nreturn rewrite_clj.zip.insert_newline_left.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn rewrite_clj.zip.insert_newline_left.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(rewrite_clj.zip.insert_newline_left.cljs$core$IFn$_invoke$arity$1 = (function (zloc){\nreturn rewrite_clj.zip.whitespace.insert_newline_left.cljs$core$IFn$_invoke$arity$1(zloc);\n}));\n\n(rewrite_clj.zip.insert_newline_left.cljs$core$IFn$_invoke$arity$2 = (function (zloc,n){\nreturn rewrite_clj.zip.whitespace.insert_newline_left.cljs$core$IFn$_invoke$arity$2(zloc,n);\n}));\n\n(rewrite_clj.zip.insert_newline_left.cljs$lang$maxFixedArity = 2);\n\n/**\n * Return zipper with `n` newlines node inserted to the right of the current node in `zloc`, without moving location.\n * `n` defaults to 1.\n */\nrewrite_clj.zip.insert_newline_right = (function rewrite_clj$zip$insert_newline_right(var_args){\nvar G__41401 = arguments.length;\nswitch (G__41401) {\ncase 1:\nreturn rewrite_clj.zip.insert_newline_right.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn rewrite_clj.zip.insert_newline_right.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(rewrite_clj.zip.insert_newline_right.cljs$core$IFn$_invoke$arity$1 = (function (zloc){\nreturn rewrite_clj.zip.whitespace.insert_newline_right.cljs$core$IFn$_invoke$arity$1(zloc);\n}));\n\n(rewrite_clj.zip.insert_newline_right.cljs$core$IFn$_invoke$arity$2 = (function (zloc,n){\nreturn rewrite_clj.zip.whitespace.insert_newline_right.cljs$core$IFn$_invoke$arity$2(zloc,n);\n}));\n\n(rewrite_clj.zip.insert_newline_right.cljs$lang$maxFixedArity = 2);\n\n/**\n * DEPRECATED: renamed to [[insert-space-left]].\n */\nrewrite_clj.zip.prepend_space = (function rewrite_clj$zip$prepend_space(var_args){\nvar G__41406 = arguments.length;\nswitch (G__41406) {\ncase 2:\nreturn rewrite_clj.zip.prepend_space.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 1:\nreturn rewrite_clj.zip.prepend_space.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(rewrite_clj.zip.prepend_space.cljs$core$IFn$_invoke$arity$2 = (function (zloc,n){\nreturn rewrite_clj.zip.whitespace.prepend_space.cljs$core$IFn$_invoke$arity$2(zloc,n);\n}));\n\n(rewrite_clj.zip.prepend_space.cljs$core$IFn$_invoke$arity$1 = (function (zloc){\nreturn rewrite_clj.zip.whitespace.prepend_space.cljs$core$IFn$_invoke$arity$1(zloc);\n}));\n\n(rewrite_clj.zip.prepend_space.cljs$lang$maxFixedArity = 2);\n\n/**\n * DEPRECATED: renamed to [[insert-space-right]].\n */\nrewrite_clj.zip.append_space = (function rewrite_clj$zip$append_space(var_args){\nvar G__41408 = arguments.length;\nswitch (G__41408) {\ncase 2:\nreturn rewrite_clj.zip.append_space.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 1:\nreturn rewrite_clj.zip.append_space.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(rewrite_clj.zip.append_space.cljs$core$IFn$_invoke$arity$2 = (function (zloc,n){\nreturn rewrite_clj.zip.whitespace.append_space.cljs$core$IFn$_invoke$arity$2(zloc,n);\n}));\n\n(rewrite_clj.zip.append_space.cljs$core$IFn$_invoke$arity$1 = (function (zloc){\nreturn rewrite_clj.zip.whitespace.append_space.cljs$core$IFn$_invoke$arity$1(zloc);\n}));\n\n(rewrite_clj.zip.append_space.cljs$lang$maxFixedArity = 2);\n\n/**\n * DEPRECATED: renamed to [[insert-newline-left]].\n */\nrewrite_clj.zip.prepend_newline = (function rewrite_clj$zip$prepend_newline(var_args){\nvar G__41410 = arguments.length;\nswitch (G__41410) {\ncase 2:\nreturn rewrite_clj.zip.prepend_newline.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 1:\nreturn rewrite_clj.zip.prepend_newline.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(rewrite_clj.zip.prepend_newline.cljs$core$IFn$_invoke$arity$2 = (function (zloc,n){\nreturn rewrite_clj.zip.whitespace.prepend_newline.cljs$core$IFn$_invoke$arity$2(zloc,n);\n}));\n\n(rewrite_clj.zip.prepend_newline.cljs$core$IFn$_invoke$arity$1 = (function (zloc){\nreturn rewrite_clj.zip.whitespace.prepend_newline.cljs$core$IFn$_invoke$arity$1(zloc);\n}));\n\n(rewrite_clj.zip.prepend_newline.cljs$lang$maxFixedArity = 2);\n\n/**\n * DEPRECATED: renamed to [[insert-newline-right]].\n */\nrewrite_clj.zip.append_newline = (function rewrite_clj$zip$append_newline(var_args){\nvar G__41414 = arguments.length;\nswitch (G__41414) {\ncase 2:\nreturn rewrite_clj.zip.append_newline.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 1:\nreturn rewrite_clj.zip.append_newline.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(rewrite_clj.zip.append_newline.cljs$core$IFn$_invoke$arity$2 = (function (zloc,n){\nreturn rewrite_clj.zip.whitespace.append_newline.cljs$core$IFn$_invoke$arity$2(zloc,n);\n}));\n\n(rewrite_clj.zip.append_newline.cljs$core$IFn$_invoke$arity$1 = (function (zloc){\nreturn rewrite_clj.zip.whitespace.append_newline.cljs$core$IFn$_invoke$arity$1(zloc);\n}));\n\n(rewrite_clj.zip.append_newline.cljs$lang$maxFixedArity = 2);\n\n/**\n * Raw version of [[right]].\n * \n * Returns zipper with location at the right sibling of the current node in `zloc`, or nil.\n * \n * NOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.\n */\nrewrite_clj.zip.right_STAR_ = (function rewrite_clj$zip$right_STAR_(zloc){\nreturn rewrite_clj.custom_zipper.core.right(zloc);\n});\n/**\n * Raw version of [[left]].\n * \n * Returns zipper with location at the left sibling of the current node in `zloc`, or nil.\n * \n * NOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.\n */\nrewrite_clj.zip.left_STAR_ = (function rewrite_clj$zip$left_STAR_(zloc){\nreturn rewrite_clj.custom_zipper.core.left(zloc);\n});\n/**\n * Raw version of [[up]].\n * \n * Returns zipper with the location at the parent of current node in `zloc`, or nil if at\n *   the top.\n * \n * NOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.\n */\nrewrite_clj.zip.up_STAR_ = (function rewrite_clj$zip$up_STAR_(zloc){\nreturn rewrite_clj.custom_zipper.core.up(zloc);\n});\n/**\n * Raw version of [[down]].\n * \n * Returns zipper with the location at the leftmost child of current node in `zloc`, or\n *   nil if no children.\n * \n * NOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.\n */\nrewrite_clj.zip.down_STAR_ = (function rewrite_clj$zip$down_STAR_(zloc){\nreturn rewrite_clj.custom_zipper.core.down(zloc);\n});\n/**\n * Raw version of [[next]].\n * \n * Returns zipper with location at the next depth-first location in the hierarchy in `zloc`.\n *   When reaching the end, returns a distinguished zipper detectable via [[end?]]. If already\n *   at the end, stays there.\n * \n * NOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.\n */\nrewrite_clj.zip.next_STAR_ = (function rewrite_clj$zip$next_STAR_(zloc){\nreturn rewrite_clj.custom_zipper.core.next(zloc);\n});\n/**\n * Raw version of [[prev]].\n * \n * Returns zipper with location at the previous depth-first location in the hierarchy in `zloc`.\n *   If already at the root, returns nil.\n * \n * NOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.\n */\nrewrite_clj.zip.prev_STAR_ = (function rewrite_clj$zip$prev_STAR_(zloc){\nreturn rewrite_clj.custom_zipper.core.prev(zloc);\n});\n/**\n * Raw version of [[rightmost]].\n * \n * Returns zipper with location at the rightmost sibling of the current node in `zloc`, or self.\n * \n * NOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.\n */\nrewrite_clj.zip.rightmost_STAR_ = (function rewrite_clj$zip$rightmost_STAR_(zloc){\nreturn rewrite_clj.custom_zipper.core.rightmost(zloc);\n});\n/**\n * Raw version of [[leftmost]].\n * \n * Returns zipper with location at the leftmost sibling of the current node in `zloc`, or self.\n * \n * NOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.\n */\nrewrite_clj.zip.leftmost_STAR_ = (function rewrite_clj$zip$leftmost_STAR_(zloc){\nreturn rewrite_clj.custom_zipper.core.leftmost(zloc);\n});\n/**\n * Raw version of [[replace]].\n * \n * Returns zipper with `node` replacing current node in `zloc`, without moving location.\n * \n * NOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.\n */\nrewrite_clj.zip.replace_STAR_ = (function rewrite_clj$zip$replace_STAR_(zloc,node){\nreturn rewrite_clj.custom_zipper.core.replace(zloc,node);\n});\n/**\n * Raw version of [[edit]].\n * \n * Returns zipper with value of `(apply f current-node args)` replacing current node in `zloc`.\n * \n * The result of `f` should be a rewrite-clj node.\n * \n * NOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.\n */\nrewrite_clj.zip.edit_STAR_ = (function rewrite_clj$zip$edit_STAR_(var_args){\nvar args__5775__auto__ = [];\nvar len__5769__auto___41496 = arguments.length;\nvar i__5770__auto___41497 = (0);\nwhile(true){\nif((i__5770__auto___41497 < len__5769__auto___41496)){\nargs__5775__auto__.push((arguments[i__5770__auto___41497]));\n\nvar G__41498 = (i__5770__auto___41497 + (1));\ni__5770__auto___41497 = G__41498;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__5776__auto__ = ((((2) < args__5775__auto__.length))?(new cljs.core.IndexedSeq(args__5775__auto__.slice((2)),(0),null)):null);\nreturn rewrite_clj.zip.edit_STAR_.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__5776__auto__);\n});\n\n(rewrite_clj.zip.edit_STAR_.cljs$core$IFn$_invoke$arity$variadic = (function (zloc,f,args){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$4(rewrite_clj.custom_zipper.core.edit,zloc,f,args);\n}));\n\n(rewrite_clj.zip.edit_STAR_.cljs$lang$maxFixedArity = (2));\n\n/** @this {Function} */\n(rewrite_clj.zip.edit_STAR_.cljs$lang$applyTo = (function (seq41421){\nvar G__41422 = cljs.core.first(seq41421);\nvar seq41421__$1 = cljs.core.next(seq41421);\nvar G__41423 = cljs.core.first(seq41421__$1);\nvar seq41421__$2 = cljs.core.next(seq41421__$1);\nvar self__5754__auto__ = this;\nreturn self__5754__auto__.cljs$core$IFn$_invoke$arity$variadic(G__41422,G__41423,seq41421__$2);\n}));\n\n/**\n * Raw version of [[remove]].\n * \n * Returns zipper with current node in `zloc` removed, with location at node that would have preceded\n *   it in a depth-first walk.\n * \n * NOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.\n */\nrewrite_clj.zip.remove_STAR_ = (function rewrite_clj$zip$remove_STAR_(zloc){\nreturn rewrite_clj.custom_zipper.core.remove(zloc);\n});\n/**\n * Raw version of [[insert-left]].\n * \n * Returns zipper with `item` inserted as the left sibling of current node in `zloc`,\n *  without moving location.\n * \n * NOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.\n */\nrewrite_clj.zip.insert_left_STAR_ = (function rewrite_clj$zip$insert_left_STAR_(zloc,item){\nreturn rewrite_clj.custom_zipper.core.insert_left(zloc,item);\n});\n/**\n * Raw version of [[insert-right]].\n * \n * Returns zipper with `item` inserted as the right sibling of the current node in `zloc`,\n *   without moving location.\n * \n * NOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.\n */\nrewrite_clj.zip.insert_right_STAR_ = (function rewrite_clj$zip$insert_right_STAR_(zloc,item){\nreturn rewrite_clj.custom_zipper.core.insert_right(zloc,item);\n});\n/**\n * Raw version of [[insert-child]].\n * \n * Returns zipper with `item` inserted as the leftmost child of the current node in `zloc`,\n *   without moving location.\n * \n * NOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.\n */\nrewrite_clj.zip.insert_child_STAR_ = (function rewrite_clj$zip$insert_child_STAR_(zloc,item){\nreturn rewrite_clj.custom_zipper.core.insert_child(zloc,item);\n});\n/**\n * Raw version of [[append-child]].\n * \n * Returns zipper with `item` inserted as the rightmost child of the current node in `zloc`,\n *   without moving.\n * \n * NOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.\n */\nrewrite_clj.zip.append_child_STAR_ = (function rewrite_clj$zip$append_child_STAR_(zloc,item){\nreturn rewrite_clj.custom_zipper.core.append_child(zloc,item);\n});\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:doc","A rich API for navigating and updating Clojure/ClojureScripti/EDN source code via a zipper tree.\n\n  The zipper holds a tree of nodes representing source code. It also holds your current location while navigating\n  through the tree and any pending changes you have made. Changes are applied back into the tree\n  when invoking root functions.\n\n  Although they are preserved, whitespace and comment nodes are normally skipped when navigating through the tree.\n  There are times when you will want to include whitespace and comment nodes, and as you see below, provisions are\n  available to do so.\n\n  It is good to remember that while some function names convey mutation, we are never changing anything, we are\n  instead returning modified copies.\n\n  Some conventions in the code and docstrings:\n  - `zloc` is the used as the argument name for our zipper\n  - \"current node in `zloc`\" is shorthand for: node at current location in zipper `zloc`\n\n  Because this API contains many functions, we offer the following categorized listing:\n\n  **Create a zipper**\n  [[edn]]\n  [[edn*]]\n  [[of-string]]\n  [[of-file]]\n\n  **Move**\n  [[left]]\n  [[right]]\n  [[up]]\n  [[down]]\n  [[prev]]\n  [[next]]\n  [[leftmost]]\n  [[rightmost]]\n\n  **Move without skipping whitespace and comments**\n  [[left*]]\n  [[right*]]\n  [[up*]]\n  [[down*]]\n  [[prev*]]\n  [[next*]]\n  [[leftmost*]]\n  [[rightmost*]]\n\n  **Whitespace/comment aware skip**\n  [[skip]]\n  [[skip-whitespace]]\n  [[skip-whitespace-left]]\n\n  **Test for whitespace**\n  [[whitespace?]]\n  [[linebreak?]]\n  [[whitespace-or-comment?]]\n\n  **Test location**\n  [[leftmost?]]\n  [[rightmost?]]\n  [[end?]]\n\n  **Test data type**\n  [[seq?]]\n  [[list?]]\n  [[vector?]]\n  [[set?]]\n  [[map?]]\n  [[namespaced-map?]]\n\n  **Find**\n  [[find]]\n  [[find-next]]\n  [[find-depth-first]]\n  [[find-next-depth-first]]\n  [[find-tag]]\n  [[find-next-tag]]\n  [[find-value]]\n  [[find-next-value]]\n  [[find-token]]\n  [[find-next-token]]\n  [[find-last-by-pos]]\n  [[find-tag-by-pos]]\n\n  **Inspect**\n  [[node]]\n  [[position]]\n  [[position-span]]\n  [[tag]]\n  [[length]]\n\n  **Convert**\n  [[sexpr-able?]]\n  [[sexpr]]\n  [[child-sexprs]]\n  [[reapply-context]]\n\n  **Update**\n  [[replace]]\n  [[edit]]\n  [[splice]]\n  [[prefix]]\n  [[suffix]]\n  [[insert-right]]\n  [[insert-left]]\n  [[insert-child]]\n  [[insert-space-left]]\n  [[insert-space-right]]\n  [[insert-newline-left]]\n  [[insert-newline-right]]\n  [[append-child]]\n  [[remove]]\n  [[remove-preserve-newline]]\n  [[root]]\n\n  **Update without whitespace treatment**\n  [[replace*]]\n  [[edit*]]\n  [[insert-left*]]\n  [[insert-right*]]\n  [[insert-child*]]\n  [[append-child*]]\n  [[remove*]]\n\n  **Update without changing location**\n  [[edit-node]]\n  [[edit->]]\n  [[edit->>]]\n\n  **Isolated update without changing location**\n  [[subedit-node]]\n  [[subzip]]\n  [[prewalk]]\n  [[postwalk]]\n  [[subedit->]]\n  [[subedit->>]]\n\n  **Sequence operations**\n  [[map]]\n  [[map-keys]]\n  [[map-vals]]\n  [[get]]\n  [[assoc]]\n\n  **Stringify**\n  [[string]]\n  [[root-string]]\n\n  **Output**\n  [[print]]\n  [[print-root]]","~:file","rewrite_clj/zip.cljc","~:line",2,"~:column",5,"~:end-line",2,"~:end-column",20],"~:ns-aliases",["^ ","~$clojure.spec.alpha","~$cljs.spec.alpha","~$clojure.tools.reader.impl.utils","~$cljs.tools.reader.impl.utils","~$cljs.loader","~$shadow.loader","~$clojure.tools.reader.impl.commons","~$cljs.tools.reader.impl.commons","~$clojure.tools.reader.impl.errors","~$cljs.tools.reader.impl.errors","~$react","~$module$node_modules$react$index","~$clojure.tools.reader.reader-types","~$cljs.tools.reader.reader-types","~$clojure.tools.reader.edn","~$cljs.tools.reader.edn","~$clojure.pprint","~$cljs.pprint","~$react-dom","~$module$node_modules$react_dom$index","~$clojure.repl","~$cljs.repl"],"~:use-macros",null,"~:excludes",["~#set",["~$seq?","~$vector?","~$map","~$find","~$set?","~$remove","~$map?","~$get","~$replace","~$print","~$next","~$list?","~$assoc"]],"~:macros",["^ ","~$subedit->",["^ ","~:arglists",["~#list",[["~$zloc","~$&","~$body"]]],"^6","Like `->`, threads `zloc`, as an isolated sub-tree through forms, then zips\n   up to, and locates at, the root of the modified sub-tree.\n   \n   See [docs on sub editing](/doc/01-user-guide.adoc#sub-editing).","^8",721,"^9",1,"^7","rewrite_clj/zip.cljc","~:name","~$rewrite-clj.zip/subedit->","~:ns","~$rewrite-clj.zip","~:macro",true],"~$edit->>",["^ ","^19",["^1:",[["^1;","~$&","^1<"]]],"^6","Like `->>`, threads `zloc` through forms.\n   The resulting zipper will be located at the same path (i.e. the same\n   number of downwards and right movements from the root) as incoming `zloc`.\n   \n   See also [[subedit->>]] for an isolated edit.","^8",712,"^9",1,"^7","rewrite_clj/zip.cljc","^1=","~$rewrite-clj.zip/edit->>","^1?","^1@","^1A",true],"~$subedit->>",["^ ","^19",["^1:",[["^1;","~$&","^1<"]]],"^6","Like `->`. Threads `zloc`, as an isolated sub-tree through forms, then zips\n      up to, and locates at, the root of the modified sub-tree.\n\n   See [docs on sub editing](/doc/01-user-guide.adoc#sub-editing).","^8",729,"^9",1,"^7","rewrite_clj/zip.cljc","^1=","~$rewrite-clj.zip/subedit->>","^1?","^1@","^1A",true],"~$edit->",["^ ","^19",["^1:",[["^1;","~$&","^1<"]]],"^6","Like `->`, threads `zloc` through forms.\n   The resulting zipper will be located at the same path (i.e. the same\n   number of downwards and right movements from the root) as incoming `zloc`.\n   \n   See also [[subedit->]] for an isolated edit.","^8",703,"^9",1,"^7","rewrite_clj/zip.cljc","^1=","~$rewrite-clj.zip/edit->","^1?","^1@","^1A",true]],"^1=","^1@","~:reader-aliases",["^ "],"~:op","^1?","~:imports",null,"~:requires",["^ ","~$rewrite-clj.zip.removez","^1L","~$rewrite-clj.zip.subedit","^1M","~$rewrite-clj.zip.findz","^1N","~$rewrite-clj.custom-zipper.core","^1O","~$cljs.core","^1P","~$goog","^1Q","~$rewrite-clj.zip.insert","^1R","~$rewrite-clj.zip.whitespace","^1S","~$rewrite-clj.zip.move","^1T","~$rewrite-clj.zip.editz","^1U","~$rewrite-clj.zip.context","^1V","~$rewrite-clj.zip.walk","^1W","~$rewrite-clj.zip.seqz","^1X","~$rewrite-clj.zip.base","^1Y","~$rewrite-clj.node.coercer","^1Z"],"~:seen",["^U",["~:require","~:require-macros"]],"~:uses",null,"^21",["^ ","^1M","^1M","^1@","^1@","^1P","^1P"],"~:form",["^1:",["~$ns","^1@","A rich API for navigating and updating Clojure/ClojureScripti/EDN source code via a zipper tree.\n\n  The zipper holds a tree of nodes representing source code. It also holds your current location while navigating\n  through the tree and any pending changes you have made. Changes are applied back into the tree\n  when invoking root functions.\n\n  Although they are preserved, whitespace and comment nodes are normally skipped when navigating through the tree.\n  There are times when you will want to include whitespace and comment nodes, and as you see below, provisions are\n  available to do so.\n\n  It is good to remember that while some function names convey mutation, we are never changing anything, we are\n  instead returning modified copies.\n\n  Some conventions in the code and docstrings:\n  - `zloc` is the used as the argument name for our zipper\n  - \"current node in `zloc`\" is shorthand for: node at current location in zipper `zloc`\n\n  Because this API contains many functions, we offer the following categorized listing:\n\n  **Create a zipper**\n  [[edn]]\n  [[edn*]]\n  [[of-string]]\n  [[of-file]]\n\n  **Move**\n  [[left]]\n  [[right]]\n  [[up]]\n  [[down]]\n  [[prev]]\n  [[next]]\n  [[leftmost]]\n  [[rightmost]]\n\n  **Move without skipping whitespace and comments**\n  [[left*]]\n  [[right*]]\n  [[up*]]\n  [[down*]]\n  [[prev*]]\n  [[next*]]\n  [[leftmost*]]\n  [[rightmost*]]\n\n  **Whitespace/comment aware skip**\n  [[skip]]\n  [[skip-whitespace]]\n  [[skip-whitespace-left]]\n\n  **Test for whitespace**\n  [[whitespace?]]\n  [[linebreak?]]\n  [[whitespace-or-comment?]]\n\n  **Test location**\n  [[leftmost?]]\n  [[rightmost?]]\n  [[end?]]\n\n  **Test data type**\n  [[seq?]]\n  [[list?]]\n  [[vector?]]\n  [[set?]]\n  [[map?]]\n  [[namespaced-map?]]\n\n  **Find**\n  [[find]]\n  [[find-next]]\n  [[find-depth-first]]\n  [[find-next-depth-first]]\n  [[find-tag]]\n  [[find-next-tag]]\n  [[find-value]]\n  [[find-next-value]]\n  [[find-token]]\n  [[find-next-token]]\n  [[find-last-by-pos]]\n  [[find-tag-by-pos]]\n\n  **Inspect**\n  [[node]]\n  [[position]]\n  [[position-span]]\n  [[tag]]\n  [[length]]\n\n  **Convert**\n  [[sexpr-able?]]\n  [[sexpr]]\n  [[child-sexprs]]\n  [[reapply-context]]\n\n  **Update**\n  [[replace]]\n  [[edit]]\n  [[splice]]\n  [[prefix]]\n  [[suffix]]\n  [[insert-right]]\n  [[insert-left]]\n  [[insert-child]]\n  [[insert-space-left]]\n  [[insert-space-right]]\n  [[insert-newline-left]]\n  [[insert-newline-right]]\n  [[append-child]]\n  [[remove]]\n  [[remove-preserve-newline]]\n  [[root]]\n\n  **Update without whitespace treatment**\n  [[replace*]]\n  [[edit*]]\n  [[insert-left*]]\n  [[insert-right*]]\n  [[insert-child*]]\n  [[append-child*]]\n  [[remove*]]\n\n  **Update without changing location**\n  [[edit-node]]\n  [[edit->]]\n  [[edit->>]]\n\n  **Isolated update without changing location**\n  [[subedit-node]]\n  [[subzip]]\n  [[prewalk]]\n  [[postwalk]]\n  [[subedit->]]\n  [[subedit->>]]\n\n  **Sequence operations**\n  [[map]]\n  [[map-keys]]\n  [[map-vals]]\n  [[get]]\n  [[assoc]]\n\n  **Stringify**\n  [[string]]\n  [[root-string]]\n\n  **Output**\n  [[print]]\n  [[print-root]]",["^1:",["~:refer-clojure","~:exclude",["^14","^Y","^12","^[","^V","^10","^W","^15","^Z","^13","^X","^11","^16"]]],["^1:",["^20",["^1O"],["^1Z"],["^1Y"],["^1V"],["^1U"],["^1N"],["^1R"],["^1T"],["^1L"],["^1X"],["^1M","~:include-macros",true],["^1W"],["^1S"]]],["^1:",["^21",["^1@"]]]]],"~:flags",["^ ","^20",["^U",[]],"^21",["^U",[]]],"~:js-deps",["^ "],"~:deps",["^1Q","^1P","^1O","^1Z","^1Y","^1V","^1U","^1N","^1R","^1T","^1L","^1X","^1M","^1W","^1S"]],"^1?","^1@","~:resource-id",["~:shadow.build.classpath/resource","rewrite_clj/zip.cljc"],"~:compiled-at",1666857667172,"^1H",["^ ","^1L","^1L","^1M","^1M","^1N","^1N","^1@","^1@","^1O","^1O","^1P","^1P","^1Q","^1Q","^1R","^1R","^1S","^1S","^1T","^1T","^1U","^1U","^1V","^1V","^1W","^1W","^1X","^1X","^1Y","^1Y","^1Z","^1Z"],"~:resource-name","rewrite_clj/zip.cljc","~:warnings",[],"~:source",";; DO NOT EDIT FILE, automatically generated from: ./template/rewrite_clj/zip.cljc\n(ns rewrite-clj.zip\n  \"A rich API for navigating and updating Clojure/ClojureScripti/EDN source code via a zipper tree.\n\n  The zipper holds a tree of nodes representing source code. It also holds your current location while navigating\n  through the tree and any pending changes you have made. Changes are applied back into the tree\n  when invoking root functions.\n\n  Although they are preserved, whitespace and comment nodes are normally skipped when navigating through the tree.\n  There are times when you will want to include whitespace and comment nodes, and as you see below, provisions are\n  available to do so.\n\n  It is good to remember that while some function names convey mutation, we are never changing anything, we are\n  instead returning modified copies.\n\n  Some conventions in the code and docstrings:\n  - `zloc` is the used as the argument name for our zipper\n  - \\\"current node in `zloc`\\\" is shorthand for: node at current location in zipper `zloc`\n\n  Because this API contains many functions, we offer the following categorized listing:\n\n  **Create a zipper**\n  [[edn]]\n  [[edn*]]\n  [[of-string]]\n  [[of-file]]\n\n  **Move**\n  [[left]]\n  [[right]]\n  [[up]]\n  [[down]]\n  [[prev]]\n  [[next]]\n  [[leftmost]]\n  [[rightmost]]\n\n  **Move without skipping whitespace and comments**\n  [[left*]]\n  [[right*]]\n  [[up*]]\n  [[down*]]\n  [[prev*]]\n  [[next*]]\n  [[leftmost*]]\n  [[rightmost*]]\n\n  **Whitespace/comment aware skip**\n  [[skip]]\n  [[skip-whitespace]]\n  [[skip-whitespace-left]]\n\n  **Test for whitespace**\n  [[whitespace?]]\n  [[linebreak?]]\n  [[whitespace-or-comment?]]\n\n  **Test location**\n  [[leftmost?]]\n  [[rightmost?]]\n  [[end?]]\n\n  **Test data type**\n  [[seq?]]\n  [[list?]]\n  [[vector?]]\n  [[set?]]\n  [[map?]]\n  [[namespaced-map?]]\n\n  **Find**\n  [[find]]\n  [[find-next]]\n  [[find-depth-first]]\n  [[find-next-depth-first]]\n  [[find-tag]]\n  [[find-next-tag]]\n  [[find-value]]\n  [[find-next-value]]\n  [[find-token]]\n  [[find-next-token]]\n  [[find-last-by-pos]]\n  [[find-tag-by-pos]]\n\n  **Inspect**\n  [[node]]\n  [[position]]\n  [[position-span]]\n  [[tag]]\n  [[length]]\n\n  **Convert**\n  [[sexpr-able?]]\n  [[sexpr]]\n  [[child-sexprs]]\n  [[reapply-context]]\n\n  **Update**\n  [[replace]]\n  [[edit]]\n  [[splice]]\n  [[prefix]]\n  [[suffix]]\n  [[insert-right]]\n  [[insert-left]]\n  [[insert-child]]\n  [[insert-space-left]]\n  [[insert-space-right]]\n  [[insert-newline-left]]\n  [[insert-newline-right]]\n  [[append-child]]\n  [[remove]]\n  [[remove-preserve-newline]]\n  [[root]]\n\n  **Update without whitespace treatment**\n  [[replace*]]\n  [[edit*]]\n  [[insert-left*]]\n  [[insert-right*]]\n  [[insert-child*]]\n  [[append-child*]]\n  [[remove*]]\n\n  **Update without changing location**\n  [[edit-node]]\n  [[edit->]]\n  [[edit->>]]\n\n  **Isolated update without changing location**\n  [[subedit-node]]\n  [[subzip]]\n  [[prewalk]]\n  [[postwalk]]\n  [[subedit->]]\n  [[subedit->>]]\n\n  **Sequence operations**\n  [[map]]\n  [[map-keys]]\n  [[map-vals]]\n  [[get]]\n  [[assoc]]\n\n  **Stringify**\n  [[string]]\n  [[root-string]]\n\n  **Output**\n  [[print]]\n  [[print-root]]\"\n  (:refer-clojure :exclude [next find replace remove\n                            seq? map? vector? list? set?\n                            print map get assoc])\n  (:require [rewrite-clj.custom-zipper.core]\n            [rewrite-clj.node.coercer] ;; load coercions to make them available\n            [rewrite-clj.zip.base]\n            [rewrite-clj.zip.context]\n            [rewrite-clj.zip.editz]\n            [rewrite-clj.zip.findz]\n            [rewrite-clj.zip.insert]\n            [rewrite-clj.zip.move]\n            [rewrite-clj.zip.removez]\n            [rewrite-clj.zip.seqz]\n            [rewrite-clj.zip.subedit #?@(:cljs [:include-macros true])]\n            [rewrite-clj.zip.walk]\n            [rewrite-clj.zip.whitespace])\n  #?(:cljs (:require-macros [rewrite-clj.zip])))\n\n#?(:clj (set! *warn-on-reflection* true))\n\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.custom-zipper.core\n(defn node\n  \"Returns the current node in `zloc`.\"\n  [zloc] (rewrite-clj.custom-zipper.core/node zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.custom-zipper.core\n(defn position\n  \"Returns the ones-based `[row col]` of the start of the current node in `zloc`.\n   \n  Throws if `zloc` was not created with [position tracking](/doc/01-user-guide.adoc#position-tracking).\"\n  [zloc] (rewrite-clj.custom-zipper.core/position zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.custom-zipper.core\n(defn position-span\n  \"Returns the ones-based `[[start-row start-col] [end-row end-col]]` of the current node in `zloc`.\n  `end-col` is exclusive.\n\n  Throws if `zloc` was not created with [position tracking](/doc/01-user-guide.adoc#position-tracking).\"\n  [zloc] (rewrite-clj.custom-zipper.core/position-span zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.custom-zipper.core\n(defn root\n  \"Zips all the way up `zloc` and returns the root node, reflecting any changes.\"\n  [zloc] (rewrite-clj.custom-zipper.core/root zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.base\n(defn ^{:added \"0.4.4\"} child-sexprs\n  \"Return s-expression (the Clojure forms) of children of current node in `zloc`.\n\n  See docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances).\"\n  [zloc] (rewrite-clj.zip.base/child-sexprs zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.base\n(defn edn*\n  \"Create and return zipper from Clojure/ClojureScript/EDN `node` (likely parsed by [[rewrite-clj.parse]]).\n\n  Optional `opts` can specify:\n  - `:track-position?` set to `true` to enable ones-based row/column tracking, see [docs on position tracking](/doc/01-user-guide.adoc#position-tracking).\n  - `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)\"\n  ([node] (rewrite-clj.zip.base/edn* node))\n  ([node opts] (rewrite-clj.zip.base/edn* node opts)))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.base\n(defn edn\n  \"Create and return zipper from Clojure/ClojureScript/EDN `node` (likely parsed by [[rewrite-clj.parse]]),\n  and move to the first non-whitespace/non-comment child. If node is not forms node, is wrapped in forms node\n  for a consistent root.\n\n  Optional `opts` can specify:\n  - `:track-position?` set to `true` to enable ones-based row/column tracking, see [docs on position tracking](/doc/01-user-guide.adoc#position-tracking).\n  - `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)\"\n  ([node] (rewrite-clj.zip.base/edn node))\n  ([node opts] (rewrite-clj.zip.base/edn node opts)))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.base\n(defn tag\n  \"Return tag of current node in `zloc`.\"\n  [zloc] (rewrite-clj.zip.base/tag zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.base\n(defn sexpr\n  \"Return s-expression (the Clojure form) of current node in `zloc`.\n\n  See docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances).\"\n  [zloc] (rewrite-clj.zip.base/sexpr zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.base\n(defn sexpr-able?\n  \"Return true if current node's element type in `zloc` can be [[sexpr]]-ed.\n\n   See [related docs in user guide](/doc/01-user-guide.adoc#not-all-clojure-is-sexpr-able)\"\n  [zloc] (rewrite-clj.zip.base/sexpr-able? zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.base\n(defn length\n  \"Return length of printable [[string]] of current node in `zloc`.\"\n  [zloc] (rewrite-clj.zip.base/length zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.base\n(defn ^{:deprecated \"0.4.0\"} value\n  \"DEPRECATED. Return a tag/s-expression pair for inner nodes, or\n   the s-expression itself for leaves.\"\n  [zloc] (rewrite-clj.zip.base/value zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.base\n(defn of-string\n  \"Create and return zipper from all forms in Clojure/ClojureScript/EDN string `s`.\n\n  Optional `opts` can specify:\n  - `:track-position?` set to `true` to enable ones-based row/column tracking, see [docs on position tracking](/doc/01-user-guide.adoc#position-tracking).\n  - `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)\"\n  ([s] (rewrite-clj.zip.base/of-string s))\n  ([s opts] (rewrite-clj.zip.base/of-string s opts)))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.base\n(defn ^{:added \"0.4.0\"} string\n  \"Return string representing the current node in `zloc`.\"\n  [zloc] (rewrite-clj.zip.base/string zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.base\n(defn ^{:deprecated \"0.4.0\"} ->string\n  \"DEPRECATED. Renamed to [[string]].\"\n  [zloc] (rewrite-clj.zip.base/->string zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.base\n(defn ^{:added \"0.4.0\"} root-string\n  \"Return string representing the zipped-up `zloc` zipper.\"\n  [zloc] (rewrite-clj.zip.base/root-string zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.base\n(defn ^{:deprecated \"0.4.0\"} ->root-string\n  \"DEPRECATED. Renamed to [[root-string]].\"\n  [zloc] (rewrite-clj.zip.base/->root-string zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.base\n(defn print\n  \"Print current node in `zloc`.\n\n   NOTE: Optional `writer` is currently ignored for ClojureScript.\"\n  ([zloc writer] (rewrite-clj.zip.base/print zloc writer))\n  ([zloc] (rewrite-clj.zip.base/print zloc)))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.base\n(defn print-root\n  \"Zip up and print `zloc` from root node.\n\n   NOTE: Optional `writer` is currently ignored for ClojureScript.\"\n  ([zloc writer] (rewrite-clj.zip.base/print-root zloc writer))\n  ([zloc] (rewrite-clj.zip.base/print-root zloc)))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.editz\n(defn replace\n  \"Return `zloc` with the current node replaced by `value`.\n  If `value` is not already a node, an attempt will be made to coerce it to one.\"\n  [zloc value] (rewrite-clj.zip.editz/replace zloc value))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.editz\n(defn edit\n  \"Return `zloc` with the current node replaced with the result of:\n\n   `(apply f (s-expr current-node) args)`\n\n  The result of `f`, if not already a node, will be coerced to a node if possible.\n\n  See docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances).\"\n  [zloc f & args] (apply rewrite-clj.zip.editz/edit zloc f args))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.editz\n(defn splice\n  \"Return zipper with the children of the current node in `zloc` merged into itself.\n   (akin to Clojure's `unquote-splicing` macro: `~@...`).\n   - if the node is not one that can have children, no modification will\n     be performed.\n   - if the node has no or only whitespace children, it will be removed.\n   - otherwise, splicing will be performed, moving the zipper to the first\n     non-whitespace spliced child node.\n\n  For example, given `[[1 2 3] 4 5 6]`, if zloc is located at vector `[1 2 3]`, a splice will result in raising the vector's children up `[1 2 3 4 5 6]` and locating the zipper at node `1`.\"\n  [zloc] (rewrite-clj.zip.editz/splice zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.editz\n(defn prefix\n  \"Return zipper with the current node in `zloc` prefixed with string `s`.\n   Operates on token node or a multi-line node, else exception is thrown.\n   When multi-line, first line is prefixed.\"\n  [zloc s] (rewrite-clj.zip.editz/prefix zloc s))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.editz\n(defn suffix\n  \"Return zipper with the current node in `zloc` suffixed with string `s`.\n   Operates on token node or a multi-line node, else exception is thrown.\n   When multi-line, last line is suffixed.\"\n  [zloc s] (rewrite-clj.zip.editz/suffix zloc s))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.context\n(defn reapply-context\n  \"Returns `zloc` with namespaced map sexpr context to all symbols and keywords reapplied from current location downward.\n\n  Keywords and symbols:\n  * that are keys in a namespaced map will have namespaced map context applied\n  * otherwise will have any namespaced map context removed\n\n  You should only need to use this function if:\n  * you care about `sexpr` on keywords and symbols\n  * and you are moving keywords and symbols from a namespaced map to some other location.\"\n  [zloc] (rewrite-clj.zip.context/reapply-context zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.findz\n(defn find\n  \"Return `zloc` located to the first node satisfying predicate `p?` else nil.\n   Search starts at the current node and continues via movement function `f`.\n\n   `f` defaults to [[rewrite-clj.zip/right]]\"\n  ([zloc p?] (rewrite-clj.zip.findz/find zloc p?))\n  ([zloc f p?] (rewrite-clj.zip.findz/find zloc f p?)))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.findz\n(defn find-next\n  \"Return `zloc` located to the next node satisfying predicate `p?` else `nil`.\n   Search starts one movement `f` from the current node and continues via `f`.\n\n   `f` defaults to [[rewrite-clj.zip/right]]\"\n  ([zloc p?] (rewrite-clj.zip.findz/find-next zloc p?))\n  ([zloc f p?] (rewrite-clj.zip.findz/find-next zloc f p?)))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.findz\n(defn find-depth-first\n  \"Return `zloc` located to the first node satisfying predicate `p?` else `nil`.\n   Search is depth-first from the current node.\"\n  [zloc p?] (rewrite-clj.zip.findz/find-depth-first zloc p?))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.findz\n(defn find-next-depth-first\n  \"Return `zloc` located to next node satisfying predicate `p?` else `nil`.\n   Search starts depth-first after the current node.\"\n  [zloc p?] (rewrite-clj.zip.findz/find-next-depth-first zloc p?))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.findz\n(defn find-tag\n  \"Return `zloc` located to the first node with tag `t` else `nil`.\n   Search starts at the current node and continues via movement function `f`.\n\n   `f` defaults to [[rewrite-clj.zip/right]]\"\n  ([zloc t] (rewrite-clj.zip.findz/find-tag zloc t))\n  ([zloc f t] (rewrite-clj.zip.findz/find-tag zloc f t)))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.findz\n(defn find-next-tag\n  \"Return `zloc` located to the next node with tag `t` else `nil`.\n  Search starts one movement `f` after the current node and continues via `f`.\n\n   `f` defaults to [[rewrite-clj.zip/right]]\"\n  ([zloc t] (rewrite-clj.zip.findz/find-next-tag zloc t))\n  ([zloc f t] (rewrite-clj.zip.findz/find-next-tag zloc f t)))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.findz\n(defn find-value\n  \"Return `zloc` located to the first token node that `sexpr`esses to `v` else `nil`.\n   Search starts from the current node and continues via movement function `f`.\n\n   `v` can be a single value or a set. When `v` is a set, matches on any value in set.\n\n   `f` defaults to [[rewrite-clj.zip/right]] in short form call.\n\n  See docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances).\"\n  ([zloc v] (rewrite-clj.zip.findz/find-value zloc v))\n  ([zloc f v] (rewrite-clj.zip.findz/find-value zloc f v)))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.findz\n(defn find-next-value\n  \"Return `zloc` located to the next token node that `sexpr`esses to `v` else `nil`.\n   Search starts one movement `f` from the current location, and continues via `f`.\n\n   `v` can be a single value or a set. When `v` is a set matches on any value in set.\n\n   `f` defaults to [[rewrite-clj.zip/right]] in short form call.\n\n  See docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances).\"\n  ([zloc v] (rewrite-clj.zip.findz/find-next-value zloc v))\n  ([zloc f v] (rewrite-clj.zip.findz/find-next-value zloc f v)))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.findz\n(defn find-token\n  \"Return `zloc` located to the the first token node satisfying predicate `p?`.\n  Search starts at the current node and continues via movement function `f`.\n\n   `f` defaults to [[rewrite-clj.zip/right]]\"\n  ([zloc p?] (rewrite-clj.zip.findz/find-token zloc p?))\n  ([zloc f p?] (rewrite-clj.zip.findz/find-token zloc f p?)))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.findz\n(defn find-next-token\n  \"Return `zloc` located to the next token node satisfying predicate `p?` else `nil`.\n  Search starts one movement `f` after the current node and continues via `f`.\n\n   `f` defaults to [[rewrite-clj.zip/right]]\"\n  ([zloc p?] (rewrite-clj.zip.findz/find-next-token zloc p?))\n  ([zloc f p?] (rewrite-clj.zip.findz/find-next-token zloc f p?)))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.findz\n(defn find-last-by-pos\n  \"Return `zloc` located to the last node spanning position `pos` that satisfies predicate `p?` else `nil`.\n   Search is depth-first from the current node.\n\n  NOTE: Does not ignore whitespace/comment nodes.\"\n  ([zloc pos] (rewrite-clj.zip.findz/find-last-by-pos zloc pos))\n  ([zloc pos p?] (rewrite-clj.zip.findz/find-last-by-pos zloc pos p?)))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.findz\n(defn find-tag-by-pos\n  \"Return `zloc` located to the last node spanning position `pos` with tag `t` else `nil`.\n  Search is depth-first from the current node.\"\n  [zloc pos t] (rewrite-clj.zip.findz/find-tag-by-pos zloc pos t))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.insert\n(defn insert-right\n  \"Return zipper with `item` inserted to the right of the current node in `zloc`, without moving location.\n  Will insert a space if necessary.\"\n  [zloc item] (rewrite-clj.zip.insert/insert-right zloc item))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.insert\n(defn insert-left\n  \"Return zipper with `item` inserted to the left of the current node in `zloc`, without moving location.\n  Will insert a space if necessary.\"\n  [zloc item] (rewrite-clj.zip.insert/insert-left zloc item))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.insert\n(defn insert-child\n  \"Return zipper with `item` inserted as the first child of the current node in `zloc`, without moving location.\"\n  [zloc item] (rewrite-clj.zip.insert/insert-child zloc item))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.insert\n(defn append-child\n  \"Return zipper with `item` inserted as the last child of the current node in `zloc`, without moving.\n  Will insert a space if necessary.\"\n  [zloc item] (rewrite-clj.zip.insert/append-child zloc item))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.move\n(defn left\n  \"Return zipper with location moved left to next non-whitespace/non-comment sibling of current node in `zloc`.\"\n  [zloc] (rewrite-clj.zip.move/left zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.move\n(defn right\n  \"Return zipper with location moved right to next non-whitespace/non-comment sibling of current node in `zloc`.\"\n  [zloc] (rewrite-clj.zip.move/right zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.move\n(defn up\n  \"Return zipper with location moved up to next non-whitespace/non-comment parent of current node in `zloc`, or `nil` if at the top.\"\n  [zloc] (rewrite-clj.zip.move/up zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.move\n(defn down\n  \"Return zipper with location moved down to the first non-whitespace/non-comment child node of the current node in `zloc`, or nil if no applicable children.\"\n  [zloc] (rewrite-clj.zip.move/down zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.move\n(defn prev\n  \"Return zipper with location moved to the previous depth-first non-whitespace/non-comment node in `zloc`. If already at root, returns nil.\"\n  [zloc] (rewrite-clj.zip.move/prev zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.move\n(defn next\n  \"Return zipper with location moved to the next depth-first non-whitespace/non-comment node in `zloc`.\n   End can be detected with [[end?]], if already at end, stays there.\"\n  [zloc] (rewrite-clj.zip.move/next zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.move\n(defn leftmost\n  \"Return zipper with location moved to the leftmost non-whitespace/non-comment sibling of current node in `zloc`.\"\n  [zloc] (rewrite-clj.zip.move/leftmost zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.move\n(defn rightmost\n  \"Return zipper with location moved to the rightmost non-whitespace/non-comment sibling of current node in `zloc`.\"\n  [zloc] (rewrite-clj.zip.move/rightmost zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.move\n(defn leftmost?\n  \"Return true if at leftmost non-whitespace/non-comment sibling node in `zloc`.\"\n  [zloc] (rewrite-clj.zip.move/leftmost? zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.move\n(defn rightmost?\n  \"Return true if at rightmost non-whitespace/non-comment sibling node in `zloc`.\"\n  [zloc] (rewrite-clj.zip.move/rightmost? zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.move\n(defn end?\n  \"Return true if `zloc` is at end of depth-first traversal.\"\n  [zloc] (rewrite-clj.zip.move/end? zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.removez\n(defn remove\n  \"Return `zloc` with current node removed. Returned zipper location\n   is moved to the first non-whitespace node preceding removed node in a depth-first walk.\n   Removes whitespace appropriately.\n\n  - `[1 |2  3]    => [|1 3]`\n  - `[1 |2]       => [|1]`\n  - `[|1 2]       => |[2]`\n  - `[|1]         => |[]`\n  - `[  |1  ]     => |[]`\n  - `[1 [2 3] |4] => [1 [2 |3]]`\n  - `[|1 [2 3] 4] => |[[2 3] 4]`\n\n   If the removed node is a rightmost sibling, both leading and trailing whitespace\n   is removed, otherwise only trailing whitespace is removed.\n\n   The result is that a following element (no matter whether it is on the same line\n   or not) will end up at same positon (line/column) as the removed one.\n   If a comment lies betwen the original node and the neighbour this will not hold true.\n   \n   If the removed node is at end of input and is trailed by 1 or more newlines, \n   a single trailing newline will be preserved.\"\n  [zloc] (rewrite-clj.zip.removez/remove zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.removez\n(defn remove-preserve-newline\n  \"Same as [[remove]] but preserves newlines.\n   Specifically: will trim all whitespace - or whitespace up to first linebreak if present.\"\n  [zloc] (rewrite-clj.zip.removez/remove-preserve-newline zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.seqz\n(defn seq?\n  \"Returns true if current node in `zloc` is a sequence.\"\n  [zloc] (rewrite-clj.zip.seqz/seq? zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.seqz\n(defn list?\n  \"Returns true if current node in `zloc` is a list.\"\n  [zloc] (rewrite-clj.zip.seqz/list? zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.seqz\n(defn vector?\n  \"Returns true if current node in `zloc` is a vector.\"\n  [zloc] (rewrite-clj.zip.seqz/vector? zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.seqz\n(defn set?\n  \"Returns true if current node in `zloc` is a set.\"\n  [zloc] (rewrite-clj.zip.seqz/set? zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.seqz\n(defn map?\n  \"Returns true if current node in `zloc` is a map.\"\n  [zloc] (rewrite-clj.zip.seqz/map? zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.seqz\n(defn namespaced-map?\n  \"Returns true if the current node in `zloc` is a namespaced map.\"\n  [zloc] (rewrite-clj.zip.seqz/namespaced-map? zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.seqz\n(defn map\n  \"Returns `zloc` with function `f` applied to all nodes of the current node.\n  Current node must be a sequence node. Equivalent to [[rewrite-clj.zip/map-vals]] for maps.\n\n  `zloc` location is unchanged.\n\n  `f` arg is zloc positioned at\n  - value nodes for maps\n  - each element of a seq\n  and is should return:\n  - an updated zloc with zloc positioned at edited node\n  - a falsey value to leave value node unchanged\n\n  Folks typically use [[rewrite-clj.zip/edit]] for `f`.\"\n  [f zloc] (rewrite-clj.zip.seqz/map f zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.seqz\n(defn map-keys\n  \"Returns `zloc` with function `f` applied to all key nodes of the current node.\n   Current node must be map node.\n\n  `zloc` location is unchanged.\n\n  `f` arg is zloc positioned at key node and should return:\n  - an updated zloc with zloc positioned at key node\n  - a falsey value to leave value node unchanged\n\n  Folks typically use [[rewrite-clj.zip/edit]] for `f`.\"\n  [f zloc] (rewrite-clj.zip.seqz/map-keys f zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.seqz\n(defn map-vals\n  \"Returns `zloc` with function `f` applied to each value node of the current node.\n   Current node must be map node.\n\n  `zloc` location is unchanged.\n\n  `f` arg is zloc positioned at value node and should return:\n  - an updated zloc with zloc positioned at value node\n  - a falsey value to leave value node unchanged\n\n  Folks typically use [[rewrite-clj.zip/edit]] for `f`.\"\n  [f zloc] (rewrite-clj.zip.seqz/map-vals f zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.seqz\n(defn get\n  \"Returns `zloc` located to map key node's sexpr value matching `k` else `nil`.\n\n  `k` should be:\n  - a key for maps\n  - a zero-based index for sequences\n\n  NOTE: `k` will be compared against resolved keywords in maps.\n  See docs for sexpr behavior on [namespaced elements](/doc/01-user-guide.adoc#namespaced-elements).\"\n  [zloc k] (rewrite-clj.zip.seqz/get zloc k))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.seqz\n(defn assoc\n  \"Returns `zloc` with current node's `k` set to value `v`.\n\n  `zloc` location is unchanged.\n\n  `k` should be:\n  - a key for maps\n  - a zero-based index for sequences, an exception is thrown if index is out of bounds\n\n  NOTE: `k` will be compared against resolved keywords in maps.\n  See docs for sexpr behavior on [namespaced elements](/doc/01-user-guide.adoc#namespaced-elements).\"\n  [zloc k v] (rewrite-clj.zip.seqz/assoc zloc k v))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.subedit\n(defn edit-node\n  \"Return zipper applying function `f` to `zloc`. The resulting\n   zipper will be located at the same path (i.e. the same number of\n   downwards and right movements from the root) incoming `zloc`.\n   \n   See also [[subedit-node]] for an isolated edit.\"\n  [zloc f] (rewrite-clj.zip.subedit/edit-node zloc f))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.subedit\n(defn subedit-node\n  \"Return zipper replacing current node in `zloc` with result of `f` applied to said node as an isolated sub-tree.\n   The resulting zipper will be located on the root of the modified sub-tree.\n   \n   See [docs on sub editing](/doc/01-user-guide.adoc#sub-editing).\"\n  [zloc f] (rewrite-clj.zip.subedit/subedit-node zloc f))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.subedit\n(defn subzip\n  \"Create and return a zipper whose root is the current node in `zloc`.\n   \n   See [docs on sub editing](/doc/01-user-guide.adoc#sub-editing).\"\n  [zloc] (rewrite-clj.zip.subedit/subzip zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.subedit\n(defmacro edit->\n  \"Like `->`, threads `zloc` through forms.\n   The resulting zipper will be located at the same path (i.e. the same\n   number of downwards and right movements from the root) as incoming `zloc`.\n   \n   See also [[subedit->]] for an isolated edit.\"\n  [zloc & body] `(rewrite-clj.zip.subedit/edit-> ~zloc ~@body))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.subedit\n(defmacro edit->>\n  \"Like `->>`, threads `zloc` through forms.\n   The resulting zipper will be located at the same path (i.e. the same\n   number of downwards and right movements from the root) as incoming `zloc`.\n   \n   See also [[subedit->>]] for an isolated edit.\"\n  [zloc & body] `(rewrite-clj.zip.subedit/edit->> ~zloc ~@body))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.subedit\n(defmacro subedit->\n  \"Like `->`, threads `zloc`, as an isolated sub-tree through forms, then zips\n   up to, and locates at, the root of the modified sub-tree.\n   \n   See [docs on sub editing](/doc/01-user-guide.adoc#sub-editing).\"\n  [zloc & body] `(rewrite-clj.zip.subedit/subedit-> ~zloc ~@body))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.subedit\n(defmacro subedit->>\n  \"Like `->`. Threads `zloc`, as an isolated sub-tree through forms, then zips\n      up to, and locates at, the root of the modified sub-tree.\n\n   See [docs on sub editing](/doc/01-user-guide.adoc#sub-editing).\"\n  [zloc & body] `(rewrite-clj.zip.subedit/subedit->> ~zloc ~@body))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.walk\n(defn prewalk\n  \"Return zipper modified by an isolated depth-first pre-order traversal.\n\n   Pre-order traversal visits root before children.\n   For example, traversal order of `(1 (2 3 (4 5) 6 (7 8)) 9)` is:\n\n   1. `(1 (2 3 (4 5) 6 (7 8)) 9)`\n   2. `1`\n   3. `(2 3 (4 5) 6 (7 8))`\n   4. `2`\n   5. `3`\n   6. `(4 5)`\n   7. `4`\n   8. `5`\n   9. `6`\n   10. `(7 8)`\n   11. `7`\n   12. `8`\n   13. `9`\n\n   Traversal starts at the current node in `zloc` and continues to the end of the isolated sub-tree.\n\n   Function `f` is called on the zipper locations satisfying predicate `p?` and must return either\n   - nil to indicate no changes\n   - or a valid zipper\n   WARNING: when function `f` changes the location in the zipper, normal traversal will be affected.\n\n   When `p?` is not specified `f` is called on all locations.\n\n   Note that by default a newly created zipper automatically navigates to the first non-whitespace\n   node. If you want to be sure to walk all forms in a zipper, you'll want to navigate one up prior to your walk:\n\n   ```Clojure\n   (-> (zip/of-string \\\"my clojure forms\\\")\n       zip/up\n       (zip/prewalk ...))\n   ```\n\n   See [docs on sub editing](/doc/01-user-guide.adoc#sub-editing).\"\n  ([zloc f] (rewrite-clj.zip.walk/prewalk zloc f))\n  ([zloc p? f] (rewrite-clj.zip.walk/prewalk zloc p? f)))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.walk\n(defn ^{:added \"0.4.9\"} postwalk\n  \"Return zipper modified by an isolated depth-first post-order traversal.\n\n   Pre-order traversal visits children before root.\n   For example, traversal order of `(1 (2 3 (4 5) 6 (7 8)) 9)` is:\n\n   1. `1`\n   2. `2`\n   3. `3`\n   4. `4`\n   5. `5`\n   6. `(4 5)`\n   7. `6`\n   8. `7`\n   9. `8`\n   10. `(7 8)`\n   11. `(2 3 (4 5) 6 (7 8))`\n   12. `9`\n   13. `(1 (2 3 (4 5) 6 (7 8)) 9)`\n\n   Traversal starts at the current node in `zloc` and continues to the end of the isolated sub-tree.\n\n   Function `f` is called on the zipper locations satisfying predicate `p?` and must return either\n   - nil to indicate no changes\n   - or a valid zipper\n   WARNING: when function `f` changes the location in the zipper, normal traversal will be affected.\n\n   When `p?` is not specified `f` is called on all locations.\n\n   Note that by default a newly created zipper automatically navigates to the first non-whitespace\n   node. If you want to be sure to walk all forms in a zipper, you'll want to navigate one up prior to your walk:\n\n   ```Clojure\n   (-> (zip/of-string \\\"my clojure forms\\\")\n       zip/up\n       (zip/postwalk ...))\n   ```\n\n   See [docs on sub editing](/doc/01-user-guide.adoc#sub-editing).\"\n  ([zloc f] (rewrite-clj.zip.walk/postwalk zloc f))\n  ([zloc p? f] (rewrite-clj.zip.walk/postwalk zloc p? f)))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.whitespace\n(defn whitespace?\n  \"Returns true when the current the node in `zloc` is a Clojure whitespace (which includes the comma).\"\n  [zloc] (rewrite-clj.zip.whitespace/whitespace? zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.whitespace\n(defn linebreak?\n  \"Returns true when the current node in `zloc` is a linebreak.\"\n  [zloc] (rewrite-clj.zip.whitespace/linebreak? zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.whitespace\n(defn whitespace-or-comment?\n  \"Returns true when current node in `zloc` is whitespace or a comment.\"\n  [zloc] (rewrite-clj.zip.whitespace/whitespace-or-comment? zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.whitespace\n(defn skip\n  \"Return zipper with location moved to first location not satisfying predicate `p?` starting from the node in\n   `zloc` and traversing by function `f`.\"\n  [f p? zloc] (rewrite-clj.zip.whitespace/skip f p? zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.whitespace\n(defn skip-whitespace\n  \"Return zipper with location moved to first non-whitespace/non-comment starting from current node in `zloc`\n   and traversing by function `f`.\n\n   `f` defaults to [[rewrite-clj.zip/right]]\"\n  ([zloc] (rewrite-clj.zip.whitespace/skip-whitespace zloc))\n  ([f zloc] (rewrite-clj.zip.whitespace/skip-whitespace f zloc)))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.whitespace\n(defn skip-whitespace-left\n  \"Return zipper with location moved to first non-whitespace/non-comment starting from current node in `zloc` traversing left.\"\n  [zloc] (rewrite-clj.zip.whitespace/skip-whitespace-left zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.whitespace\n(defn ^{:added \"0.5.0\"} insert-space-left\n  \"Return zipper with `n` space whitespace node inserted to the left of the current node in `zloc`, without moving location.\n   `n` defaults to 1.\"\n  ([zloc] (rewrite-clj.zip.whitespace/insert-space-left zloc))\n  ([zloc n] (rewrite-clj.zip.whitespace/insert-space-left zloc n)))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.whitespace\n(defn ^{:added \"0.5.0\"} insert-space-right\n  \"Return zipper with `n` space whitespace node inserted to the right of the current node in `zloc`, without moving location.\n   `n` defaults to 1.\"\n  ([zloc] (rewrite-clj.zip.whitespace/insert-space-right zloc))\n  ([zloc n] (rewrite-clj.zip.whitespace/insert-space-right zloc n)))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.whitespace\n(defn ^{:added \"0.5.0\"} insert-newline-left\n  \"Return zipper with `n` newlines node inserted to the left of the current node in `zloc`, without moving location.\n   `n` defaults to 1.\"\n  ([zloc] (rewrite-clj.zip.whitespace/insert-newline-left zloc))\n  ([zloc n] (rewrite-clj.zip.whitespace/insert-newline-left zloc n)))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.whitespace\n(defn ^{:added \"0.5.0\"} insert-newline-right\n  \"Return zipper with `n` newlines node inserted to the right of the current node in `zloc`, without moving location.\n   `n` defaults to 1.\"\n  ([zloc] (rewrite-clj.zip.whitespace/insert-newline-right zloc))\n  ([zloc n] (rewrite-clj.zip.whitespace/insert-newline-right zloc n)))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.whitespace\n(defn ^{:deprecated \"0.5.0\"} prepend-space\n  \"DEPRECATED: renamed to [[insert-space-left]].\"\n  ([zloc n] (rewrite-clj.zip.whitespace/prepend-space zloc n))\n  ([zloc] (rewrite-clj.zip.whitespace/prepend-space zloc)))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.whitespace\n(defn ^{:deprecated \"0.5.0\"} append-space\n  \"DEPRECATED: renamed to [[insert-space-right]].\"\n  ([zloc n] (rewrite-clj.zip.whitespace/append-space zloc n))\n  ([zloc] (rewrite-clj.zip.whitespace/append-space zloc)))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.whitespace\n(defn ^{:deprecated \"0.5.0\"} prepend-newline\n  \"DEPRECATED: renamed to [[insert-newline-left]].\"\n  ([zloc n] (rewrite-clj.zip.whitespace/prepend-newline zloc n))\n  ([zloc] (rewrite-clj.zip.whitespace/prepend-newline zloc)))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.whitespace\n(defn ^{:deprecated \"0.5.0\"} append-newline\n  \"DEPRECATED: renamed to [[insert-newline-right]].\"\n  ([zloc n] (rewrite-clj.zip.whitespace/append-newline zloc n))\n  ([zloc] (rewrite-clj.zip.whitespace/append-newline zloc)))\n;; TODO: clj-kondo barfs on an empty reader cond\n#?(:clj\n   \n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.zip.base\n(defn of-file\n  \"Create and return zipper from all forms in Clojure/ClojureScript/EDN File `f`.\n\n     Optional `opts` can specify:\n     - `:track-position?` set to `true` to enable ones-based row/column tracking, see [docs on position tracking](/doc/01-user-guide.adoc#position-tracking).\n     - `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)\"\n  ([f] (rewrite-clj.zip.base/of-file f))\n  ([f opts] (rewrite-clj.zip.base/of-file f opts))))\n\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.custom-zipper.core\n(defn right*\n  \"Raw version of [[right]].\n\nReturns zipper with location at the right sibling of the current node in `zloc`, or nil.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.\"\n  [zloc] (rewrite-clj.custom-zipper.core/right zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.custom-zipper.core\n(defn left*\n  \"Raw version of [[left]].\n\nReturns zipper with location at the left sibling of the current node in `zloc`, or nil.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.\"\n  [zloc] (rewrite-clj.custom-zipper.core/left zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.custom-zipper.core\n(defn up*\n  \"Raw version of [[up]].\n\nReturns zipper with the location at the parent of current node in `zloc`, or nil if at\n  the top.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.\"\n  [zloc] (rewrite-clj.custom-zipper.core/up zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.custom-zipper.core\n(defn down*\n  \"Raw version of [[down]].\n\nReturns zipper with the location at the leftmost child of current node in `zloc`, or\n  nil if no children.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.\"\n  [zloc] (rewrite-clj.custom-zipper.core/down zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.custom-zipper.core\n(defn next*\n  \"Raw version of [[next]].\n\nReturns zipper with location at the next depth-first location in the hierarchy in `zloc`.\n  When reaching the end, returns a distinguished zipper detectable via [[end?]]. If already\n  at the end, stays there.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.\"\n  [zloc] (rewrite-clj.custom-zipper.core/next zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.custom-zipper.core\n(defn prev*\n  \"Raw version of [[prev]].\n\nReturns zipper with location at the previous depth-first location in the hierarchy in `zloc`.\n  If already at the root, returns nil.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.\"\n  [zloc] (rewrite-clj.custom-zipper.core/prev zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.custom-zipper.core\n(defn rightmost*\n  \"Raw version of [[rightmost]].\n\nReturns zipper with location at the rightmost sibling of the current node in `zloc`, or self.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.\"\n  [zloc] (rewrite-clj.custom-zipper.core/rightmost zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.custom-zipper.core\n(defn leftmost*\n  \"Raw version of [[leftmost]].\n\nReturns zipper with location at the leftmost sibling of the current node in `zloc`, or self.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.\"\n  [zloc] (rewrite-clj.custom-zipper.core/leftmost zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.custom-zipper.core\n(defn replace*\n  \"Raw version of [[replace]].\n\nReturns zipper with `node` replacing current node in `zloc`, without moving location.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.\"\n  [zloc node] (rewrite-clj.custom-zipper.core/replace zloc node))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.custom-zipper.core\n(defn edit*\n  \"Raw version of [[edit]].\n\nReturns zipper with value of `(apply f current-node args)` replacing current node in `zloc`.\n   \n   The result of `f` should be a rewrite-clj node.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.\"\n  [zloc f & args] (apply rewrite-clj.custom-zipper.core/edit zloc f args))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.custom-zipper.core\n(defn remove*\n  \"Raw version of [[remove]].\n\nReturns zipper with current node in `zloc` removed, with location at node that would have preceded\n  it in a depth-first walk.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.\"\n  [zloc] (rewrite-clj.custom-zipper.core/remove zloc))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.custom-zipper.core\n(defn insert-left*\n  \"Raw version of [[insert-left]].\n\nReturns zipper with `item` inserted as the left sibling of current node in `zloc`,\n without moving location.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.\"\n  [zloc item] (rewrite-clj.custom-zipper.core/insert-left zloc item))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.custom-zipper.core\n(defn insert-right*\n  \"Raw version of [[insert-right]].\n\nReturns zipper with `item` inserted as the right sibling of the current node in `zloc`,\n  without moving location.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.\"\n  [zloc item] (rewrite-clj.custom-zipper.core/insert-right zloc item))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.custom-zipper.core\n(defn insert-child*\n  \"Raw version of [[insert-child]].\n\nReturns zipper with `item` inserted as the leftmost child of the current node in `zloc`,\n  without moving location.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.\"\n  [zloc item] (rewrite-clj.custom-zipper.core/insert-child zloc item))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.custom-zipper.core\n(defn append-child*\n  \"Raw version of [[append-child]].\n\nReturns zipper with `item` inserted as the rightmost child of the current node in `zloc`,\n  without moving.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.\"\n  [zloc item] (rewrite-clj.custom-zipper.core/append-child zloc item))\n","~:reader-features",["^U",["~:cljs"]],"~:cljc",true,"~:source-map-compact",["^ ","mappings","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","names",["rewrite-clj.zip/node","zloc","rewrite-clj.custom-zipper.core/node","rewrite-clj.zip/position","rewrite-clj.custom-zipper.core/position","rewrite-clj.zip/position-span","rewrite-clj.custom-zipper.core/position-span","rewrite-clj.zip/root","rewrite-clj.custom-zipper.core/root","rewrite-clj.zip/child-sexprs","rewrite-clj.zip.base/child-sexprs","var_args","G__41263","rewrite-clj.zip/edn*","js/Error","node","rewrite_clj.zip.base.edn_STAR_","opts","G__41269","rewrite-clj.zip/edn","rewrite_clj.zip.base.edn","rewrite-clj.zip/tag","rewrite-clj.zip.base/tag","rewrite-clj.zip/sexpr","rewrite-clj.zip.base/sexpr","rewrite-clj.zip/sexpr-able?","rewrite-clj.zip.base/sexpr-able?","rewrite-clj.zip/length","rewrite-clj.zip.base/length","rewrite-clj.zip/value","rewrite-clj.zip.base/value","G__41273","rewrite-clj.zip/of-string","s","rewrite_clj.zip.base.of_string","rewrite-clj.zip/string","rewrite-clj.zip.base/string","rewrite-clj.zip/->string","rewrite-clj.zip.base/->string","rewrite-clj.zip/root-string","rewrite-clj.zip.base/root-string","rewrite-clj.zip/->root-string","rewrite-clj.zip.base/->root-string","G__41277","rewrite-clj.zip/print","writer","rewrite_clj.zip.base.print","G__41279","rewrite-clj.zip/print-root","rewrite_clj.zip.base.print_root","rewrite-clj.zip/replace","value","rewrite-clj.zip.editz/replace","args__5775__auto__","len__5769__auto__","i__5770__auto__","argseq__5776__auto__","cljs.core/IndexedSeq","rewrite-clj.zip/edit","seq41282","G__41283","cljs.core/first","cljs.core/next","G__41284","self__5754__auto__","f","args","cljs.core.apply","rewrite-clj.zip.editz/edit","rewrite-clj.zip/splice","rewrite-clj.zip.editz/splice","rewrite-clj.zip/prefix","rewrite-clj.zip.editz/prefix","rewrite-clj.zip/suffix","rewrite-clj.zip.editz/suffix","rewrite-clj.zip/reapply-context","rewrite-clj.zip.context/reapply-context","G__41293","rewrite-clj.zip/find","p?","rewrite_clj.zip.findz.find","G__41307","rewrite-clj.zip/find-next","rewrite_clj.zip.findz.find_next","rewrite-clj.zip/find-depth-first","rewrite-clj.zip.findz/find-depth-first","rewrite-clj.zip/find-next-depth-first","rewrite-clj.zip.findz/find-next-depth-first","G__41315","rewrite-clj.zip/find-tag","t","rewrite_clj.zip.findz.find_tag","G__41320","rewrite-clj.zip/find-next-tag","rewrite_clj.zip.findz.find_next_tag","G__41323","rewrite-clj.zip/find-value","v","rewrite_clj.zip.findz.find_value","G__41327","rewrite-clj.zip/find-next-value","rewrite_clj.zip.findz.find_next_value","G__41333","rewrite-clj.zip/find-token","rewrite_clj.zip.findz.find_token","G__41338","rewrite-clj.zip/find-next-token","rewrite_clj.zip.findz.find_next_token","G__41343","rewrite-clj.zip/find-last-by-pos","pos","rewrite_clj.zip.findz.find_last_by_pos","rewrite-clj.zip/find-tag-by-pos","rewrite-clj.zip.findz/find-tag-by-pos","rewrite-clj.zip/insert-right","item","rewrite-clj.zip.insert/insert-right","rewrite-clj.zip/insert-left","rewrite-clj.zip.insert/insert-left","rewrite-clj.zip/insert-child","rewrite-clj.zip.insert/insert-child","rewrite-clj.zip/append-child","rewrite-clj.zip.insert/append-child","rewrite-clj.zip/left","rewrite-clj.zip.move/left","rewrite-clj.zip/right","rewrite-clj.zip.move/right","rewrite-clj.zip/up","rewrite-clj.zip.move/up","rewrite-clj.zip/down","rewrite-clj.zip.move/down","rewrite-clj.zip/prev","rewrite-clj.zip.move/prev","rewrite-clj.zip/next","rewrite-clj.zip.move/next","rewrite-clj.zip/leftmost","rewrite-clj.zip.move/leftmost","rewrite-clj.zip/rightmost","rewrite-clj.zip.move/rightmost","rewrite-clj.zip/leftmost?","rewrite-clj.zip.move/leftmost?","rewrite-clj.zip/rightmost?","rewrite-clj.zip.move/rightmost?","rewrite-clj.zip/end?","rewrite-clj.zip.move/end?","rewrite-clj.zip/remove","rewrite-clj.zip.removez/remove","rewrite-clj.zip/remove-preserve-newline","rewrite-clj.zip.removez/remove-preserve-newline","rewrite-clj.zip/seq?","rewrite-clj.zip.seqz/seq?","rewrite-clj.zip/list?","rewrite-clj.zip.seqz/list?","rewrite-clj.zip/vector?","rewrite-clj.zip.seqz/vector?","rewrite-clj.zip/set?","rewrite-clj.zip.seqz/set?","rewrite-clj.zip/map?","rewrite-clj.zip.seqz/map?","rewrite-clj.zip/namespaced-map?","rewrite-clj.zip.seqz/namespaced-map?","rewrite-clj.zip/map","rewrite-clj.zip.seqz/map","rewrite-clj.zip/map-keys","rewrite-clj.zip.seqz/map-keys","rewrite-clj.zip/map-vals","rewrite-clj.zip.seqz/map-vals","rewrite-clj.zip/get","k","rewrite-clj.zip.seqz/get","rewrite-clj.zip/assoc","rewrite-clj.zip.seqz/assoc","rewrite-clj.zip/edit-node","rewrite-clj.zip.subedit/edit-node","rewrite-clj.zip/subedit-node","rewrite-clj.zip.subedit/subedit-node","rewrite-clj.zip/subzip","rewrite-clj.zip.subedit/subzip","G__41370","rewrite-clj.zip/prewalk","rewrite_clj.zip.walk.prewalk","G__41380","rewrite-clj.zip/postwalk","rewrite_clj.zip.walk.postwalk","rewrite-clj.zip/whitespace?","rewrite-clj.zip.whitespace/whitespace?","rewrite-clj.zip/linebreak?","rewrite-clj.zip.whitespace/linebreak?","rewrite-clj.zip/whitespace-or-comment?","rewrite-clj.zip.whitespace/whitespace-or-comment?","rewrite-clj.zip/skip","rewrite-clj.zip.whitespace/skip","G__41385","rewrite-clj.zip/skip-whitespace","rewrite_clj.zip.whitespace.skip_whitespace","rewrite-clj.zip/skip-whitespace-left","rewrite-clj.zip.whitespace/skip-whitespace-left","G__41390","rewrite-clj.zip/insert-space-left","rewrite_clj.zip.whitespace.insert_space_left","n","G__41397","rewrite-clj.zip/insert-space-right","rewrite_clj.zip.whitespace.insert_space_right","G__41399","rewrite-clj.zip/insert-newline-left","rewrite_clj.zip.whitespace.insert_newline_left","G__41401","rewrite-clj.zip/insert-newline-right","rewrite_clj.zip.whitespace.insert_newline_right","G__41406","rewrite-clj.zip/prepend-space","rewrite_clj.zip.whitespace.prepend_space","G__41408","rewrite-clj.zip/append-space","rewrite_clj.zip.whitespace.append_space","G__41410","rewrite-clj.zip/prepend-newline","rewrite_clj.zip.whitespace.prepend_newline","G__41414","rewrite-clj.zip/append-newline","rewrite_clj.zip.whitespace.append_newline","rewrite-clj.zip/right*","rewrite-clj.custom-zipper.core/right","rewrite-clj.zip/left*","rewrite-clj.custom-zipper.core/left","rewrite-clj.zip/up*","rewrite-clj.custom-zipper.core/up","rewrite-clj.zip/down*","rewrite-clj.custom-zipper.core/down","rewrite-clj.zip/next*","rewrite-clj.custom-zipper.core/next","rewrite-clj.zip/prev*","rewrite-clj.custom-zipper.core/prev","rewrite-clj.zip/rightmost*","rewrite-clj.custom-zipper.core/rightmost","rewrite-clj.zip/leftmost*","rewrite-clj.custom-zipper.core/leftmost","rewrite-clj.zip/replace*","rewrite-clj.custom-zipper.core/replace","rewrite-clj.zip/edit*","seq41421","G__41422","G__41423","rewrite-clj.custom-zipper.core/edit","rewrite-clj.zip/remove*","rewrite-clj.custom-zipper.core/remove","rewrite-clj.zip/insert-left*","rewrite-clj.custom-zipper.core/insert-left","rewrite-clj.zip/insert-right*","rewrite-clj.custom-zipper.core/insert-right","rewrite-clj.zip/insert-child*","rewrite-clj.custom-zipper.core/insert-child","rewrite-clj.zip/append-child*","rewrite-clj.custom-zipper.core/append-child"]],"~:used-vars",["^U",["~$rewrite-clj.custom-zipper.core/insert-left","~$rewrite-clj.zip.whitespace/prepend-space","~$rewrite-clj.zip.base/->string","~$rewrite-clj.zip.seqz/map?","~$rewrite-clj.custom-zipper.core/prev","~$rewrite-clj.zip/prepend-newline","~$rewrite-clj.zip/find-next-tag","~$rewrite-clj.zip/up","~$rewrite-clj.zip.base/of-string","~$rewrite-clj.zip/edit*","~$rewrite-clj.zip.base/print-root","~$rewrite-clj.zip.findz/find","~$rewrite-clj.zip.findz/find-next-token","~$rewrite-clj.zip/whitespace-or-comment?","~$rewrite-clj.custom-zipper.core/rightmost","~$rewrite-clj.zip/print","~$rewrite-clj.zip.subedit/subzip","~$rewrite-clj.zip/find-tag-by-pos","~$rewrite-clj.zip/left*","~$rewrite-clj.zip.whitespace/append-newline","~$rewrite-clj.zip.whitespace/insert-newline-right","~$rewrite-clj.custom-zipper.core/right","~$rewrite-clj.zip.walk/postwalk","~$rewrite-clj.zip/up*","~$rewrite-clj.zip/append-newline","~$rewrite-clj.zip.move/leftmost?","~$rewrite-clj.zip/skip-whitespace","~$rewrite-clj.zip/root-string","~$rewrite-clj.zip/find-next-depth-first","~$rewrite-clj.zip/find-next","~$rewrite-clj.custom-zipper.core/root","~$rewrite-clj.zip/find-value","~$rewrite-clj.zip/sexpr","~$rewrite-clj.zip.whitespace/prepend-newline","~$rewrite-clj.zip/find-tag","~$rewrite-clj.zip/value","~$rewrite-clj.zip/map?","~$rewrite-clj.zip/prewalk","~$rewrite-clj.zip/down*","~$cljs.core/IndexedSeq","~$rewrite-clj.zip/down","~$rewrite-clj.zip.whitespace/append-space","~$rewrite-clj.zip/edit-node","~$rewrite-clj.zip/string","~$rewrite-clj.zip/node","~$rewrite-clj.zip.move/next","~$rewrite-clj.zip.move/rightmost?","~$rewrite-clj.zip/prepend-space","~$rewrite-clj.zip.whitespace/whitespace-or-comment?","~$rewrite-clj.zip/subzip","~$rewrite-clj.zip.base/->root-string","~$rewrite-clj.zip/replace*","~$rewrite-clj.zip/position-span","~$cljs.core/apply","~$rewrite-clj.zip/namespaced-map?","~$rewrite-clj.zip/edn*","~$rewrite-clj.zip.whitespace/insert-space-left","~$rewrite-clj.zip/position","~$rewrite-clj.zip/insert-child","~$rewrite-clj.zip/find-last-by-pos","~$rewrite-clj.zip.move/rightmost","~$rewrite-clj.zip.findz/find-token","~$rewrite-clj.zip.base/string","~$rewrite-clj.zip.editz/prefix","~$rewrite-clj.zip/append-child*","~$rewrite-clj.zip.move/prev","~$rewrite-clj.zip.base/length","~$rewrite-clj.zip.insert/insert-child","~$rewrite-clj.zip.whitespace/whitespace?","~$rewrite-clj.zip.subedit/subedit-node","~$rewrite-clj.zip/of-string","~$rewrite-clj.zip/insert-right*","~$rewrite-clj.zip/append-child","~$rewrite-clj.zip.findz/find-value","~$rewrite-clj.custom-zipper.core/remove","~$rewrite-clj.zip.findz/find-tag","~$rewrite-clj.zip/leftmost","~$rewrite-clj.zip/insert-space-right","~$rewrite-clj.zip.move/right","~$rewrite-clj.zip.subedit/edit-node","~$rewrite-clj.zip/insert-right","~$rewrite-clj.zip/prev*","~$rewrite-clj.custom-zipper.core/left","~$rewrite-clj.zip.whitespace/insert-newline-left","~$rewrite-clj.zip.context/reapply-context","~$rewrite-clj.zip/remove*","~$rewrite-clj.zip.seqz/map-keys","~$rewrite-clj.zip.insert/insert-right","~$rewrite-clj.zip.whitespace/skip-whitespace-left","~$rewrite-clj.zip.insert/append-child","~$rewrite-clj.zip/prefix","~$rewrite-clj.zip/reapply-context","~$rewrite-clj.zip.findz/find-next-tag","~$rewrite-clj.zip.seqz/map-vals","~$rewrite-clj.zip.base/value","~$rewrite-clj.zip.editz/edit","~$rewrite-clj.zip/skip-whitespace-left","~$rewrite-clj.zip.base/sexpr","~$rewrite-clj.zip/leftmost?","~$rewrite-clj.zip.findz/find-depth-first","~$rewrite-clj.zip.seqz/list?","~$rewrite-clj.zip/edit","~$rewrite-clj.zip/list?","~$rewrite-clj.custom-zipper.core/replace","~$rewrite-clj.zip.whitespace/skip","~$rewrite-clj.zip/insert-newline-right","~$rewrite-clj.zip.base/edn*","~$rewrite-clj.zip/find-next-value","~$rewrite-clj.zip/map-keys","~$rewrite-clj.zip/edn","~$rewrite-clj.zip/next","~$rewrite-clj.zip/next*","~$rewrite-clj.zip.whitespace/insert-space-right","~$rewrite-clj.zip/map-vals","~$rewrite-clj.zip/insert-child*","~$rewrite-clj.zip/prev","~$rewrite-clj.zip.base/edn","~$rewrite-clj.zip.findz/find-next-depth-first","~$rewrite-clj.zip.findz/find-tag-by-pos","~$rewrite-clj.zip/length","~$rewrite-clj.zip/insert-left","~$rewrite-clj.zip/right*","~$rewrite-clj.zip/assoc","~$rewrite-clj.custom-zipper.core/up","~$rewrite-clj.zip.insert/insert-left","~$rewrite-clj.zip.base/sexpr-able?","~$rewrite-clj.zip.removez/remove","~$rewrite-clj.zip.seqz/assoc","~$rewrite-clj.zip.move/left","~$rewrite-clj.zip.seqz/set?","~$rewrite-clj.zip.move/end?","~$rewrite-clj.zip/rightmost","~$rewrite-clj.zip.seqz/map","~$rewrite-clj.zip.move/leftmost","~$rewrite-clj.zip/insert-space-left","~$rewrite-clj.zip/linebreak?","~$rewrite-clj.zip/tag","~$rewrite-clj.zip/insert-left*","~$rewrite-clj.zip/right","~$rewrite-clj.zip/leftmost*","~$rewrite-clj.zip/child-sexprs","~$rewrite-clj.zip/seq?","~$rewrite-clj.zip.base/child-sexprs","~$rewrite-clj.zip.seqz/get","~$rewrite-clj.zip/whitespace?","~$rewrite-clj.zip.base/tag","~$rewrite-clj.zip/find","~$rewrite-clj.zip.walk/prewalk","~$rewrite-clj.zip/postwalk","~$rewrite-clj.zip/skip","~$rewrite-clj.zip/root","~$rewrite-clj.custom-zipper.core/node","~$rewrite-clj.zip/subedit-node","~$rewrite-clj.zip/remove-preserve-newline","~$rewrite-clj.zip.findz/find-next","~$rewrite-clj.zip/insert-newline-left","~$rewrite-clj.custom-zipper.core/down","~$rewrite-clj.custom-zipper.core/position-span","~$rewrite-clj.zip/map","~$cljs.core/next","~$rewrite-clj.zip.seqz/seq?","~$rewrite-clj.zip.seqz/namespaced-map?","~$rewrite-clj.zip/print-root","~$rewrite-clj.custom-zipper.core/insert-child","~$rewrite-clj.custom-zipper.core/position","~$rewrite-clj.zip.editz/replace","~$rewrite-clj.zip.seqz/vector?","~$rewrite-clj.zip/rightmost*","~$rewrite-clj.zip/end?","~$rewrite-clj.zip/get","~$rewrite-clj.zip/->string","~$rewrite-clj.zip/append-space","~$rewrite-clj.zip/sexpr-able?","~$rewrite-clj.zip.editz/splice","~$rewrite-clj.zip.base/print","~$rewrite-clj.zip.move/up","~$rewrite-clj.zip/remove","~$rewrite-clj.zip/find-depth-first","~$rewrite-clj.zip/find-token","~$rewrite-clj.custom-zipper.core/insert-right","~$rewrite-clj.custom-zipper.core/append-child","~$rewrite-clj.custom-zipper.core/leftmost","~$rewrite-clj.zip/left","~$rewrite-clj.zip.findz/find-last-by-pos","~$rewrite-clj.zip/splice","~$rewrite-clj.zip.whitespace/linebreak?","~$rewrite-clj.zip/vector?","~$cljs.core/first","~$rewrite-clj.zip/set?","~$rewrite-clj.zip/suffix","~$rewrite-clj.zip.move/down","~$rewrite-clj.zip.findz/find-next-value","~$rewrite-clj.zip.base/root-string","~$js/Error","~$rewrite-clj.zip/->root-string","~$rewrite-clj.custom-zipper.core/edit","~$rewrite-clj.zip.removez/remove-preserve-newline","~$rewrite-clj.zip/find-next-token","~$rewrite-clj.zip/replace","~$rewrite-clj.zip.editz/suffix","~$rewrite-clj.zip/rightmost?","~$rewrite-clj.zip.whitespace/skip-whitespace","~$rewrite-clj.custom-zipper.core/next"]]],"~:cache-keys",["~#cmap",[["^2<","rewrite_clj/zip/options.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","~:shadow.build.compiler/resolve",["^ ","~:require-id",null,"~:deps-ids",["^U",[]],"~:deps-syms",["^1Q","^1P","~$rewrite-clj.node.protocols"]]],["^2<","goog/dom/tagname.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","~$goog.dom.HtmlElement"]]],["^2<","rewrite_clj/zip/walk.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","^1T","^1M"]]],["^2<","cljs/tools/reader/impl/utils.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","~$clojure.string","~$goog.string"]]],["^2<","rewrite_clj/node/reader_macro.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","^7=","~$rewrite-clj.node.whitespace"]]],["^2<","rewrite_clj/parser.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","~$rewrite-clj.node.forms","~$rewrite-clj.parser.core","~$rewrite-clj.reader"]]],["^2<","goog/html/trustedtypes.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q"]]],["^2<","goog/string/stringformat.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^7@"]]],["^2<","goog/labs/useragent/browser.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","~$goog.array","~$goog.object","~$goog.labs.userAgent.util","~$goog.string.internal"]]],["^2<","goog/html/safeurl.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","~$goog.asserts","~$goog.fs.url","~$goog.html.TrustedResourceUrl","~$goog.i18n.bidi.Dir","~$goog.i18n.bidi.DirectionalString","~$goog.string.Const","~$goog.string.TypedString","^7H"]]],["^2<","goog/array/array.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^7I"]]],["^2<","rewrite_clj/parser/whitespace.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","^7A","^7D"]]],["^2<","rewrite_clj/node/regex.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","^7="]]],["^2<","goog/debug/error.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q"]]],["^2<","cljs/tools/reader/edn.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","^F","^J","^@","^D","~$cljs.tools.reader","^7@","~$goog.string.StringBuffer"]]],["^2<","goog/dom/nodetype.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q"]]],["^2<","cljs/tools/reader/impl/inspect.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P"]]],["^2<","cljs/tools/reader.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","^J","^@","^D","^F","^7E","^7@","^7Q"]]],["^2<","rewrite_clj/zip/base.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","^1O","^7B","^7=","~$rewrite-clj.parser","~$rewrite-clj.zip.options","^1S"]]],["^2<","rewrite_clj/zip/editz.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","^1O","~$rewrite-clj.custom-zipper.utils","^7=","~$rewrite-clj.node.token","^7A","^1Y","^7S","^1L","^1S"]]],["^2<","rewrite_clj/parser/token.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","^7U","^7D"]]],["^2<","rewrite_clj/node/uneval.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","^7="]]],["^2<","goog/string/typedstring.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q"]]],["^2<","rewrite_clj/parser/keyword.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","~$rewrite-clj.node.keyword","^7D"]]],["^2<","rewrite_clj/zip/seqz.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","^1O","^1Y","^1U","^1N","^1R","^1T"]]],["^2<","goog/object/object.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q"]]],["^2<","goog/dom/asserts.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^7I"]]],"~:SHADOW-TIMESTAMP",[1666857604000,1666857604000,1666857293000],["^2<","rewrite_clj/node/keyword.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","^7="]]],["^2<","rewrite_clj/node/token.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","^7="]]],["^2<","goog/math/long.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^7I","~$goog.reflect"]]],["^2<","goog/html/trustedresourceurl.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^7I","~$goog.fs.blob","^7J","~$goog.html.SafeScript","~$goog.html.trustedtypes","^7L","^7M","^7N","^7O"]]],["^2<","rewrite_clj/node/comment.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","^7="]]],["^2<","rewrite_clj/zip/subedit.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","^1O","^1Y","^7S"]]],["^2<","goog/string/internal.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q"]]],["^2<","goog/functions/functions.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q"]]],["^2<","rewrite_clj/parser/string.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","^7?","~$rewrite-clj.node.stringz","^7D","^7Q"]]],["^2<","goog/html/safestyle.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^7N","~$goog.html.SafeUrl","^7O","^7I","^7H"]]],["^2<","goog/dom/safe.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^7I","~$goog.dom.asserts","~$goog.functions","~$goog.html.SafeHtml","^7Z","~$goog.html.SafeStyle","^81","^7K","~$goog.html.uncheckedconversions","^7N","^7H"]]],["^2<","rewrite_clj/zip/removez.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","^1O","^7T","^1T","^1S"]]],["^2<","clojure/walk.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P"]]],["^2<","goog/html/safehtml.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^7N","^7L","^7M","^7Z","^85","~$goog.html.SafeStyleSheet","^81","~$goog.dom.TagName","^7K","^7O","^7I","~$goog.labs.userAgent.browser","^7E","^7F","^7H","~$goog.dom.tags","^7["]]],["^2<","rewrite_clj/node/forms.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","^7="]]],["^2<","goog/dom/tags.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^7F"]]],["^2<","rewrite_clj/node/integer.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","~$rewrite-clj.interop","^7="]]],["^2<","rewrite_clj/parser/core.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","~$rewrite-clj.node.comment","~$rewrite-clj.node.fn","~$rewrite-clj.node.meta","^7=","~$rewrite-clj.node.quote","~$rewrite-clj.node.reader-macro","~$rewrite-clj.node.regex","~$rewrite-clj.node.seq","^7U","~$rewrite-clj.node.uneval","~$rewrite-clj.parser.keyword","~$rewrite-clj.parser.namespaced-map","~$rewrite-clj.parser.string","~$rewrite-clj.parser.token","~$rewrite-clj.parser.whitespace","^7D"]]],["^2<","rewrite_clj/node/fn.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","^7?","~$clojure.walk","^8;","^7="]]],["^2<","goog/fs/blob.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q"]]],["^2<","rewrite_clj/node/protocols.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","^7?","^8;"]]],["^2<","goog/asserts/asserts.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","~$goog.debug.Error","~$goog.dom.NodeType"]]],["^2<","rewrite_clj/zip/whitespace.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","^1O","^8<","~$rewrite-clj.node.extras","^7A"]]],["^2<","goog/uri/uri.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^7E","^7I","~$goog.collections.maps","^7@","~$goog.structs","~$goog.uri.utils","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"]]],["^2<","rewrite_clj/node/meta.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","^8;","^7=","^7A"]]],["^2<","rewrite_clj/node/stringz.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","^7?","^L","^7="]]],["^2<","rewrite_clj/parser/namespaced_map.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","~$rewrite-clj.node.namespaced-map","^7=","^7A","^7D"]]],["^2<","goog/collections/maps.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q"]]],["^2<","rewrite_clj/node/whitespace.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","^7=","^7D"]]],["^2<","goog/i18n/bidi.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q"]]],["^2<","rewrite_clj/zip/move.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","^1O","^1S"]]],["^2<","goog/fs/url.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q"]]],["^2<","rewrite_clj/node/quote.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","^7="]]],["^2<","goog/base.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",[]]],["^2<","goog/structs/structs.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^7E","^7F"]]],["^2<","cljs/tools/reader/impl/errors.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","^J","^7?","~$cljs.tools.reader.impl.inspect"]]],["^2<","rewrite_clj/zip/context.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","^1O","^7=","^1X","^1W"]]],["^2<","clojure/string.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","^7@","^7Q"]]],["^2<","rewrite_clj/zip/findz.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","^1O","^1Y","^1T"]]],["^2<","rewrite_clj/zip.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","^1O","^1Z","^1Y","^1V","^1U","^1N","^1R","^1T","^1L","^1X","^1M","^1W","^1S"]]],["^2<","rewrite_clj/zip/insert.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","^1O","^7=","^7A","^1S"]]],["^2<","rewrite_clj/node/namespaced_map.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","^7="]]],["^2<","goog/string/string.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","~$goog.dom.safe","^86","^7N","^7H"]]],["^2<","rewrite_clj/custom_zipper/core.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","~$clojure.zip","~$rewrite-clj.custom-zipper.switchable","^7="]]],["^2<","goog/reflect/reflect.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q"]]],["^2<","goog/labs/useragent/util.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","~$goog.labs.userAgent","^7H"]]],["^2<","clojure/zip.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P"]]],["^2<","goog/string/stringbuffer.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q"]]],["^2<","cljs/tools/reader/reader_types.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","^@","^7@","^7Q"]]],["^2<","rewrite_clj/reader.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","^L","^D","^F","^@","^J","^8;","^7Q"]]],["^2<","goog/labs/useragent/useragent.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q"]]],["^2<","rewrite_clj/custom_zipper/utils.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","^1O"]]],["^2<","rewrite_clj/node/coercer.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","^7?","^8<","^8=","^7B","~$rewrite-clj.node.integer","^7V","^8>","^8R","^7=","^8?","^8@","^8A","^8B","^80","^7U","^8C","^7A"]]],["^2<","goog/html/uncheckedconversions.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^7I","^84","^7Z","^85","^87","^81","^7K","^7N","^7H","^7L"]]],["^2<","cljs/tools/reader/impl/commons.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","^F","^J","^@"]]],["^2<","goog/dom/htmlelement.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q"]]],["^2<","cljs/core.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","~$goog.math.Long","~$goog.math.Integer","^7@","^7F","^7E","~$goog.Uri","^7Q"]]],["^2<","rewrite_clj/custom_zipper/switchable.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P"]]],["^2<","goog/html/safescript.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^7N","^7O","^7[","^7I"]]],["^2<","rewrite_clj/node/extras.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","^8<","^7A"]]],["^2<","goog/html/safestylesheet.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^7N","^85","^7O","^7F","^7I","^7H"]]],["^2<","goog/math/integer.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^7X"]]],["^2<","goog/uri/utils.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^7I","^7@"]]],["^2<","goog/string/const.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^7I","^7O"]]],["^2<","rewrite_clj/interop.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","^7@","~$goog.string.format"]]],["^2<","rewrite_clj/node/seq.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^79",["^ ","^7:",null,"^7;",["^U",[]],"^7<",["^1Q","^1P","^8;","^7="]]]]],"~:clj-info",["^ ","jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/string.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/impl/errors.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/env.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/default_data_readers.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/core.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/edn.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/reader.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/reader_types.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/util.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/compiler.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/impl/inspect.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/edn.clj",1666857280000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/passes/and_or.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/pprint.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map/base64_vlq.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/set.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/reader_types.clj",1666857280000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/node/protocols.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/instant.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map/base64.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/interop.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/impl/utils.clj",1666857280000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/custom_zipper/core.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/externs.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/zip.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/impl/commons.clj",1666857280000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/js_deps.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/binaryage/devtools/1.0.6/devtools-1.0.6.jar!/devtools/defaults.clj",1666857314000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/java/io.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/impl/inspect.clj",1666857280000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/node/comment.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/parser.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/node/whitespace.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/zip/whitespace.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/impl.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/custom_zipper/switchable.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/node/forms.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/tagged_literals.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/core.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/zip/subedit.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/parser/core.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/passes.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/node/extras.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/data/json.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/zip/options.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/instant.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/impl/namespaces.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/zip.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/zip/base.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/impl/errors.clj",1666857280000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/cljs/tools/reader/reader_types.clj",1666857280000],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","A rich API for navigating and updating Clojure/ClojureScripti/EDN source code via a zipper tree.\n\n  The zipper holds a tree of nodes representing source code. It also holds your current location while navigating\n  through the tree and any pending changes you have made. Changes are applied back into the tree\n  when invoking root functions.\n\n  Although they are preserved, whitespace and comment nodes are normally skipped when navigating through the tree.\n  There are times when you will want to include whitespace and comment nodes, and as you see below, provisions are\n  available to do so.\n\n  It is good to remember that while some function names convey mutation, we are never changing anything, we are\n  instead returning modified copies.\n\n  Some conventions in the code and docstrings:\n  - `zloc` is the used as the argument name for our zipper\n  - \"current node in `zloc`\" is shorthand for: node at current location in zipper `zloc`\n\n  Because this API contains many functions, we offer the following categorized listing:\n\n  **Create a zipper**\n  [[edn]]\n  [[edn*]]\n  [[of-string]]\n  [[of-file]]\n\n  **Move**\n  [[left]]\n  [[right]]\n  [[up]]\n  [[down]]\n  [[prev]]\n  [[next]]\n  [[leftmost]]\n  [[rightmost]]\n\n  **Move without skipping whitespace and comments**\n  [[left*]]\n  [[right*]]\n  [[up*]]\n  [[down*]]\n  [[prev*]]\n  [[next*]]\n  [[leftmost*]]\n  [[rightmost*]]\n\n  **Whitespace/comment aware skip**\n  [[skip]]\n  [[skip-whitespace]]\n  [[skip-whitespace-left]]\n\n  **Test for whitespace**\n  [[whitespace?]]\n  [[linebreak?]]\n  [[whitespace-or-comment?]]\n\n  **Test location**\n  [[leftmost?]]\n  [[rightmost?]]\n  [[end?]]\n\n  **Test data type**\n  [[seq?]]\n  [[list?]]\n  [[vector?]]\n  [[set?]]\n  [[map?]]\n  [[namespaced-map?]]\n\n  **Find**\n  [[find]]\n  [[find-next]]\n  [[find-depth-first]]\n  [[find-next-depth-first]]\n  [[find-tag]]\n  [[find-next-tag]]\n  [[find-value]]\n  [[find-next-value]]\n  [[find-token]]\n  [[find-next-token]]\n  [[find-last-by-pos]]\n  [[find-tag-by-pos]]\n\n  **Inspect**\n  [[node]]\n  [[position]]\n  [[position-span]]\n  [[tag]]\n  [[length]]\n\n  **Convert**\n  [[sexpr-able?]]\n  [[sexpr]]\n  [[child-sexprs]]\n  [[reapply-context]]\n\n  **Update**\n  [[replace]]\n  [[edit]]\n  [[splice]]\n  [[prefix]]\n  [[suffix]]\n  [[insert-right]]\n  [[insert-left]]\n  [[insert-child]]\n  [[insert-space-left]]\n  [[insert-space-right]]\n  [[insert-newline-left]]\n  [[insert-newline-right]]\n  [[append-child]]\n  [[remove]]\n  [[remove-preserve-newline]]\n  [[root]]\n\n  **Update without whitespace treatment**\n  [[replace*]]\n  [[edit*]]\n  [[insert-left*]]\n  [[insert-right*]]\n  [[insert-child*]]\n  [[append-child*]]\n  [[remove*]]\n\n  **Update without changing location**\n  [[edit-node]]\n  [[edit->]]\n  [[edit->>]]\n\n  **Isolated update without changing location**\n  [[subedit-node]]\n  [[subzip]]\n  [[prewalk]]\n  [[postwalk]]\n  [[subedit->]]\n  [[subedit->>]]\n\n  **Sequence operations**\n  [[map]]\n  [[map-keys]]\n  [[map-vals]]\n  [[get]]\n  [[assoc]]\n\n  **Stringify**\n  [[string]]\n  [[root-string]]\n\n  **Output**\n  [[print]]\n  [[print-root]]","^7","rewrite_clj/zip.cljc","^8",2,"^9",5,"^:",2,"^;",20],"^<",["^ ","^=","^>","^?","^@","^A","^B","^C","^D","^E","^F","^G","^H","^I","^J","^K","^L","^M","^N","^O","^P","^Q","^R"],"^S",null,"^T",["^U",["^V","^W","^X","^Y","^Z","^[","^10","^11","^12","^13","~$next*","^14","^15","^16"]],"^17",["^ ","^18",["^ ","^19",["^1:",[["^1;","~$&","^1<"]]],"^6","Like `->`, threads `zloc`, as an isolated sub-tree through forms, then zips\n   up to, and locates at, the root of the modified sub-tree.\n   \n   See [docs on sub editing](/doc/01-user-guide.adoc#sub-editing).","^8",721,"^9",1,"^7","rewrite_clj/zip.cljc","^1=","^1>","^1?","^1@","^1A",true],"^1B",["^ ","^19",["^1:",[["^1;","~$&","^1<"]]],"^6","Like `->>`, threads `zloc` through forms.\n   The resulting zipper will be located at the same path (i.e. the same\n   number of downwards and right movements from the root) as incoming `zloc`.\n   \n   See also [[subedit->>]] for an isolated edit.","^8",712,"^9",1,"^7","rewrite_clj/zip.cljc","^1=","^1C","^1?","^1@","^1A",true],"^1D",["^ ","^19",["^1:",[["^1;","~$&","^1<"]]],"^6","Like `->`. Threads `zloc`, as an isolated sub-tree through forms, then zips\n      up to, and locates at, the root of the modified sub-tree.\n\n   See [docs on sub editing](/doc/01-user-guide.adoc#sub-editing).","^8",729,"^9",1,"^7","rewrite_clj/zip.cljc","^1=","^1E","^1?","^1@","^1A",true],"^1F",["^ ","^19",["^1:",[["^1;","~$&","^1<"]]],"^6","Like `->`, threads `zloc` through forms.\n   The resulting zipper will be located at the same path (i.e. the same\n   number of downwards and right movements from the root) as incoming `zloc`.\n   \n   See also [[subedit->]] for an isolated edit.","^8",703,"^9",1,"^7","rewrite_clj/zip.cljc","^1=","^1G","^1?","^1@","^1A",true]],"^1=","^1@","^1H",["^ "],"^1J",null,"^1K",["^ ","^1L","^1L","^1M","^1M","^1N","^1N","^1O","^1O","^1P","^1P","^1Q","^1Q","^1R","^1R","^1S","^1S","^1T","^1T","^1U","^1U","^1V","^1V","^1W","^1W","^1X","^1X","^1Y","^1Y","^1Z","^1Z"],"^1[",["^U",["^20","^21"]],"~:shadow/js-access-global",["^U",["Error"]],"^22",null,"~:defs",["^ ","~$child-sexprs",["^ ","~:protocol-inline",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",199,"^9",25,"^:",199,"^;",37,"~:added","0.4.4","^19",["^1:",["~$quote",["^1:",[["^1;"]]]]],"^6","Return s-expression (the Clojure forms) of children of current node in `zloc`.\n\n  See docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances)."],"^:B","0.4.4","^1=","^5P","^7","rewrite_clj/zip.cljc","^;",37,"~:method-params",["^1:",[["^1;"]]],"~:protocol-impl",null,"~:arglists-meta",["^1:",[null,null]],"^9",1,"~:variadic?",false,"^8",199,"~:ret-tag",["^U",["~$cljs.core/LazySeq","~$clj-nil"]],"^:",199,"~:max-fixed-arity",1,"~:fn-var",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Return s-expression (the Clojure forms) of children of current node in `zloc`.\n\n  See docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances)."],"~$tag",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",228,"^9",7,"^:",228,"^;",10,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Return tag of current node in `zloc`."],"^1=","^5L","^7","rewrite_clj/zip.cljc","^;",10,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",228,"^:H",["^U",["~$any","^:J"]],"^:",228,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Return tag of current node in `zloc`."],"~$insert-space-left",["^ ","^:A",null,"^5",["^ ","^:B","0.5.0","^7","rewrite_clj/zip.cljc","^;",42,"~:top-fn",["^ ","^:G",false,"~:fixed-arity",2,"^:K",2,"^:D",[["^1;"],["^1;","~$n"]],"^19",["^1:",[["^1;"],["^1;","~$n"]]],"^:F",["^1:",[null,null]]],"^9",25,"^8",858,"^:",858,"^19",["^1:",["^:C",["^1:",[["^1;"],["^1;","~$n"]]]]],"^6","Return zipper with `n` space whitespace node inserted to the left of the current node in `zloc`, without moving location.\n   `n` defaults to 1."],"^:B","0.5.0","^1=","^5J","^7","rewrite_clj/zip.cljc","^;",42,"^:P",["^ ","^:G",false,"^:Q",2,"^:K",2,"^:D",[["^1;"],["^1;","~$n"]],"^19",["^1:",[["^1;"],["^1;","~$n"]]],"^:F",["^1:",[null,null]]],"^:D",[["^1;"],["^1;","~$n"]],"^:E",null,"^:Q",2,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"~:methods",[["^ ","^:Q",1,"^:G",false,"~:tag","^:N"],["^ ","^:Q",2,"^:G",false,"^:S",["^U",[null,"~$clj","^:N","~$cljs.core/MetaFn","^:J"]]]],"^8",858,"^:",858,"^:K",2,"^:L",true,"^19",["^1:",[["^1;"],["^1;","~$n"]]],"^6","Return zipper with `n` space whitespace node inserted to the left of the current node in `zloc`, without moving location.\n   `n` defaults to 1."],"~$postwalk",["^ ","^:A",null,"^5",["^ ","^:B","0.4.9","^7","rewrite_clj/zip.cljc","^;",33,"^:P",["^ ","^:G",false,"^:Q",3,"^:K",3,"^:D",[["^1;","~$f"],["^1;","~$p?","~$f"]],"^19",["^1:",[["^1;","~$f"],["^1;","^:W","~$f"]]],"^:F",["^1:",[null,null]]],"^9",25,"^8",780,"^:",780,"^19",["^1:",["^:C",["^1:",[["^1;","~$f"],["^1;","^:W","~$f"]]]]],"^6","Return zipper modified by an isolated depth-first post-order traversal.\n\n   Pre-order traversal visits children before root.\n   For example, traversal order of `(1 (2 3 (4 5) 6 (7 8)) 9)` is:\n\n   1. `1`\n   2. `2`\n   3. `3`\n   4. `4`\n   5. `5`\n   6. `(4 5)`\n   7. `6`\n   8. `7`\n   9. `8`\n   10. `(7 8)`\n   11. `(2 3 (4 5) 6 (7 8))`\n   12. `9`\n   13. `(1 (2 3 (4 5) 6 (7 8)) 9)`\n\n   Traversal starts at the current node in `zloc` and continues to the end of the isolated sub-tree.\n\n   Function `f` is called on the zipper locations satisfying predicate `p?` and must return either\n   - nil to indicate no changes\n   - or a valid zipper\n   WARNING: when function `f` changes the location in the zipper, normal traversal will be affected.\n\n   When `p?` is not specified `f` is called on all locations.\n\n   Note that by default a newly created zipper automatically navigates to the first non-whitespace\n   node. If you want to be sure to walk all forms in a zipper, you'll want to navigate one up prior to your walk:\n\n   ```Clojure\n   (-> (zip/of-string \"my clojure forms\")\n       zip/up\n       (zip/postwalk ...))\n   ```\n\n   See [docs on sub editing](/doc/01-user-guide.adoc#sub-editing)."],"^:B","0.4.9","^1=","^5X","^7","rewrite_clj/zip.cljc","^;",33,"^:P",["^ ","^:G",false,"^:Q",3,"^:K",3,"^:D",[["^1;","~$f"],["^1;","^:W","~$f"]],"^19",["^1:",[["^1;","~$f"],["^1;","^:W","~$f"]]],"^:F",["^1:",[null,null]]],"^:D",[["^1;","~$f"],["^1;","^:W","~$f"]],"^:E",null,"^:Q",3,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^:R",[["^ ","^:Q",2,"^:G",false,"^:S","^:N"],["^ ","^:Q",3,"^:G",false,"^:S",["^U",["^:T","^:N","^:U","^:J"]]]],"^8",780,"^:",780,"^:K",3,"^:L",true,"^19",["^1:",[["^1;","~$f"],["^1;","^:W","~$f"]]],"^6","Return zipper modified by an isolated depth-first post-order traversal.\n\n   Pre-order traversal visits children before root.\n   For example, traversal order of `(1 (2 3 (4 5) 6 (7 8)) 9)` is:\n\n   1. `1`\n   2. `2`\n   3. `3`\n   4. `4`\n   5. `5`\n   6. `(4 5)`\n   7. `6`\n   8. `7`\n   9. `8`\n   10. `(7 8)`\n   11. `(2 3 (4 5) 6 (7 8))`\n   12. `9`\n   13. `(1 (2 3 (4 5) 6 (7 8)) 9)`\n\n   Traversal starts at the current node in `zloc` and continues to the end of the isolated sub-tree.\n\n   Function `f` is called on the zipper locations satisfying predicate `p?` and must return either\n   - nil to indicate no changes\n   - or a valid zipper\n   WARNING: when function `f` changes the location in the zipper, normal traversal will be affected.\n\n   When `p?` is not specified `f` is called on all locations.\n\n   Note that by default a newly created zipper automatically navigates to the first non-whitespace\n   node. If you want to be sure to walk all forms in a zipper, you'll want to navigate one up prior to your walk:\n\n   ```Clojure\n   (-> (zip/of-string \"my clojure forms\")\n       zip/up\n       (zip/postwalk ...))\n   ```\n\n   See [docs on sub editing](/doc/01-user-guide.adoc#sub-editing)."],"~$whitespace?",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",823,"^9",7,"^:",823,"^;",18,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Returns true when the current the node in `zloc` is a Clojure whitespace (which includes the comma)."],"^1=","^5T","^7","rewrite_clj/zip.cljc","^;",18,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",823,"^:H",["^U",["~$boolean","^:J"]],"^:",823,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Returns true when the current the node in `zloc` is a Clojure whitespace (which includes the comma)."],"^V",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",578,"^9",7,"^:",578,"^;",11,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Returns true if current node in `zloc` is a sequence."],"^1=","^5Q","^7","rewrite_clj/zip.cljc","^;",11,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",578,"^:H","^:Y","^:",578,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Returns true if current node in `zloc` is a sequence."],"~$insert-child*",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",1050,"^9",7,"^:",1050,"^;",20,"^19",["^1:",["^:C",["^1:",[["^1;","~$item"]]]]],"^6","Raw version of [[insert-child]].\n\nReturns zipper with `item` inserted as the leftmost child of the current node in `zloc`,\n  without moving location.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes."],"^1=","^56","^7","rewrite_clj/zip.cljc","^;",20,"^:D",["^1:",[["^1;","^:["]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",1050,"^:H",["^U",["^:T","^:N","^:U","^:J"]],"^:",1050,"^:K",2,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;","^:["]]]]],"^6","Raw version of [[insert-child]].\n\nReturns zipper with `item` inserted as the leftmost child of the current node in `zloc`,\n  without moving location.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes."],"^W",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",588,"^9",7,"^:",588,"^;",14,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Returns true if current node in `zloc` is a vector."],"^1=","^6R","^7","rewrite_clj/zip.cljc","^;",14,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",588,"^:H","^:Y","^:",588,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Returns true if current node in `zloc` is a vector."],"~$insert-newline-left",["^ ","^:A",null,"^5",["^ ","^:B","0.5.0","^7","rewrite_clj/zip.cljc","^;",44,"^:P",["^ ","^:G",false,"^:Q",2,"^:K",2,"^:D",[["^1;"],["^1;","~$n"]],"^19",["^1:",[["^1;"],["^1;","~$n"]]],"^:F",["^1:",[null,null]]],"^9",25,"^8",872,"^:",872,"^19",["^1:",["^:C",["^1:",[["^1;"],["^1;","~$n"]]]]],"^6","Return zipper with `n` newlines node inserted to the left of the current node in `zloc`, without moving location.\n   `n` defaults to 1."],"^:B","0.5.0","^1=","^63","^7","rewrite_clj/zip.cljc","^;",44,"^:P",["^ ","^:G",false,"^:Q",2,"^:K",2,"^:D",[["^1;"],["^1;","~$n"]],"^19",["^1:",[["^1;"],["^1;","~$n"]]],"^:F",["^1:",[null,null]]],"^:D",[["^1;"],["^1;","~$n"]],"^:E",null,"^:Q",2,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^:R",[["^ ","^:Q",1,"^:G",false,"^:S","^:N"],["^ ","^:Q",2,"^:G",false,"^:S",["^U",["^:T","^:N","^:U","^:J"]]]],"^8",872,"^:",872,"^:K",2,"^:L",true,"^19",["^1:",[["^1;"],["^1;","~$n"]]],"^6","Return zipper with `n` newlines node inserted to the left of the current node in `zloc`, without moving location.\n   `n` defaults to 1."],"~$right*",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",923,"^9",7,"^:",923,"^;",13,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Raw version of [[right]].\n\nReturns zipper with location at the right sibling of the current node in `zloc`, or nil.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes."],"^1=","^5=","^7","rewrite_clj/zip.cljc","^;",13,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",923,"^:H",["^U",["^:T","^:N","^:U","^:J"]],"^:",923,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Raw version of [[right]].\n\nReturns zipper with location at the right sibling of the current node in `zloc`, or nil.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes."],"~$insert-left*",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",1030,"^9",7,"^:",1030,"^;",19,"^19",["^1:",["^:C",["^1:",[["^1;","^:["]]]]],"^6","Raw version of [[insert-left]].\n\nReturns zipper with `item` inserted as the left sibling of current node in `zloc`,\n without moving location.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes."],"^1=","^5M","^7","rewrite_clj/zip.cljc","^;",19,"^:D",["^1:",[["^1;","^:["]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",1030,"^:H",["^U",["^:T","^:N","^:U","^:J"]],"^:",1030,"^:K",2,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;","^:["]]]]],"^6","Raw version of [[insert-left]].\n\nReturns zipper with `item` inserted as the left sibling of current node in `zloc`,\n without moving location.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes."],"^X",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",608,"^9",7,"^:",608,"^;",10,"^19",["^1:",["^:C",["^1:",[["~$f","^1;"]]]]],"^6","Returns `zloc` with function `f` applied to all nodes of the current node.\n  Current node must be a sequence node. Equivalent to [[rewrite-clj.zip/map-vals]] for maps.\n\n  `zloc` location is unchanged.\n\n  `f` arg is zloc positioned at\n  - value nodes for maps\n  - each element of a seq\n  and is should return:\n  - an updated zloc with zloc positioned at edited node\n  - a falsey value to leave value node unchanged\n\n  Folks typically use [[rewrite-clj.zip/edit]] for `f`."],"^1=","^66","^7","rewrite_clj/zip.cljc","^;",10,"^:D",["^1:",[["~$f","^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",608,"^:H",["^U",[null,"^:N","^:J"]],"^:",608,"^:K",2,"^:L",true,"^19",["^1:",["^:C",["^1:",[["~$f","^1;"]]]]],"^6","Returns `zloc` with function `f` applied to all nodes of the current node.\n  Current node must be a sequence node. Equivalent to [[rewrite-clj.zip/map-vals]] for maps.\n\n  `zloc` location is unchanged.\n\n  `f` arg is zloc positioned at\n  - value nodes for maps\n  - each element of a seq\n  and is should return:\n  - an updated zloc with zloc positioned at edited node\n  - a falsey value to leave value node unchanged\n\n  Folks typically use [[rewrite-clj.zip/edit]] for `f`."],"~$linebreak?",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",828,"^9",7,"^:",828,"^;",17,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Returns true when the current node in `zloc` is a linebreak."],"^1=","^5K","^7","rewrite_clj/zip.cljc","^;",17,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",828,"^:H",["^U",["^:Y","^:J"]],"^:",828,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Returns true when the current node in `zloc` is a linebreak."],"~$rightmost*",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",982,"^9",7,"^:",982,"^;",17,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Raw version of [[rightmost]].\n\nReturns zipper with location at the rightmost sibling of the current node in `zloc`, or self.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes."],"^1=","^6?","^7","rewrite_clj/zip.cljc","^;",17,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",982,"^:H",["^U",[null,"^:T","^:U","^:J"]],"^:",982,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Raw version of [[rightmost]].\n\nReturns zipper with location at the rightmost sibling of the current node in `zloc`, or self.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes."],"~$rightmost",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",527,"^9",7,"^:",527,"^;",16,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Return zipper with location moved to the rightmost non-whitespace/non-comment sibling of current node in `zloc`."],"^1=","^5G","^7","rewrite_clj/zip.cljc","^;",16,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",527,"^:H",["^U",["^:N","^:J"]],"^:",527,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Return zipper with location moved to the rightmost non-whitespace/non-comment sibling of current node in `zloc`."],"~$insert-child",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",480,"^9",7,"^:",480,"^;",19,"^19",["^1:",["^:C",["^1:",[["^1;","^:["]]]]],"^6","Return zipper with `item` inserted as the first child of the current node in `zloc`, without moving location."],"^1=","^3V","^7","rewrite_clj/zip.cljc","^;",19,"^:D",["^1:",[["^1;","^:["]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",480,"^:H",["^U",[null,"^:N"]],"^:",480,"^:K",2,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;","^:["]]]]],"^6","Return zipper with `item` inserted as the first child of the current node in `zloc`, without moving location."],"~$skip",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",838,"^9",7,"^:",838,"^;",11,"^19",["^1:",["^:C",["^1:",[["~$f","^:W","^1;"]]]]],"^6","Return zipper with location moved to first location not satisfying predicate `p?` starting from the node in\n   `zloc` and traversing by function `f`."],"^1=","^5Y","^7","rewrite_clj/zip.cljc","^;",11,"^:D",["^1:",[["~$f","^:W","^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",838,"^:H",["^U",["^:N","^:J"]],"^:",838,"^:K",3,"^:L",true,"^19",["^1:",["^:C",["^1:",[["~$f","^:W","^1;"]]]]],"^6","Return zipper with location moved to first location not satisfying predicate `p?` starting from the node in\n   `zloc` and traversing by function `f`."],"~$left",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",491,"^9",7,"^:",491,"^;",11,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Return zipper with location moved left to next non-whitespace/non-comment sibling of current node in `zloc`."],"^1=","^6N","^7","rewrite_clj/zip.cljc","^;",11,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",491,"^:H",["^U",["^:N","^:J"]],"^:",491,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Return zipper with location moved left to next non-whitespace/non-comment sibling of current node in `zloc`."],"~$leftmost",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",522,"^9",7,"^:",522,"^;",15,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Return zipper with location moved to the leftmost non-whitespace/non-comment sibling of current node in `zloc`."],"^1=","^4<","^7","rewrite_clj/zip.cljc","^;",15,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",522,"^:H",["^U",["^:N","^:J"]],"^:",522,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Return zipper with location moved to the leftmost non-whitespace/non-comment sibling of current node in `zloc`."],"^Y",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",361,"^9",7,"^:",361,"^;",11,"^19",["^1:",["^:C",["^1:",[["^1;","^:W"],["^1;","~$f","^:W"]]]]],"^6","Return `zloc` located to the first node satisfying predicate `p?` else nil.\n   Search starts at the current node and continues via movement function `f`.\n\n   `f` defaults to [[rewrite-clj.zip/right]]","^:P",["^ ","^:G",false,"^:Q",3,"^:K",3,"^:D",[["^1;","^:W"],["^1;","~$f","^:W"]],"^19",["^1:",[["^1;","^:W"],["^1;","~$f","^:W"]]],"^:F",["^1:",[null,null]]]],"^1=","^5V","^7","rewrite_clj/zip.cljc","^;",11,"^:P",["^ ","^:G",false,"^:Q",3,"^:K",3,"^:D",[["^1;","^:W"],["^1;","~$f","^:W"]],"^19",["^1:",[["^1;","^:W"],["^1;","~$f","^:W"]]],"^:F",["^1:",[null,null]]],"^:D",[["^1;","^:W"],["^1;","~$f","^:W"]],"^:E",null,"^:Q",3,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^:R",[["^ ","^:Q",2,"^:G",false,"^:S","^:N"],["^ ","^:Q",3,"^:G",false,"^:S",["^U",["^:N","^:J"]]]],"^8",361,"^:",361,"^:K",3,"^:L",true,"^19",["^1:",[["^1;","^:W"],["^1;","~$f","^:W"]]],"^6","Return `zloc` located to the first node satisfying predicate `p?` else nil.\n   Search starts at the current node and continues via movement function `f`.\n\n   `f` defaults to [[rewrite-clj.zip/right]]"],"~$append-child",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",485,"^9",7,"^:",485,"^;",19,"^19",["^1:",["^:C",["^1:",[["^1;","^:["]]]]],"^6","Return zipper with `item` inserted as the last child of the current node in `zloc`, without moving.\n  Will insert a space if necessary."],"^1=","^48","^7","rewrite_clj/zip.cljc","^;",19,"^:D",["^1:",[["^1;","^:["]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",485,"^:H",["^U",[null,"^:N"]],"^:",485,"^:K",2,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;","^:["]]]]],"^6","Return zipper with `item` inserted as the last child of the current node in `zloc`, without moving.\n  Will insert a space if necessary."],"~$find-token",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",435,"^9",7,"^:",435,"^;",17,"^19",["^1:",["^:C",["^1:",[["^1;","^:W"],["^1;","~$f","^:W"]]]]],"^6","Return `zloc` located to the the first token node satisfying predicate `p?`.\n  Search starts at the current node and continues via movement function `f`.\n\n   `f` defaults to [[rewrite-clj.zip/right]]","^:P",["^ ","^:G",false,"^:Q",3,"^:K",3,"^:D",[["^1;","^:W"],["^1;","~$f","^:W"]],"^19",["^1:",[["^1;","^:W"],["^1;","~$f","^:W"]]],"^:F",["^1:",[null,null]]]],"^1=","^6J","^7","rewrite_clj/zip.cljc","^;",17,"^:P",["^ ","^:G",false,"^:Q",3,"^:K",3,"^:D",[["^1;","^:W"],["^1;","~$f","^:W"]],"^19",["^1:",[["^1;","^:W"],["^1;","~$f","^:W"]]],"^:F",["^1:",[null,null]]],"^:D",[["^1;","^:W"],["^1;","~$f","^:W"]],"^:E",null,"^:Q",3,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^:R",[["^ ","^:Q",2,"^:G",false,"^:S","^:N"],["^ ","^:Q",3,"^:G",false,"^:S",["^U",["^:N","^:J"]]]],"^8",435,"^:",435,"^:K",3,"^:L",true,"^19",["^1:",[["^1;","^:W"],["^1;","~$f","^:W"]]],"^6","Return `zloc` located to the the first token node satisfying predicate `p?`.\n  Search starts at the current node and continues via movement function `f`.\n\n   `f` defaults to [[rewrite-clj.zip/right]]"],"~$suffix",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",341,"^9",7,"^:",341,"^;",13,"^19",["^1:",["^:C",["^1:",[["^1;","~$s"]]]]],"^6","Return zipper with the current node in `zloc` suffixed with string `s`.\n   Operates on token node or a multi-line node, else exception is thrown.\n   When multi-line, last line is suffixed."],"^1=","^6U","^7","rewrite_clj/zip.cljc","^;",13,"^:D",["^1:",[["^1;","~$s"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",341,"^:H","^:N","^:",341,"^:K",2,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;","~$s"]]]]],"^6","Return zipper with the current node in `zloc` suffixed with string `s`.\n   Operates on token node or a multi-line node, else exception is thrown.\n   When multi-line, last line is suffixed."],"^Z",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",593,"^9",7,"^:",593,"^;",11,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Returns true if current node in `zloc` is a set."],"^1=","^6T","^7","rewrite_clj/zip.cljc","^;",11,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",593,"^:H","^:Y","^:",593,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Returns true if current node in `zloc` is a set."],"~$prepend-space",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^;",43,"^:P",["^ ","^:G",false,"^:Q",2,"^:K",2,"^:D",[["^1;","~$n"],["^1;"]],"^19",["^1:",[["^1;","~$n"],["^1;"]]],"^:F",["^1:",[null,null]]],"^9",30,"^8",886,"~:deprecated","0.5.0","^:",886,"^19",["^1:",["^:C",["^1:",[["^1;","~$n"],["^1;"]]]]],"^6","DEPRECATED: renamed to [[insert-space-left]]."],"^1=","^3K","^7","rewrite_clj/zip.cljc","^;",43,"^:P",["^ ","^:G",false,"^:Q",2,"^:K",2,"^:D",[["^1;","~$n"],["^1;"]],"^19",["^1:",[["^1;","~$n"],["^1;"]]],"^:F",["^1:",[null,null]]],"^:D",[["^1;","~$n"],["^1;"]],"^:E",null,"^:Q",2,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^:R",[["^ ","^:Q",2,"^:G",false,"^:S",["^U",[null,"^:T","^:N","^:U","^:J"]]],["^ ","^:Q",1,"^:G",false,"^:S",["^U",[null,"^:T","^:N","^:U","^:J"]]]],"^8",886,"^;>","0.5.0","^:",886,"^:K",2,"^:L",true,"^19",["^1:",[["^1;","~$n"],["^1;"]]],"^6","DEPRECATED: renamed to [[insert-space-left]]."],"^[",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",547,"^9",7,"^:",547,"^;",13,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Return `zloc` with current node removed. Returned zipper location\n   is moved to the first non-whitespace node preceding removed node in a depth-first walk.\n   Removes whitespace appropriately.\n\n  - `[1 |2  3]    => [|1 3]`\n  - `[1 |2]       => [|1]`\n  - `[|1 2]       => |[2]`\n  - `[|1]         => |[]`\n  - `[  |1  ]     => |[]`\n  - `[1 [2 3] |4] => [1 [2 |3]]`\n  - `[|1 [2 3] 4] => |[[2 3] 4]`\n\n   If the removed node is a rightmost sibling, both leading and trailing whitespace\n   is removed, otherwise only trailing whitespace is removed.\n\n   The result is that a following element (no matter whether it is on the same line\n   or not) will end up at same positon (line/column) as the removed one.\n   If a comment lies betwen the original node and the neighbour this will not hold true.\n   \n   If the removed node is at end of input and is trailed by 1 or more newlines, \n   a single trailing newline will be preserved."],"^1=","^6H","^7","rewrite_clj/zip.cljc","^;",13,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",547,"^:H",["^U",["^:N","^:J"]],"^:",547,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Return `zloc` with current node removed. Returned zipper location\n   is moved to the first non-whitespace node preceding removed node in a depth-first walk.\n   Removes whitespace appropriately.\n\n  - `[1 |2  3]    => [|1 3]`\n  - `[1 |2]       => [|1]`\n  - `[|1 2]       => |[2]`\n  - `[|1]         => |[]`\n  - `[  |1  ]     => |[]`\n  - `[1 [2 3] |4] => [1 [2 |3]]`\n  - `[|1 [2 3] 4] => |[[2 3] 4]`\n\n   If the removed node is a rightmost sibling, both leading and trailing whitespace\n   is removed, otherwise only trailing whitespace is removed.\n\n   The result is that a following element (no matter whether it is on the same line\n   or not) will end up at same positon (line/column) as the removed one.\n   If a comment lies betwen the original node and the neighbour this will not hold true.\n   \n   If the removed node is at end of input and is trailed by 1 or more newlines, \n   a single trailing newline will be preserved."],"~$down",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",506,"^9",7,"^:",506,"^;",11,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Return zipper with location moved down to the first non-whitespace/non-comment child node of the current node in `zloc`, or nil if no applicable children."],"^1=","^3D","^7","rewrite_clj/zip.cljc","^;",11,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",506,"^:H",["^U",["^:N","^:J"]],"^:",506,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Return zipper with location moved down to the first non-whitespace/non-comment child node of the current node in `zloc`, or nil if no applicable children."],"~$find-next-depth-first",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",385,"^9",7,"^:",385,"^;",28,"^19",["^1:",["^:C",["^1:",[["^1;","^:W"]]]]],"^6","Return `zloc` located to next node satisfying predicate `p?` else `nil`.\n   Search starts depth-first after the current node."],"^1=","^38","^7","rewrite_clj/zip.cljc","^;",28,"^:D",["^1:",[["^1;","^:W"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",385,"^:H",["^U",["^:N","^:J"]],"^:",385,"^:K",2,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;","^:W"]]]]],"^6","Return `zloc` located to next node satisfying predicate `p?` else `nil`.\n   Search starts depth-first after the current node."],"^10",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",598,"^9",7,"^:",598,"^;",11,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Returns true if current node in `zloc` is a map."],"^1=","^3@","^7","rewrite_clj/zip.cljc","^;",11,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",598,"^:H","^:Y","^:",598,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Returns true if current node in `zloc` is a map."],"~$rightmost?",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",537,"^9",7,"^:",537,"^;",17,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Return true if at rightmost non-whitespace/non-comment sibling node in `zloc`."],"^1=","^74","^7","rewrite_clj/zip.cljc","^;",17,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",537,"^:H","^:Y","^:",537,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Return true if at rightmost non-whitespace/non-comment sibling node in `zloc`."],"~$root-string",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",278,"^9",25,"^:",278,"^;",36,"^:B","0.4.0","^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Return string representing the zipped-up `zloc` zipper."],"^:B","0.4.0","^1=","^37","^7","rewrite_clj/zip.cljc","^;",36,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",278,"^:H",["^U",["^:N","^:J"]],"^:",278,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Return string representing the zipped-up `zloc` zipper."],"^11",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",653,"^9",7,"^:",653,"^;",10,"^19",["^1:",["^:C",["^1:",[["^1;","~$k"]]]]],"^6","Returns `zloc` located to map key node's sexpr value matching `k` else `nil`.\n\n  `k` should be:\n  - a key for maps\n  - a zero-based index for sequences\n\n  NOTE: `k` will be compared against resolved keywords in maps.\n  See docs for sexpr behavior on [namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)."],"^1=","^6A","^7","rewrite_clj/zip.cljc","^;",10,"^:D",["^1:",[["^1;","~$k"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",653,"^:H",["^U",["^:N","^:J"]],"^:",653,"^:K",2,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;","~$k"]]]]],"^6","Returns `zloc` located to map key node's sexpr value matching `k` else `nil`.\n\n  `k` should be:\n  - a key for maps\n  - a zero-based index for sequences\n\n  NOTE: `k` will be compared against resolved keywords in maps.\n  See docs for sexpr behavior on [namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)."],"~$find-next-token",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",444,"^9",7,"^:",444,"^;",22,"^19",["^1:",["^:C",["^1:",[["^1;","^:W"],["^1;","~$f","^:W"]]]]],"^6","Return `zloc` located to the next token node satisfying predicate `p?` else `nil`.\n  Search starts one movement `f` after the current node and continues via `f`.\n\n   `f` defaults to [[rewrite-clj.zip/right]]","^:P",["^ ","^:G",false,"^:Q",3,"^:K",3,"^:D",[["^1;","^:W"],["^1;","~$f","^:W"]],"^19",["^1:",[["^1;","^:W"],["^1;","~$f","^:W"]]],"^:F",["^1:",[null,null]]]],"^1=","^71","^7","rewrite_clj/zip.cljc","^;",22,"^:P",["^ ","^:G",false,"^:Q",3,"^:K",3,"^:D",[["^1;","^:W"],["^1;","~$f","^:W"]],"^19",["^1:",[["^1;","^:W"],["^1;","~$f","^:W"]]],"^:F",["^1:",[null,null]]],"^:D",[["^1;","^:W"],["^1;","~$f","^:W"]],"^:E",null,"^:Q",3,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^:R",[["^ ","^:Q",2,"^:G",false,"^:S","^:N"],["^ ","^:Q",3,"^:G",false,"^:S",["^U",["^:N","^:J"]]]],"^8",444,"^:",444,"^:K",3,"^:L",true,"^19",["^1:",[["^1;","^:W"],["^1;","~$f","^:W"]]],"^6","Return `zloc` located to the next token node satisfying predicate `p?` else `nil`.\n  Search starts one movement `f` after the current node and continues via `f`.\n\n   `f` defaults to [[rewrite-clj.zip/right]]"],"~$append-newline",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^;",44,"^:P",["^ ","^:G",false,"^:Q",2,"^:K",2,"^:D",[["^1;","~$n"],["^1;"]],"^19",["^1:",[["^1;","~$n"],["^1;"]]],"^:F",["^1:",[null,null]]],"^9",30,"^8",904,"^;>","0.5.0","^:",904,"^19",["^1:",["^:C",["^1:",[["^1;","~$n"],["^1;"]]]]],"^6","DEPRECATED: renamed to [[insert-newline-right]]."],"^1=","^34","^7","rewrite_clj/zip.cljc","^;",44,"^:P",["^ ","^:G",false,"^:Q",2,"^:K",2,"^:D",[["^1;","~$n"],["^1;"]],"^19",["^1:",[["^1;","~$n"],["^1;"]]],"^:F",["^1:",[null,null]]],"^:D",[["^1;","~$n"],["^1;"]],"^:E",null,"^:Q",2,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^:R",[["^ ","^:Q",2,"^:G",false,"^:S",["^U",["^:T","^:N","^:U","^:J"]]],["^ ","^:Q",1,"^:G",false,"^:S",["^U",["^:T","^:N","^:U","^:J"]]]],"^8",904,"^;>","0.5.0","^:",904,"^:K",2,"^:L",true,"^19",["^1:",[["^1;","~$n"],["^1;"]]],"^6","DEPRECATED: renamed to [[insert-newline-right]]."],"~$->root-string",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",283,"^9",30,"^:",283,"^;",43,"^;>","0.4.0","^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","DEPRECATED. Renamed to [[root-string]]."],"^1=","^6Z","^7","rewrite_clj/zip.cljc","^;",43,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",283,"^;>","0.4.0","^:H",["^U",["^:N","^:J"]],"^:",283,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","DEPRECATED. Renamed to [[root-string]]."],"~$edit*",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",1009,"^9",7,"^:",1009,"^;",12,"^19",["^1:",["^:C",["^1:",[["^1;","~$f","~$&","~$args"]]]]],"^6","Raw version of [[edit]].\n\nReturns zipper with value of `(apply f current-node args)` replacing current node in `zloc`.\n   \n   The result of `f` should be a rewrite-clj node.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.","^:P",["^ ","^:G",true,"^:Q",2,"^:K",2,"^:D",[["^1:",["^1;","~$f","^;G"]]],"^19",["^1:",[["^1;","~$f","~$&","^;G"]]],"^:F",["^1:",[null]]]],"^1=","^2Q","^7","rewrite_clj/zip.cljc","^;",12,"^:P",["^ ","^:G",true,"^:Q",2,"^:K",2,"^:D",[["^1:",["^1;","~$f","^;G"]]],"^19",["^1:",[["^1;","~$f","~$&","^;G"]]],"^:F",["^1:",[null]]],"^:D",[["^1:",["^1;","~$f","^;G"]]],"^:E",null,"^:Q",2,"^:F",["^1:",[null]],"^9",1,"^:G",true,"^:R",[["^ ","^:Q",2,"^:G",true,"^:S","^:N"]],"^8",1009,"^:H","^:N","^:",1009,"^:K",2,"^:L",true,"^19",["^1:",[["^1;","~$f","~$&","^;G"]]],"^6","Raw version of [[edit]].\n\nReturns zipper with value of `(apply f current-node args)` replacing current node in `zloc`.\n   \n   The result of `f` should be a rewrite-clj node.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes."],"~$splice",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",321,"^9",7,"^:",321,"^;",13,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Return zipper with the children of the current node in `zloc` merged into itself.\n   (akin to Clojure's `unquote-splicing` macro: `~@...`).\n   - if the node is not one that can have children, no modification will\n     be performed.\n   - if the node has no or only whitespace children, it will be removed.\n   - otherwise, splicing will be performed, moving the zipper to the first\n     non-whitespace spliced child node.\n\n  For example, given `[[1 2 3] 4 5 6]`, if zloc is located at vector `[1 2 3]`, a splice will result in raising the vector's children up `[1 2 3 4 5 6]` and locating the zipper at node `1`."],"^1=","^6P","^7","rewrite_clj/zip.cljc","^;",13,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",321,"^:H",["^U",[null,"^:T","^:N","^:U","^:J"]],"^:",321,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Return zipper with the children of the current node in `zloc` merged into itself.\n   (akin to Clojure's `unquote-splicing` macro: `~@...`).\n   - if the node is not one that can have children, no modification will\n     be performed.\n   - if the node has no or only whitespace children, it will be removed.\n   - otherwise, splicing will be performed, moving the zipper to the first\n     non-whitespace spliced child node.\n\n  For example, given `[[1 2 3] 4 5 6]`, if zloc is located at vector `[1 2 3]`, a splice will result in raising the vector's children up `[1 2 3 4 5 6]` and locating the zipper at node `1`."],"^12",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",304,"^9",7,"^:",304,"^;",14,"^19",["^1:",["^:C",["^1:",[["^1;","~$value"]]]]],"^6","Return `zloc` with the current node replaced by `value`.\n  If `value` is not already a node, an attempt will be made to coerce it to one."],"^1=","^72","^7","rewrite_clj/zip.cljc","^;",14,"^:D",["^1:",[["^1;","^;I"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",304,"^:H",["^U",["^:T","^:N","^:U","^:J"]],"^:",304,"^:K",2,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;","^;I"]]]]],"^6","Return `zloc` with the current node replaced by `value`.\n  If `value` is not already a node, an attempt will be made to coerce it to one."],"~$prepend-newline",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^;",45,"^:P",["^ ","^:G",false,"^:Q",2,"^:K",2,"^:D",[["^1;","~$n"],["^1;"]],"^19",["^1:",[["^1;","~$n"],["^1;"]]],"^:F",["^1:",[null,null]]],"^9",30,"^8",898,"^;>","0.5.0","^:",898,"^19",["^1:",["^:C",["^1:",[["^1;","~$n"],["^1;"]]]]],"^6","DEPRECATED: renamed to [[insert-newline-left]]."],"^1=","^2M","^7","rewrite_clj/zip.cljc","^;",45,"^:P",["^ ","^:G",false,"^:Q",2,"^:K",2,"^:D",[["^1;","~$n"],["^1;"]],"^19",["^1:",[["^1;","~$n"],["^1;"]]],"^:F",["^1:",[null,null]]],"^:D",[["^1;","~$n"],["^1;"]],"^:E",null,"^:Q",2,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^:R",[["^ ","^:Q",2,"^:G",false,"^:S",["^U",["^:T","^:N","^:U","^:J"]]],["^ ","^:Q",1,"^:G",false,"^:S",["^U",["^:T","^:N","^:U","^:J"]]]],"^8",898,"^;>","0.5.0","^:",898,"^:K",2,"^:L",true,"^19",["^1:",[["^1;","~$n"],["^1;"]]],"^6","DEPRECATED: renamed to [[insert-newline-left]]."],"~$left*",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",932,"^9",7,"^:",932,"^;",12,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Raw version of [[left]].\n\nReturns zipper with location at the left sibling of the current node in `zloc`, or nil.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes."],"^1=","^2Z","^7","rewrite_clj/zip.cljc","^;",12,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",932,"^:H",["^U",["^:T","^:N","^:U","^:J"]],"^:",932,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Raw version of [[left]].\n\nReturns zipper with location at the left sibling of the current node in `zloc`, or nil.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes."],"~$leftmost*",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",991,"^9",7,"^:",991,"^;",16,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Raw version of [[leftmost]].\n\nReturns zipper with location at the leftmost sibling of the current node in `zloc`, or self.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes."],"^1=","^5O","^7","rewrite_clj/zip.cljc","^;",16,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",991,"^:H",["^U",[null,"^:T","^:N","^:U","^:J"]],"^:",991,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Raw version of [[leftmost]].\n\nReturns zipper with location at the leftmost sibling of the current node in `zloc`, or self.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes."],"~$end?",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",542,"^9",7,"^:",542,"^;",11,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Return true if `zloc` is at end of depth-first traversal."],"^1=","^6@","^7","rewrite_clj/zip.cljc","^;",11,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",542,"^:H",["^U",["^:Y","^:N"]],"^:",542,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Return true if `zloc` is at end of depth-first traversal."],"~$sexpr-able?",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",240,"^9",7,"^:",240,"^;",18,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Return true if current node's element type in `zloc` can be [[sexpr]]-ed.\n\n   See [related docs in user guide](/doc/01-user-guide.adoc#not-all-clojure-is-sexpr-able)"],"^1=","^6D","^7","rewrite_clj/zip.cljc","^;",18,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",240,"^:H",["^U",["^:Y","^:J"]],"^:",240,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Return true if current node's element type in `zloc` can be [[sexpr]]-ed.\n\n   See [related docs in user guide](/doc/01-user-guide.adoc#not-all-clojure-is-sexpr-able)"],"~$find-tag-by-pos",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",462,"^9",7,"^:",462,"^;",22,"^19",["^1:",["^:C",["^1:",[["^1;","~$pos","~$t"]]]]],"^6","Return `zloc` located to the last node spanning position `pos` with tag `t` else `nil`.\n  Search is depth-first from the current node."],"^1=","^2Y","^7","rewrite_clj/zip.cljc","^;",22,"^:D",["^1:",[["^1;","^;P","~$t"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",462,"^:H",["^U",["^:N","^:J"]],"^:",462,"^:K",3,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;","^;P","~$t"]]]]],"^6","Return `zloc` located to the last node spanning position `pos` with tag `t` else `nil`.\n  Search is depth-first from the current node."],"~$append-space",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^;",42,"^:P",["^ ","^:G",false,"^:Q",2,"^:K",2,"^:D",[["^1;","~$n"],["^1;"]],"^19",["^1:",[["^1;","~$n"],["^1;"]]],"^:F",["^1:",[null,null]]],"^9",30,"^8",892,"^;>","0.5.0","^:",892,"^19",["^1:",["^:C",["^1:",[["^1;","~$n"],["^1;"]]]]],"^6","DEPRECATED: renamed to [[insert-space-right]]."],"^1=","^6C","^7","rewrite_clj/zip.cljc","^;",42,"^:P",["^ ","^:G",false,"^:Q",2,"^:K",2,"^:D",[["^1;","~$n"],["^1;"]],"^19",["^1:",[["^1;","~$n"],["^1;"]]],"^:F",["^1:",[null,null]]],"^:D",[["^1;","~$n"],["^1;"]],"^:E",null,"^:Q",2,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^:R",[["^ ","^:Q",2,"^:G",false,"^:S",["^U",[null,"^:T","^:N","^:U","^:J"]]],["^ ","^:Q",1,"^:G",false,"^:S",["^U",[null,"^:T","^:N","^:U","^:J"]]]],"^8",892,"^;>","0.5.0","^:",892,"^:K",2,"^:L",true,"^19",["^1:",[["^1;","~$n"],["^1;"]]],"^6","DEPRECATED: renamed to [[insert-space-right]]."],"~$prewalk",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",737,"^9",7,"^:",737,"^;",14,"^19",["^1:",["^:C",["^1:",[["^1;","~$f"],["^1;","^:W","~$f"]]]]],"^6","Return zipper modified by an isolated depth-first pre-order traversal.\n\n   Pre-order traversal visits root before children.\n   For example, traversal order of `(1 (2 3 (4 5) 6 (7 8)) 9)` is:\n\n   1. `(1 (2 3 (4 5) 6 (7 8)) 9)`\n   2. `1`\n   3. `(2 3 (4 5) 6 (7 8))`\n   4. `2`\n   5. `3`\n   6. `(4 5)`\n   7. `4`\n   8. `5`\n   9. `6`\n   10. `(7 8)`\n   11. `7`\n   12. `8`\n   13. `9`\n\n   Traversal starts at the current node in `zloc` and continues to the end of the isolated sub-tree.\n\n   Function `f` is called on the zipper locations satisfying predicate `p?` and must return either\n   - nil to indicate no changes\n   - or a valid zipper\n   WARNING: when function `f` changes the location in the zipper, normal traversal will be affected.\n\n   When `p?` is not specified `f` is called on all locations.\n\n   Note that by default a newly created zipper automatically navigates to the first non-whitespace\n   node. If you want to be sure to walk all forms in a zipper, you'll want to navigate one up prior to your walk:\n\n   ```Clojure\n   (-> (zip/of-string \"my clojure forms\")\n       zip/up\n       (zip/prewalk ...))\n   ```\n\n   See [docs on sub editing](/doc/01-user-guide.adoc#sub-editing).","^:P",["^ ","^:G",false,"^:Q",3,"^:K",3,"^:D",[["^1;","~$f"],["^1;","^:W","~$f"]],"^19",["^1:",[["^1;","~$f"],["^1;","^:W","~$f"]]],"^:F",["^1:",[null,null]]]],"^1=","^3A","^7","rewrite_clj/zip.cljc","^;",14,"^:P",["^ ","^:G",false,"^:Q",3,"^:K",3,"^:D",[["^1;","~$f"],["^1;","^:W","~$f"]],"^19",["^1:",[["^1;","~$f"],["^1;","^:W","~$f"]]],"^:F",["^1:",[null,null]]],"^:D",[["^1;","~$f"],["^1;","^:W","~$f"]],"^:E",null,"^:Q",3,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^:R",[["^ ","^:Q",2,"^:G",false,"^:S","^:N"],["^ ","^:Q",3,"^:G",false,"^:S",["^U",["^:T","^:N","^:U","^:J"]]]],"^8",737,"^:",737,"^:K",3,"^:L",true,"^19",["^1:",[["^1;","~$f"],["^1;","^:W","~$f"]]],"^6","Return zipper modified by an isolated depth-first pre-order traversal.\n\n   Pre-order traversal visits root before children.\n   For example, traversal order of `(1 (2 3 (4 5) 6 (7 8)) 9)` is:\n\n   1. `(1 (2 3 (4 5) 6 (7 8)) 9)`\n   2. `1`\n   3. `(2 3 (4 5) 6 (7 8))`\n   4. `2`\n   5. `3`\n   6. `(4 5)`\n   7. `4`\n   8. `5`\n   9. `6`\n   10. `(7 8)`\n   11. `7`\n   12. `8`\n   13. `9`\n\n   Traversal starts at the current node in `zloc` and continues to the end of the isolated sub-tree.\n\n   Function `f` is called on the zipper locations satisfying predicate `p?` and must return either\n   - nil to indicate no changes\n   - or a valid zipper\n   WARNING: when function `f` changes the location in the zipper, normal traversal will be affected.\n\n   When `p?` is not specified `f` is called on all locations.\n\n   Note that by default a newly created zipper automatically navigates to the first non-whitespace\n   node. If you want to be sure to walk all forms in a zipper, you'll want to navigate one up prior to your walk:\n\n   ```Clojure\n   (-> (zip/of-string \"my clojure forms\")\n       zip/up\n       (zip/prewalk ...))\n   ```\n\n   See [docs on sub editing](/doc/01-user-guide.adoc#sub-editing)."],"~$find-tag",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",391,"^9",7,"^:",391,"^;",15,"^19",["^1:",["^:C",["^1:",[["^1;","~$t"],["^1;","~$f","~$t"]]]]],"^6","Return `zloc` located to the first node with tag `t` else `nil`.\n   Search starts at the current node and continues via movement function `f`.\n\n   `f` defaults to [[rewrite-clj.zip/right]]","^:P",["^ ","^:G",false,"^:Q",3,"^:K",3,"^:D",[["^1;","~$t"],["^1;","~$f","~$t"]],"^19",["^1:",[["^1;","~$t"],["^1;","~$f","~$t"]]],"^:F",["^1:",[null,null]]]],"^1=","^3>","^7","rewrite_clj/zip.cljc","^;",15,"^:P",["^ ","^:G",false,"^:Q",3,"^:K",3,"^:D",[["^1;","~$t"],["^1;","~$f","~$t"]],"^19",["^1:",[["^1;","~$t"],["^1;","~$f","~$t"]]],"^:F",["^1:",[null,null]]],"^:D",[["^1;","~$t"],["^1;","~$f","~$t"]],"^:E",null,"^:Q",3,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^:R",[["^ ","^:Q",2,"^:G",false,"^:S","^:N"],["^ ","^:Q",3,"^:G",false,"^:S",["^U",["^:N","^:J"]]]],"^8",391,"^:",391,"^:K",3,"^:L",true,"^19",["^1:",[["^1;","~$t"],["^1;","~$f","~$t"]]],"^6","Return `zloc` located to the first node with tag `t` else `nil`.\n   Search starts at the current node and continues via movement function `f`.\n\n   `f` defaults to [[rewrite-clj.zip/right]]"],"~$sexpr",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",233,"^9",7,"^:",233,"^;",12,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Return s-expression (the Clojure form) of current node in `zloc`.\n\n  See docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances)."],"^1=","^3<","^7","rewrite_clj/zip.cljc","^;",12,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",233,"^:H",["^U",["^:N","^:J"]],"^:",233,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Return s-expression (the Clojure form) of current node in `zloc`.\n\n  See docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances)."],"^;I",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",252,"^9",30,"^:",252,"^;",35,"^;>","0.4.0","^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","DEPRECATED. Return a tag/s-expression pair for inner nodes, or\n   the s-expression itself for leaves."],"^1=","^3?","^7","rewrite_clj/zip.cljc","^;",35,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",252,"^;>","0.4.0","^:H",["^U",["^:N","^:J"]],"^:",252,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","DEPRECATED. Return a tag/s-expression pair for inner nodes, or\n   the s-expression itself for leaves."],"~$find-value",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",409,"^9",7,"^:",409,"^;",17,"^19",["^1:",["^:C",["^1:",[["^1;","~$v"],["^1;","~$f","~$v"]]]]],"^6","Return `zloc` located to the first token node that `sexpr`esses to `v` else `nil`.\n   Search starts from the current node and continues via movement function `f`.\n\n   `v` can be a single value or a set. When `v` is a set, matches on any value in set.\n\n   `f` defaults to [[rewrite-clj.zip/right]] in short form call.\n\n  See docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances).","^:P",["^ ","^:G",false,"^:Q",3,"^:K",3,"^:D",[["^1;","~$v"],["^1;","~$f","~$v"]],"^19",["^1:",[["^1;","~$v"],["^1;","~$f","~$v"]]],"^:F",["^1:",[null,null]]]],"^1=","^3;","^7","rewrite_clj/zip.cljc","^;",17,"^:P",["^ ","^:G",false,"^:Q",3,"^:K",3,"^:D",[["^1;","~$v"],["^1;","~$f","~$v"]],"^19",["^1:",[["^1;","~$v"],["^1;","~$f","~$v"]]],"^:F",["^1:",[null,null]]],"^:D",[["^1;","~$v"],["^1;","~$f","~$v"]],"^:E",null,"^:Q",3,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^:R",[["^ ","^:Q",2,"^:G",false,"^:S","^:N"],["^ ","^:Q",3,"^:G",false,"^:S",["^U",["^:N","^:J"]]]],"^8",409,"^:",409,"^:K",3,"^:L",true,"^19",["^1:",[["^1;","~$v"],["^1;","~$f","~$v"]]],"^6","Return `zloc` located to the first token node that `sexpr`esses to `v` else `nil`.\n   Search starts from the current node and continues via movement function `f`.\n\n   `v` can be a single value or a set. When `v` is a set, matches on any value in set.\n\n   `f` defaults to [[rewrite-clj.zip/right]] in short form call.\n\n  See docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances)."],"~$find-next",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",370,"^9",7,"^:",370,"^;",16,"^19",["^1:",["^:C",["^1:",[["^1;","^:W"],["^1;","~$f","^:W"]]]]],"^6","Return `zloc` located to the next node satisfying predicate `p?` else `nil`.\n   Search starts one movement `f` from the current node and continues via `f`.\n\n   `f` defaults to [[rewrite-clj.zip/right]]","^:P",["^ ","^:G",false,"^:Q",3,"^:K",3,"^:D",[["^1;","^:W"],["^1;","~$f","^:W"]],"^19",["^1:",[["^1;","^:W"],["^1;","~$f","^:W"]]],"^:F",["^1:",[null,null]]]],"^1=","^39","^7","rewrite_clj/zip.cljc","^;",16,"^:P",["^ ","^:G",false,"^:Q",3,"^:K",3,"^:D",[["^1;","^:W"],["^1;","~$f","^:W"]],"^19",["^1:",[["^1;","^:W"],["^1;","~$f","^:W"]]],"^:F",["^1:",[null,null]]],"^:D",[["^1;","^:W"],["^1;","~$f","^:W"]],"^:E",null,"^:Q",3,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^:R",[["^ ","^:Q",2,"^:G",false,"^:S","^:N"],["^ ","^:Q",3,"^:G",false,"^:S",["^U",["^:N","^:J"]]]],"^8",370,"^:",370,"^:K",3,"^:L",true,"^19",["^1:",[["^1;","^:W"],["^1;","~$f","^:W"]]],"^6","Return `zloc` located to the next node satisfying predicate `p?` else `nil`.\n   Search starts one movement `f` from the current node and continues via `f`.\n\n   `f` defaults to [[rewrite-clj.zip/right]]"],"~$up*",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",941,"^9",7,"^:",941,"^;",10,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Raw version of [[up]].\n\nReturns zipper with the location at the parent of current node in `zloc`, or nil if at\n  the top.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes."],"^1=","^33","^7","rewrite_clj/zip.cljc","^;",10,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",941,"^:H",["^U",["^:T","^:N","^:U","^:J"]],"^:",941,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Raw version of [[up]].\n\nReturns zipper with the location at the parent of current node in `zloc`, or nil if at\n  the top.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes."],"~$map-keys",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",625,"^9",7,"^:",625,"^;",15,"^19",["^1:",["^:C",["^1:",[["~$f","^1;"]]]]],"^6","Returns `zloc` with function `f` applied to all key nodes of the current node.\n   Current node must be map node.\n\n  `zloc` location is unchanged.\n\n  `f` arg is zloc positioned at key node and should return:\n  - an updated zloc with zloc positioned at key node\n  - a falsey value to leave value node unchanged\n\n  Folks typically use [[rewrite-clj.zip/edit]] for `f`."],"^1=","^50","^7","rewrite_clj/zip.cljc","^;",15,"^:D",["^1:",[["~$f","^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",625,"^:H",["^U",[null,"^:N","^:J"]],"^:",625,"^:K",2,"^:L",true,"^19",["^1:",["^:C",["^1:",[["~$f","^1;"]]]]],"^6","Returns `zloc` with function `f` applied to all key nodes of the current node.\n   Current node must be map node.\n\n  `zloc` location is unchanged.\n\n  `f` arg is zloc positioned at key node and should return:\n  - an updated zloc with zloc positioned at key node\n  - a falsey value to leave value node unchanged\n\n  Folks typically use [[rewrite-clj.zip/edit]] for `f`."],"~$edit",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",310,"^9",7,"^:",310,"^;",11,"^19",["^1:",["^:C",["^1:",[["^1;","~$f","~$&","^;G"]]]]],"^6","Return `zloc` with the current node replaced with the result of:\n\n   `(apply f (s-expr current-node) args)`\n\n  The result of `f`, if not already a node, will be coerced to a node if possible.\n\n  See docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances).","^:P",["^ ","^:G",true,"^:Q",2,"^:K",2,"^:D",[["^1:",["^1;","~$f","^;G"]]],"^19",["^1:",[["^1;","~$f","~$&","^;G"]]],"^:F",["^1:",[null]]]],"^1=","^4U","^7","rewrite_clj/zip.cljc","^;",11,"^:P",["^ ","^:G",true,"^:Q",2,"^:K",2,"^:D",[["^1:",["^1;","~$f","^;G"]]],"^19",["^1:",[["^1;","~$f","~$&","^;G"]]],"^:F",["^1:",[null]]],"^:D",[["^1:",["^1;","~$f","^;G"]]],"^:E",null,"^:Q",2,"^:F",["^1:",[null]],"^9",1,"^:G",true,"^:R",[["^ ","^:Q",2,"^:G",true,"^:S","^:N"]],"^8",310,"^:H","^:N","^:",310,"^:K",2,"^:L",true,"^19",["^1:",[["^1;","~$f","~$&","^;G"]]],"^6","Return `zloc` with the current node replaced with the result of:\n\n   `(apply f (s-expr current-node) args)`\n\n  The result of `f`, if not already a node, will be coerced to a node if possible.\n\n  See docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances)."],"~$namespaced-map?",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",603,"^9",7,"^:",603,"^;",22,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Returns true if the current node in `zloc` is a namespaced map."],"^1=","^3R","^7","rewrite_clj/zip.cljc","^;",22,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",603,"^:H","^:Y","^:",603,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Returns true if the current node in `zloc` is a namespaced map."],"~$edn*",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",206,"^9",7,"^:",206,"^;",11,"^19",["^1:",["^:C",["^1:",[["~$node"],["^<0","~$opts"]]]]],"^6","Create and return zipper from Clojure/ClojureScript/EDN `node` (likely parsed by [[rewrite-clj.parse]]).\n\n  Optional `opts` can specify:\n  - `:track-position?` set to `true` to enable ones-based row/column tracking, see [docs on position tracking](/doc/01-user-guide.adoc#position-tracking).\n  - `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)","^:P",["^ ","^:G",false,"^:Q",2,"^:K",2,"^:D",[["^<0"],["^<0","^<1"]],"^19",["^1:",[["^<0"],["^<0","^<1"]]],"^:F",["^1:",[null,null]]]],"^1=","^3S","^7","rewrite_clj/zip.cljc","^;",11,"^:P",["^ ","^:G",false,"^:Q",2,"^:K",2,"^:D",[["^<0"],["^<0","^<1"]],"^19",["^1:",[["^<0"],["^<0","^<1"]]],"^:F",["^1:",[null,null]]],"^:D",[["^<0"],["^<0","^<1"]],"^:E",null,"^:Q",2,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^:R",[["^ ","^:Q",1,"^:G",false,"^:S","^:N"],["^ ","^:Q",2,"^:G",false,"^:S",["^U",["^:T","^:U","^:J"]]]],"^8",206,"^:",206,"^:K",2,"^:L",true,"^19",["^1:",[["^<0"],["^<0","^<1"]]],"^6","Create and return zipper from Clojure/ClojureScript/EDN `node` (likely parsed by [[rewrite-clj.parse]]).\n\n  Optional `opts` can specify:\n  - `:track-position?` set to `true` to enable ones-based row/column tracking, see [docs on position tracking](/doc/01-user-guide.adoc#position-tracking).\n  - `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)"],"~$find-next-tag",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",400,"^9",7,"^:",400,"^;",20,"^19",["^1:",["^:C",["^1:",[["^1;","~$t"],["^1;","~$f","~$t"]]]]],"^6","Return `zloc` located to the next node with tag `t` else `nil`.\n  Search starts one movement `f` after the current node and continues via `f`.\n\n   `f` defaults to [[rewrite-clj.zip/right]]","^:P",["^ ","^:G",false,"^:Q",3,"^:K",3,"^:D",[["^1;","~$t"],["^1;","~$f","~$t"]],"^19",["^1:",[["^1;","~$t"],["^1;","~$f","~$t"]]],"^:F",["^1:",[null,null]]]],"^1=","^2N","^7","rewrite_clj/zip.cljc","^;",20,"^:P",["^ ","^:G",false,"^:Q",3,"^:K",3,"^:D",[["^1;","~$t"],["^1;","~$f","~$t"]],"^19",["^1:",[["^1;","~$t"],["^1;","~$f","~$t"]]],"^:F",["^1:",[null,null]]],"^:D",[["^1;","~$t"],["^1;","~$f","~$t"]],"^:E",null,"^:Q",3,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^:R",[["^ ","^:Q",2,"^:G",false,"^:S","^:N"],["^ ","^:Q",3,"^:G",false,"^:S",["^U",["^:N","^:J"]]]],"^8",400,"^:",400,"^:K",3,"^:L",true,"^19",["^1:",[["^1;","~$t"],["^1;","~$f","~$t"]]],"^6","Return `zloc` located to the next node with tag `t` else `nil`.\n  Search starts one movement `f` after the current node and continues via `f`.\n\n   `f` defaults to [[rewrite-clj.zip/right]]"],"~$replace*",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",1000,"^9",7,"^:",1000,"^;",15,"^19",["^1:",["^:C",["^1:",[["^1;","^<0"]]]]],"^6","Raw version of [[replace]].\n\nReturns zipper with `node` replacing current node in `zloc`, without moving location.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes."],"^1=","^3O","^7","rewrite_clj/zip.cljc","^;",15,"^:D",["^1:",[["^1;","^<0"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",1000,"^:H",["^U",["^:T","^:N","^:U","^:J"]],"^:",1000,"^:K",2,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;","^<0"]]]]],"^6","Raw version of [[replace]].\n\nReturns zipper with `node` replacing current node in `zloc`, without moving location.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes."],"~$subzip",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",696,"^9",7,"^:",696,"^;",13,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Create and return a zipper whose root is the current node in `zloc`.\n   \n   See [docs on sub editing](/doc/01-user-guide.adoc#sub-editing)."],"^1=","^3M","^7","rewrite_clj/zip.cljc","^;",13,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",696,"^:H",["^U",["^:T","^:U","^:J"]],"^:",696,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Create and return a zipper whose root is the current node in `zloc`.\n   \n   See [docs on sub editing](/doc/01-user-guide.adoc#sub-editing)."],"~$position-span",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",186,"^9",7,"^:",186,"^;",20,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Returns the ones-based `[[start-row start-col] [end-row end-col]]` of the current node in `zloc`.\n  `end-col` is exclusive.\n\n  Throws if `zloc` was not created with [position tracking](/doc/01-user-guide.adoc#position-tracking)."],"^1=","^3P","^7","rewrite_clj/zip.cljc","^;",20,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",186,"^:H","~$cljs.core/IVector","^:",186,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Returns the ones-based `[[start-row start-col] [end-row end-col]]` of the current node in `zloc`.\n  `end-col` is exclusive.\n\n  Throws if `zloc` was not created with [position tracking](/doc/01-user-guide.adoc#position-tracking)."],"~$skip-whitespace-left",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",853,"^9",7,"^:",853,"^;",27,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Return zipper with location moved to first non-whitespace/non-comment starting from current node in `zloc` traversing left."],"^1=","^4P","^7","rewrite_clj/zip.cljc","^;",27,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",853,"^:H",["^U",["^:N","^:J"]],"^:",853,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Return zipper with location moved to first non-whitespace/non-comment starting from current node in `zloc` traversing left."],"~$->string",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",273,"^9",30,"^:",273,"^;",38,"^;>","0.4.0","^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","DEPRECATED. Renamed to [[string]]."],"^1=","^6B","^7","rewrite_clj/zip.cljc","^;",38,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",273,"^;>","0.4.0","^:H",["^U",["^:N","^:J"]],"^:",273,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","DEPRECATED. Renamed to [[string]]."],"~$edit-node",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",679,"^9",7,"^:",679,"^;",16,"^19",["^1:",["^:C",["^1:",[["^1;","~$f"]]]]],"^6","Return zipper applying function `f` to `zloc`. The resulting\n   zipper will be located at the same path (i.e. the same number of\n   downwards and right movements from the root) incoming `zloc`.\n   \n   See also [[subedit-node]] for an isolated edit."],"^1=","^3F","^7","rewrite_clj/zip.cljc","^;",16,"^:D",["^1:",[["^1;","~$f"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",679,"^:H",["^U",[null,"^:N"]],"^:",679,"^:K",2,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;","~$f"]]]]],"^6","Return zipper applying function `f` to `zloc`. The resulting\n   zipper will be located at the same path (i.e. the same number of\n   downwards and right movements from the root) incoming `zloc`.\n   \n   See also [[subedit-node]] for an isolated edit."],"~$find-last-by-pos",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",453,"^9",7,"^:",453,"^;",23,"^19",["^1:",["^:C",["^1:",[["^1;","^;P"],["^1;","^;P","^:W"]]]]],"^6","Return `zloc` located to the last node spanning position `pos` that satisfies predicate `p?` else `nil`.\n   Search is depth-first from the current node.\n\n  NOTE: Does not ignore whitespace/comment nodes.","^:P",["^ ","^:G",false,"^:Q",3,"^:K",3,"^:D",[["^1;","^;P"],["^1;","^;P","^:W"]],"^19",["^1:",[["^1;","^;P"],["^1;","^;P","^:W"]]],"^:F",["^1:",[null,null]]]],"^1=","^3W","^7","rewrite_clj/zip.cljc","^;",23,"^:P",["^ ","^:G",false,"^:Q",3,"^:K",3,"^:D",[["^1;","^;P"],["^1;","^;P","^:W"]],"^19",["^1:",[["^1;","^;P"],["^1;","^;P","^:W"]]],"^:F",["^1:",[null,null]]],"^:D",[["^1;","^;P"],["^1;","^;P","^:W"]],"^:E",null,"^:Q",3,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^:R",[["^ ","^:Q",2,"^:G",false,"^:S","^:N"],["^ ","^:Q",3,"^:G",false,"^:S",["^U",["^:N","^:J"]]]],"^8",453,"^:",453,"^:K",3,"^:L",true,"^19",["^1:",[["^1;","^;P"],["^1;","^;P","^:W"]]],"^6","Return `zloc` located to the last node spanning position `pos` that satisfies predicate `p?` else `nil`.\n   Search is depth-first from the current node.\n\n  NOTE: Does not ignore whitespace/comment nodes."],"~$print-root",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",296,"^9",7,"^:",296,"^;",17,"^19",["^1:",["^:C",["^1:",[["^1;","~$writer"],["^1;"]]]]],"^6","Zip up and print `zloc` from root node.\n\n   NOTE: Optional `writer` is currently ignored for ClojureScript.","^:P",["^ ","^:G",false,"^:Q",2,"^:K",2,"^:D",[["^1;","^<<"],["^1;"]],"^19",["^1:",[["^1;","^<<"],["^1;"]]],"^:F",["^1:",[null,null]]]],"^1=","^6:","^7","rewrite_clj/zip.cljc","^;",17,"^:P",["^ ","^:G",false,"^:Q",2,"^:K",2,"^:D",[["^1;","^<<"],["^1;"]],"^19",["^1:",[["^1;","^<<"],["^1;"]]],"^:F",["^1:",[null,null]]],"^:D",[["^1;","^<<"],["^1;"]],"^:E",null,"^:Q",2,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^:R",[["^ ","^:Q",2,"^:G",false,"^:S","^:J"],["^ ","^:Q",1,"^:G",false,"^:S","^:J"]],"^8",296,"^:",296,"^:K",2,"^:L",true,"^19",["^1:",[["^1;","^<<"],["^1;"]]],"^6","Zip up and print `zloc` from root node.\n\n   NOTE: Optional `writer` is currently ignored for ClojureScript."],"^13",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",288,"^9",7,"^:",288,"^;",12,"^19",["^1:",["^:C",["^1:",[["^1;","^<<"],["^1;"]]]]],"^6","Print current node in `zloc`.\n\n   NOTE: Optional `writer` is currently ignored for ClojureScript.","^:P",["^ ","^:G",false,"^:Q",2,"^:K",2,"^:D",[["^1;","^<<"],["^1;"]],"^19",["^1:",[["^1;","^<<"],["^1;"]]],"^:F",["^1:",[null,null]]]],"^1=","^2W","^7","rewrite_clj/zip.cljc","^;",12,"^:P",["^ ","^:G",false,"^:Q",2,"^:K",2,"^:D",[["^1;","^<<"],["^1;"]],"^19",["^1:",[["^1;","^<<"],["^1;"]]],"^:F",["^1:",[null,null]]],"^:D",[["^1;","^<<"],["^1;"]],"^:E",null,"^:Q",2,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^:R",[["^ ","^:Q",2,"^:G",false,"^:S","^:J"],["^ ","^:Q",1,"^:G",false,"^:S","^:J"]],"^8",288,"^:",288,"^:K",2,"^:L",true,"^19",["^1:",[["^1;","^<<"],["^1;"]]],"^6","Print current node in `zloc`.\n\n   NOTE: Optional `writer` is currently ignored for ClojureScript."],"~$down*",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",951,"^9",7,"^:",951,"^;",12,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Raw version of [[down]].\n\nReturns zipper with the location at the leftmost child of current node in `zloc`, or\n  nil if no children.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes."],"^1=","^3B","^7","rewrite_clj/zip.cljc","^;",12,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",951,"^:H",["^U",["^:T","^:U","^:J"]],"^:",951,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Raw version of [[down]].\n\nReturns zipper with the location at the leftmost child of current node in `zloc`, or\n  nil if no children.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes."],"~$string",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",268,"^9",25,"^:",268,"^;",31,"^:B","0.4.0","^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Return string representing the current node in `zloc`."],"^:B","0.4.0","^1=","^3G","^7","rewrite_clj/zip.cljc","^;",31,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",268,"^:H",["^U",["^:N","^:J"]],"^:",268,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Return string representing the current node in `zloc`."],"^<0",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",174,"^9",7,"^:",174,"^;",11,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Returns the current node in `zloc`."],"^1=","^3H","^7","rewrite_clj/zip.cljc","^;",11,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",174,"^:H","^:N","^:",174,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Returns the current node in `zloc`."],"~$prefix",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",334,"^9",7,"^:",334,"^;",13,"^19",["^1:",["^:C",["^1:",[["^1;","~$s"]]]]],"^6","Return zipper with the current node in `zloc` prefixed with string `s`.\n   Operates on token node or a multi-line node, else exception is thrown.\n   When multi-line, first line is prefixed."],"^1=","^4J","^7","rewrite_clj/zip.cljc","^;",13,"^:D",["^1:",[["^1;","~$s"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",334,"^:H","^:N","^:",334,"^:K",2,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;","~$s"]]]]],"^6","Return zipper with the current node in `zloc` prefixed with string `s`.\n   Operates on token node or a multi-line node, else exception is thrown.\n   When multi-line, first line is prefixed."],"~$up",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",501,"^9",7,"^:",501,"^;",9,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Return zipper with location moved up to next non-whitespace/non-comment parent of current node in `zloc`, or `nil` if at the top."],"^1=","^2O","^7","rewrite_clj/zip.cljc","^;",9,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",501,"^:H",["^U",["^:N","^:J"]],"^:",501,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Return zipper with location moved up to next non-whitespace/non-comment parent of current node in `zloc`, or `nil` if at the top."],"~$insert-space-right",["^ ","^:A",null,"^5",["^ ","^:B","0.5.0","^7","rewrite_clj/zip.cljc","^;",43,"^:P",["^ ","^:G",false,"^:Q",2,"^:K",2,"^:D",[["^1;"],["^1;","~$n"]],"^19",["^1:",[["^1;"],["^1;","~$n"]]],"^:F",["^1:",[null,null]]],"^9",25,"^8",865,"^:",865,"^19",["^1:",["^:C",["^1:",[["^1;"],["^1;","~$n"]]]]],"^6","Return zipper with `n` space whitespace node inserted to the right of the current node in `zloc`, without moving location.\n   `n` defaults to 1."],"^:B","0.5.0","^1=","^4=","^7","rewrite_clj/zip.cljc","^;",43,"^:P",["^ ","^:G",false,"^:Q",2,"^:K",2,"^:D",[["^1;"],["^1;","~$n"]],"^19",["^1:",[["^1;"],["^1;","~$n"]]],"^:F",["^1:",[null,null]]],"^:D",[["^1;"],["^1;","~$n"]],"^:E",null,"^:Q",2,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^:R",[["^ ","^:Q",1,"^:G",false,"^:S","^:N"],["^ ","^:Q",2,"^:G",false,"^:S",["^U",[null,"^:T","^:N","^:U","^:J"]]]],"^8",865,"^:",865,"^:K",2,"^:L",true,"^19",["^1:",[["^1;"],["^1;","~$n"]]],"^6","Return zipper with `n` space whitespace node inserted to the right of the current node in `zloc`, without moving location.\n   `n` defaults to 1."],"~$insert-right",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",468,"^9",7,"^:",468,"^;",19,"^19",["^1:",["^:C",["^1:",[["^1;","^:["]]]]],"^6","Return zipper with `item` inserted to the right of the current node in `zloc`, without moving location.\n  Will insert a space if necessary."],"^1=","^4@","^7","rewrite_clj/zip.cljc","^;",19,"^:D",["^1:",[["^1;","^:["]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",468,"^:H",["^U",[null,"^:N"]],"^:",468,"^:K",2,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;","^:["]]]]],"^6","Return zipper with `item` inserted to the right of the current node in `zloc`, without moving location.\n  Will insert a space if necessary."],"~$skip-whitespace",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",844,"^9",7,"^:",844,"^;",22,"^19",["^1:",["^:C",["^1:",[["^1;"],["~$f","^1;"]]]]],"^6","Return zipper with location moved to first non-whitespace/non-comment starting from current node in `zloc`\n   and traversing by function `f`.\n\n   `f` defaults to [[rewrite-clj.zip/right]]","^:P",["^ ","^:G",false,"^:Q",2,"^:K",2,"^:D",[["^1;"],["~$f","^1;"]],"^19",["^1:",[["^1;"],["~$f","^1;"]]],"^:F",["^1:",[null,null]]]],"^1=","^36","^7","rewrite_clj/zip.cljc","^;",22,"^:P",["^ ","^:G",false,"^:Q",2,"^:K",2,"^:D",[["^1;"],["~$f","^1;"]],"^19",["^1:",[["^1;"],["~$f","^1;"]]],"^:F",["^1:",[null,null]]],"^:D",[["^1;"],["~$f","^1;"]],"^:E",null,"^:Q",2,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^:R",[["^ ","^:Q",1,"^:G",false,"^:S","^:N"],["^ ","^:Q",2,"^:G",false,"^:S",["^U",["^:N","^:J"]]]],"^8",844,"^:",844,"^:K",2,"^:L",true,"^19",["^1:",[["^1;"],["~$f","^1;"]]],"^6","Return zipper with location moved to first non-whitespace/non-comment starting from current node in `zloc`\n   and traversing by function `f`.\n\n   `f` defaults to [[rewrite-clj.zip/right]]"],"~$find-depth-first",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",379,"^9",7,"^:",379,"^;",23,"^19",["^1:",["^:C",["^1:",[["^1;","^:W"]]]]],"^6","Return `zloc` located to the first node satisfying predicate `p?` else `nil`.\n   Search is depth-first from the current node."],"^1=","^6I","^7","rewrite_clj/zip.cljc","^;",23,"^:D",["^1:",[["^1;","^:W"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",379,"^:H",["^U",["^:N","^:J"]],"^:",379,"^:K",2,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;","^:W"]]]]],"^6","Return `zloc` located to the first node satisfying predicate `p?` else `nil`.\n   Search is depth-first from the current node."],"~$leftmost?",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",532,"^9",7,"^:",532,"^;",16,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Return true if at leftmost non-whitespace/non-comment sibling node in `zloc`."],"^1=","^4R","^7","rewrite_clj/zip.cljc","^;",16,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",532,"^:H","^:Y","^:",532,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Return true if at leftmost non-whitespace/non-comment sibling node in `zloc`."],"~$remove*",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",1020,"^9",7,"^:",1020,"^;",14,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Raw version of [[remove]].\n\nReturns zipper with current node in `zloc` removed, with location at node that would have preceded\n  it in a depth-first walk.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes."],"^1=","^4E","^7","rewrite_clj/zip.cljc","^;",14,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",1020,"^:H",["^U",[null,"^:T","^:N","^:U","^:J"]],"^:",1020,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Raw version of [[remove]].\n\nReturns zipper with current node in `zloc` removed, with location at node that would have preceded\n  it in a depth-first walk.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes."],"~$remove-preserve-newline",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",572,"^9",7,"^:",572,"^;",30,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Same as [[remove]] but preserves newlines.\n   Specifically: will trim all whitespace - or whitespace up to first linebreak if present."],"^1=","^61","^7","rewrite_clj/zip.cljc","^;",30,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",572,"^:H",["^U",["^:N","^:J"]],"^:",572,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Same as [[remove]] but preserves newlines.\n   Specifically: will trim all whitespace - or whitespace up to first linebreak if present."],"~$subedit-node",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",688,"^9",7,"^:",688,"^;",19,"^19",["^1:",["^:C",["^1:",[["^1;","~$f"]]]]],"^6","Return zipper replacing current node in `zloc` with result of `f` applied to said node as an isolated sub-tree.\n   The resulting zipper will be located on the root of the modified sub-tree.\n   \n   See [docs on sub editing](/doc/01-user-guide.adoc#sub-editing)."],"^1=","^60","^7","rewrite_clj/zip.cljc","^;",19,"^:D",["^1:",[["^1;","~$f"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",688,"^:H",["^U",["^:T","^:N","^:U","^:J"]],"^:",688,"^:K",2,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;","~$f"]]]]],"^6","Return zipper replacing current node in `zloc` with result of `f` applied to said node as an isolated sub-tree.\n   The resulting zipper will be located on the root of the modified sub-tree.\n   \n   See [docs on sub editing](/doc/01-user-guide.adoc#sub-editing)."],"^:=",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",961,"^9",7,"^:",961,"^;",12,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Raw version of [[next]].\n\nReturns zipper with location at the next depth-first location in the hierarchy in `zloc`.\n  When reaching the end, returns a distinguished zipper detectable via [[end?]]. If already\n  at the end, stays there.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes."],"^1=","^53","^7","rewrite_clj/zip.cljc","^;",12,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",961,"^:H",["^U",[null,"^:T","^<6","^:N","^:U"]],"^:",961,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Raw version of [[next]].\n\nReturns zipper with location at the next depth-first location in the hierarchy in `zloc`.\n  When reaching the end, returns a distinguished zipper detectable via [[end?]]. If already\n  at the end, stays there.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes."],"~$root",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",194,"^9",7,"^:",194,"^;",11,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Zips all the way up `zloc` and returns the root node, reflecting any changes."],"^1=","^5Z","^7","rewrite_clj/zip.cljc","^;",11,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",194,"^:H","^:N","^:",194,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Zips all the way up `zloc` and returns the root node, reflecting any changes."],"~$map-vals",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",639,"^9",7,"^:",639,"^;",15,"^19",["^1:",["^:C",["^1:",[["~$f","^1;"]]]]],"^6","Returns `zloc` with function `f` applied to each value node of the current node.\n   Current node must be map node.\n\n  `zloc` location is unchanged.\n\n  `f` arg is zloc positioned at value node and should return:\n  - an updated zloc with zloc positioned at value node\n  - a falsey value to leave value node unchanged\n\n  Folks typically use [[rewrite-clj.zip/edit]] for `f`."],"^1=","^55","^7","rewrite_clj/zip.cljc","^;",15,"^:D",["^1:",[["~$f","^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",639,"^:H",["^U",[null,"^:N","^:J"]],"^:",639,"^:K",2,"^:L",true,"^19",["^1:",["^:C",["^1:",[["~$f","^1;"]]]]],"^6","Returns `zloc` with function `f` applied to each value node of the current node.\n   Current node must be map node.\n\n  `zloc` location is unchanged.\n\n  `f` arg is zloc positioned at value node and should return:\n  - an updated zloc with zloc positioned at value node\n  - a falsey value to leave value node unchanged\n\n  Folks typically use [[rewrite-clj.zip/edit]] for `f`."],"^14",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",516,"^9",7,"^:",516,"^;",11,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Return zipper with location moved to the next depth-first non-whitespace/non-comment node in `zloc`.\n   End can be detected with [[end?]], if already at end, stays there."],"^1=","^52","^7","rewrite_clj/zip.cljc","^;",11,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",516,"^:H",["^U",["^:T","^:N","^:U","^:J"]],"^:",516,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Return zipper with location moved to the next depth-first non-whitespace/non-comment node in `zloc`.\n   End can be detected with [[end?]], if already at end, stays there."],"~$find-next-value",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",422,"^9",7,"^:",422,"^;",22,"^19",["^1:",["^:C",["^1:",[["^1;","~$v"],["^1;","~$f","~$v"]]]]],"^6","Return `zloc` located to the next token node that `sexpr`esses to `v` else `nil`.\n   Search starts one movement `f` from the current location, and continues via `f`.\n\n   `v` can be a single value or a set. When `v` is a set matches on any value in set.\n\n   `f` defaults to [[rewrite-clj.zip/right]] in short form call.\n\n  See docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances).","^:P",["^ ","^:G",false,"^:Q",3,"^:K",3,"^:D",[["^1;","~$v"],["^1;","~$f","~$v"]],"^19",["^1:",[["^1;","~$v"],["^1;","~$f","~$v"]]],"^:F",["^1:",[null,null]]]],"^1=","^4[","^7","rewrite_clj/zip.cljc","^;",22,"^:P",["^ ","^:G",false,"^:Q",3,"^:K",3,"^:D",[["^1;","~$v"],["^1;","~$f","~$v"]],"^19",["^1:",[["^1;","~$v"],["^1;","~$f","~$v"]]],"^:F",["^1:",[null,null]]],"^:D",[["^1;","~$v"],["^1;","~$f","~$v"]],"^:E",null,"^:Q",3,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^:R",[["^ ","^:Q",2,"^:G",false,"^:S","^:N"],["^ ","^:Q",3,"^:G",false,"^:S",["^U",["^:N","^:J"]]]],"^8",422,"^:",422,"^:K",3,"^:L",true,"^19",["^1:",[["^1;","~$v"],["^1;","~$f","~$v"]]],"^6","Return `zloc` located to the next token node that `sexpr`esses to `v` else `nil`.\n   Search starts one movement `f` from the current location, and continues via `f`.\n\n   `v` can be a single value or a set. When `v` is a set matches on any value in set.\n\n   `f` defaults to [[rewrite-clj.zip/right]] in short form call.\n\n  See docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances)."],"^15",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",583,"^9",7,"^:",583,"^;",12,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Returns true if current node in `zloc` is a list."],"^1=","^4V","^7","rewrite_clj/zip.cljc","^;",12,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",583,"^:H","^:Y","^:",583,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Returns true if current node in `zloc` is a list."],"~$insert-newline-right",["^ ","^:A",null,"^5",["^ ","^:B","0.5.0","^7","rewrite_clj/zip.cljc","^;",45,"^:P",["^ ","^:G",false,"^:Q",2,"^:K",2,"^:D",[["^1;"],["^1;","~$n"]],"^19",["^1:",[["^1;"],["^1;","~$n"]]],"^:F",["^1:",[null,null]]],"^9",25,"^8",879,"^:",879,"^19",["^1:",["^:C",["^1:",[["^1;"],["^1;","~$n"]]]]],"^6","Return zipper with `n` newlines node inserted to the right of the current node in `zloc`, without moving location.\n   `n` defaults to 1."],"^:B","0.5.0","^1=","^4Y","^7","rewrite_clj/zip.cljc","^;",45,"^:P",["^ ","^:G",false,"^:Q",2,"^:K",2,"^:D",[["^1;"],["^1;","~$n"]],"^19",["^1:",[["^1;"],["^1;","~$n"]]],"^:F",["^1:",[null,null]]],"^:D",[["^1;"],["^1;","~$n"]],"^:E",null,"^:Q",2,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^:R",[["^ ","^:Q",1,"^:G",false,"^:S","^:N"],["^ ","^:Q",2,"^:G",false,"^:S",["^U",["^:T","^:N","^:U","^:J"]]]],"^8",879,"^:",879,"^:K",2,"^:L",true,"^19",["^1:",[["^1;"],["^1;","~$n"]]],"^6","Return zipper with `n` newlines node inserted to the right of the current node in `zloc`, without moving location.\n   `n` defaults to 1."],"~$edn",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",216,"^9",7,"^:",216,"^;",10,"^19",["^1:",["^:C",["^1:",[["^<0"],["^<0","^<1"]]]]],"^6","Create and return zipper from Clojure/ClojureScript/EDN `node` (likely parsed by [[rewrite-clj.parse]]),\n  and move to the first non-whitespace/non-comment child. If node is not forms node, is wrapped in forms node\n  for a consistent root.\n\n  Optional `opts` can specify:\n  - `:track-position?` set to `true` to enable ones-based row/column tracking, see [docs on position tracking](/doc/01-user-guide.adoc#position-tracking).\n  - `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)","^:P",["^ ","^:G",false,"^:Q",2,"^:K",2,"^:D",[["^<0"],["^<0","^<1"]],"^19",["^1:",[["^<0"],["^<0","^<1"]]],"^:F",["^1:",[null,null]]]],"^1=","^51","^7","rewrite_clj/zip.cljc","^;",10,"^:P",["^ ","^:G",false,"^:Q",2,"^:K",2,"^:D",[["^<0"],["^<0","^<1"]],"^19",["^1:",[["^<0"],["^<0","^<1"]]],"^:F",["^1:",[null,null]]],"^:D",[["^<0"],["^<0","^<1"]],"^:E",null,"^:Q",2,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^:R",[["^ ","^:Q",1,"^:G",false,"^:S","^:N"],["^ ","^:Q",2,"^:G",false,"^:S",["^U",["^:T","^:N","^:U","^:J"]]]],"^8",216,"^:",216,"^:K",2,"^:L",true,"^19",["^1:",[["^<0"],["^<0","^<1"]]],"^6","Create and return zipper from Clojure/ClojureScript/EDN `node` (likely parsed by [[rewrite-clj.parse]]),\n  and move to the first non-whitespace/non-comment child. If node is not forms node, is wrapped in forms node\n  for a consistent root.\n\n  Optional `opts` can specify:\n  - `:track-position?` set to `true` to enable ones-based row/column tracking, see [docs on position tracking](/doc/01-user-guide.adoc#position-tracking).\n  - `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)"],"^16",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",665,"^9",7,"^:",665,"^;",12,"^19",["^1:",["^:C",["^1:",[["^1;","~$k","~$v"]]]]],"^6","Returns `zloc` with current node's `k` set to value `v`.\n\n  `zloc` location is unchanged.\n\n  `k` should be:\n  - a key for maps\n  - a zero-based index for sequences, an exception is thrown if index is out of bounds\n\n  NOTE: `k` will be compared against resolved keywords in maps.\n  See docs for sexpr behavior on [namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)."],"^1=","^5>","^7","rewrite_clj/zip.cljc","^;",12,"^:D",["^1:",[["^1;","~$k","~$v"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",665,"^:H",["^U",[null,"^:N","^:J"]],"^:",665,"^:K",3,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;","~$k","~$v"]]]]],"^6","Returns `zloc` with current node's `k` set to value `v`.\n\n  `zloc` location is unchanged.\n\n  `k` should be:\n  - a key for maps\n  - a zero-based index for sequences, an exception is thrown if index is out of bounds\n\n  NOTE: `k` will be compared against resolved keywords in maps.\n  See docs for sexpr behavior on [namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)."],"~$length",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",247,"^9",7,"^:",247,"^;",13,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Return length of printable [[string]] of current node in `zloc`."],"^1=","^5;","^7","rewrite_clj/zip.cljc","^;",13,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",247,"^:H",["^U",["^:N","~$number"]],"^:",247,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Return length of printable [[string]] of current node in `zloc`."],"~$prev*",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",972,"^9",7,"^:",972,"^;",12,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Raw version of [[prev]].\n\nReturns zipper with location at the previous depth-first location in the hierarchy in `zloc`.\n  If already at the root, returns nil.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes."],"^1=","^4A","^7","rewrite_clj/zip.cljc","^;",12,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",972,"^:H",["^U",[null,"^:T","^:N","^:U","^:J"]],"^:",972,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Raw version of [[prev]].\n\nReturns zipper with location at the previous depth-first location in the hierarchy in `zloc`.\n  If already at the root, returns nil.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes."],"~$insert-left",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",474,"^9",7,"^:",474,"^;",18,"^19",["^1:",["^:C",["^1:",[["^1;","^:["]]]]],"^6","Return zipper with `item` inserted to the left of the current node in `zloc`, without moving location.\n  Will insert a space if necessary."],"^1=","^5<","^7","rewrite_clj/zip.cljc","^;",18,"^:D",["^1:",[["^1;","^:["]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",474,"^:H",["^U",[null,"^:N"]],"^:",474,"^:K",2,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;","^:["]]]]],"^6","Return zipper with `item` inserted to the left of the current node in `zloc`, without moving location.\n  Will insert a space if necessary."],"~$prev",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",511,"^9",7,"^:",511,"^;",11,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Return zipper with location moved to the previous depth-first non-whitespace/non-comment node in `zloc`. If already at root, returns nil."],"^1=","^57","^7","rewrite_clj/zip.cljc","^;",11,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",511,"^:H",["^U",["^:N","^:J"]],"^:",511,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Return zipper with location moved to the previous depth-first non-whitespace/non-comment node in `zloc`. If already at root, returns nil."],"~$insert-right*",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",1040,"^9",7,"^:",1040,"^;",20,"^19",["^1:",["^:C",["^1:",[["^1;","^:["]]]]],"^6","Raw version of [[insert-right]].\n\nReturns zipper with `item` inserted as the right sibling of the current node in `zloc`,\n  without moving location.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes."],"^1=","^47","^7","rewrite_clj/zip.cljc","^;",20,"^:D",["^1:",[["^1;","^:["]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",1040,"^:H",["^U",["^:T","^:N","^:U","^:J"]],"^:",1040,"^:K",2,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;","^:["]]]]],"^6","Raw version of [[insert-right]].\n\nReturns zipper with `item` inserted as the right sibling of the current node in `zloc`,\n  without moving location.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes."],"~$of-string",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",258,"^9",7,"^:",258,"^;",16,"^19",["^1:",["^:C",["^1:",[["~$s"],["~$s","^<1"]]]]],"^6","Create and return zipper from all forms in Clojure/ClojureScript/EDN string `s`.\n\n  Optional `opts` can specify:\n  - `:track-position?` set to `true` to enable ones-based row/column tracking, see [docs on position tracking](/doc/01-user-guide.adoc#position-tracking).\n  - `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)","^:P",["^ ","^:G",false,"^:Q",2,"^:K",2,"^:D",[["~$s"],["~$s","^<1"]],"^19",["^1:",[["~$s"],["~$s","^<1"]]],"^:F",["^1:",[null,null]]]],"^1=","^46","^7","rewrite_clj/zip.cljc","^;",16,"^:P",["^ ","^:G",false,"^:Q",2,"^:K",2,"^:D",[["~$s"],["~$s","^<1"]],"^19",["^1:",[["~$s"],["~$s","^<1"]]],"^:F",["^1:",[null,null]]],"^:D",[["~$s"],["~$s","^<1"]],"^:E",null,"^:Q",2,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^:R",[["^ ","^:Q",1,"^:G",false,"^:S","^:N"],["^ ","^:Q",2,"^:G",false,"^:S",["^U",["^:T","^:N","^:U","^:J"]]]],"^8",258,"^:",258,"^:K",2,"^:L",true,"^19",["^1:",[["~$s"],["~$s","^<1"]]],"^6","Create and return zipper from all forms in Clojure/ClojureScript/EDN string `s`.\n\n  Optional `opts` can specify:\n  - `:track-position?` set to `true` to enable ones-based row/column tracking, see [docs on position tracking](/doc/01-user-guide.adoc#position-tracking).\n  - `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)"],"~$right",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",496,"^9",7,"^:",496,"^;",12,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Return zipper with location moved right to next non-whitespace/non-comment sibling of current node in `zloc`."],"^1=","^5N","^7","rewrite_clj/zip.cljc","^;",12,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",496,"^:H",["^U",["^:N","^:J"]],"^:",496,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Return zipper with location moved right to next non-whitespace/non-comment sibling of current node in `zloc`."],"~$append-child*",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",1060,"^9",7,"^:",1060,"^;",20,"^19",["^1:",["^:C",["^1:",[["^1;","^:["]]]]],"^6","Raw version of [[append-child]].\n\nReturns zipper with `item` inserted as the rightmost child of the current node in `zloc`,\n  without moving.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes."],"^1=","^40","^7","rewrite_clj/zip.cljc","^;",20,"^:D",["^1:",[["^1;","^:["]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",1060,"^:H",["^U",["^:T","^:N","^:U","^:J"]],"^:",1060,"^:K",2,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;","^:["]]]]],"^6","Raw version of [[append-child]].\n\nReturns zipper with `item` inserted as the rightmost child of the current node in `zloc`,\n  without moving.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes."],"~$whitespace-or-comment?",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",833,"^9",7,"^:",833,"^;",29,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Returns true when current node in `zloc` is whitespace or a comment."],"^1=","^2U","^7","rewrite_clj/zip.cljc","^;",29,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",833,"^:H",["^U",["^:Y","^:J"]],"^:",833,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Returns true when current node in `zloc` is whitespace or a comment."],"~$position",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",179,"^9",7,"^:",179,"^;",15,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Returns the ones-based `[row col]` of the start of the current node in `zloc`.\n   \n  Throws if `zloc` was not created with [position tracking](/doc/01-user-guide.adoc#position-tracking)."],"^1=","^3U","^7","rewrite_clj/zip.cljc","^;",15,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",179,"^:H","^:N","^:",179,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Returns the ones-based `[row col]` of the start of the current node in `zloc`.\n   \n  Throws if `zloc` was not created with [position tracking](/doc/01-user-guide.adoc#position-tracking)."],"~$reapply-context",["^ ","^:A",null,"^5",["^ ","^7","rewrite_clj/zip.cljc","^8",348,"^9",7,"^:",348,"^;",22,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Returns `zloc` with namespaced map sexpr context to all symbols and keywords reapplied from current location downward.\n\n  Keywords and symbols:\n  * that are keys in a namespaced map will have namespaced map context applied\n  * otherwise will have any namespaced map context removed\n\n  You should only need to use this function if:\n  * you care about `sexpr` on keywords and symbols\n  * and you are moving keywords and symbols from a namespaced map to some other location."],"^1=","^4K","^7","rewrite_clj/zip.cljc","^;",22,"^:D",["^1:",[["^1;"]]],"^:E",null,"^:F",["^1:",[null,null]],"^9",1,"^:G",false,"^8",348,"^:H",["^U",["^:T","^:N","^:U","^:J"]],"^:",348,"^:K",1,"^:L",true,"^19",["^1:",["^:C",["^1:",[["^1;"]]]]],"^6","Returns `zloc` with namespaced map sexpr context to all symbols and keywords reapplied from current location downward.\n\n  Keywords and symbols:\n  * that are keys in a namespaced map will have namespaced map context applied\n  * otherwise will have any namespaced map context removed\n\n  You should only need to use this function if:\n  * you care about `sexpr` on keywords and symbols\n  * and you are moving keywords and symbols from a namespaced map to some other location."]],"^21",["^ ","^1M","^1M","^1@","^1@","^1P","^1P"],"^28",["^ ","^20",["^U",[]],"^21",["^U",[]]],"^29",["^ "],"^2:",["^1Q","^1P","^1O","^1Z","^1Y","^1V","^1U","^1N","^1R","^1T","^1L","^1X","^1M","^1W","^1S"]],"^1?","^1@","~:ns-specs",["^ "],"~:ns-spec-vars",["^U",[]],"~:compiler-options",["^78",[["^=0","~:static-fns"],true,["^=0","~:shadow-tweaks"],null,["^=0","~:source-map-inline"],null,["^=0","~:elide-asserts"],false,["^=0","~:optimize-constants"],null,["^=0","^2?"],null,["^=0","~:external-config"],null,["^=0","~:tooling-config"],null,["^=0","~:emit-constants"],null,["^=0","~:load-tests"],null,["^=0","~:form-size-threshold"],null,["^=0","~:global-goog-object&array"],null,["^=0","~:data-readers"],null,["^=0","~:infer-externs"],"~:auto",["^=0","^2A"],null,["~:js-options","~:js-provider"],"~:shadow",["~:mode"],"~:dev",["^=0","~:fn-invoke-direct"],null,["^=0","~:source-map"],"/dev/null"]]]