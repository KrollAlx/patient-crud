["^ ","~:output",["^ ","~:js","goog.provide('zprint.comment');\n/**\n * Produce a blank string of desired size.\n */\nzprint.comment.blanks = (function zprint$comment$blanks(n){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.str,cljs.core.repeat.cljs$core$IFn$_invoke$arity$2(n,\" \"));\n});\n/**\n * Do split for newlines, instead of using regular expressions.\n */\nzprint.comment.split_lf = (function zprint$comment$split_lf(s){\nvar input = s;\nvar out = cljs.core.PersistentVector.EMPTY;\nwhile(true){\nif(cljs.core.not(input)){\nreturn out;\n} else {\nvar next_lf = clojure.string.index_of.cljs$core$IFn$_invoke$arity$2(input,\"\\n\");\nvar chunk = (cljs.core.truth_(next_lf)?cljs.core.subs.cljs$core$IFn$_invoke$arity$3(input,(0),next_lf):input);\nvar G__42343 = (cljs.core.truth_(next_lf)?cljs.core.subs.cljs$core$IFn$_invoke$arity$2(input,(next_lf + (1))):null);\nvar G__42344 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,chunk);\ninput = G__42343;\nout = G__42344;\ncontinue;\n}\nbreak;\n}\n});\n/**\n * Given a tag into which you can go down from rewrite-clj, which must be\n *   a collection of some kind, return the size the l-str.  All of the tag\n *   values into which you can go down must be in this list for indent-before\n *   to work correctly.  It uses these values when it steps up out of one of\n *   these things to see how big the thing would have been if it showed up\n *   as characters.\n */\nzprint.comment.tag_l_size = (function zprint$comment$tag_l_size(t){\nvar G__41647 = t;\nvar G__41647__$1 = (((G__41647 instanceof cljs.core.Keyword))?G__41647.fqn:null);\nswitch (G__41647__$1) {\ncase \"list\":\nreturn (1);\n\nbreak;\ncase \"vector\":\nreturn (1);\n\nbreak;\ncase \"set\":\nreturn (2);\n\nbreak;\ncase \"map\":\nreturn (1);\n\nbreak;\ncase \"uneval\":\nreturn (2);\n\nbreak;\ncase \"reader-macro\":\nreturn (1);\n\nbreak;\ncase \"meta\":\nreturn (1);\n\nbreak;\ncase \"quote\":\nreturn (1);\n\nbreak;\ncase \"syntax-quote\":\nreturn (1);\n\nbreak;\ncase \"fn\":\nreturn (2);\n\nbreak;\ncase \"unquote\":\nreturn (1);\n\nbreak;\ncase \"deref\":\nreturn (1);\n\nbreak;\ncase \"namespaced-map\":\nreturn (1);\n\nbreak;\ndefault:\nreturn (0);\n\n}\n});\n/**\n * Take a zloc and move left if possible, or move up if necessary.\n *   Return a vector with [up-size new-zloc]\n */\nzprint.comment.left_or_up = (function zprint$comment$left_or_up(zloc){\nvar ploc = zloc;\nvar total_up = (0);\nwhile(true){\nvar next_left = rewrite_clj.zip.left_STAR_(ploc);\nif(cljs.core.truth_(next_left)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [total_up,next_left], null);\n} else {\nvar moving_up = rewrite_clj.zip.up_STAR_(ploc);\nvar up_tag = (cljs.core.truth_(moving_up)?rewrite_clj.zip.tag(moving_up):null);\nvar up_size = zprint.comment.tag_l_size(up_tag);\nif(cljs.core.not(moving_up)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [total_up,null], null);\n} else {\nvar G__42351 = moving_up;\nvar G__42352 = (total_up + up_size);\nploc = G__42351;\ntotal_up = G__42352;\ncontinue;\n}\n}\nbreak;\n}\n});\n/**\n * Given a string, return the number of characters to the right\n *   of any newlines in the string.  Will return nil if no newlines\n *   in the string.\n */\nzprint.comment.length_after_newline = (function zprint$comment$length_after_newline(s){\nvar nl_split = clojure.string.split.cljs$core$IFn$_invoke$arity$2([cljs.core.str.cljs$core$IFn$_invoke$arity$1(s),\" \"].join(''),/\\n/);\nvar nl_num = (cljs.core.count(nl_split) - (1));\nif((nl_num === (0))){\nreturn null;\n} else {\nreturn (cljs.core.count(cljs.core.last(nl_split)) - (1));\n}\n});\n/**\n * Given a zloc, find the amount of printing space before it on its\n *   current line.\n */\nzprint.comment.length_before = (function zprint$comment$length_before(zloc){\nvar vec__41656 = zprint.comment.left_or_up(zloc);\nvar up_size = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41656,(0),null);\nvar next_zloc = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41656,(1),null);\nvar ploc = next_zloc;\nvar indent_before = up_size;\nwhile(true){\nif(cljs.core.not(ploc)){\nreturn indent_before;\n} else {\nvar zstr = (cljs.core.truth_(ploc)?(zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(ploc) : zprint.zfns.zstring.call(null,ploc)):\"\");\nvar length_right_of_newline = zprint.comment.length_after_newline(zstr);\nvar vec__41670 = zprint.comment.left_or_up(ploc);\nvar up_size__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41670,(0),null);\nvar next_zloc__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41670,(1),null);\nif(cljs.core.truth_(length_right_of_newline)){\nreturn (length_right_of_newline + indent_before);\n} else {\nvar G__42354 = next_zloc__$1;\nvar G__42355 = ((indent_before + cljs.core.count(zstr)) + up_size__$1);\nploc = G__42354;\nindent_before = G__42355;\ncontinue;\n}\n}\nbreak;\n}\n});\n/**\n * If this is an inline comment, returns a vector with the amount\n *   of space that was between this and the previous element and the\n *   starting column of this inline comment.  That means that if we\n *   go left, we get something other than whitespace before a newline.\n *   If we get only whitespace before a newline, then this is considered\n *   an inline comment if the comment at the end of the previous line\n *   was an inline comment and we were aligned with that comment.\n *   Assumes zloc is a comment.\n */\nzprint.comment.inlinecomment_QMARK_ = (function zprint$comment$inlinecomment_QMARK_(zloc){\nvar nloc = rewrite_clj.zip.left_STAR_(zloc);\nvar spaces = (0);\nvar passed_nl_QMARK_ = false;\nwhile(true){\nvar vec__41689 = (function (){var tnloc = (zprint.zfns.ztag.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.ztag.cljs$core$IFn$_invoke$arity$1(nloc) : zprint.zfns.ztag.call(null,nloc));\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(tnloc,new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483))){\nvar nstr = (zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1 ? zprint.zfns.zstring.cljs$core$IFn$_invoke$arity$1(nloc) : zprint.zfns.zstring.call(null,nloc));\nvar trim_nstr = clojure.string.trimr(nstr);\nif((((trim_nstr).length) > (0))){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"comma\",\"comma\",1699024745),(spaces + (cljs.core.count(nstr) - ((trim_nstr).length)))], null);\n} else {\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483),spaces], null);\n}\n} else {\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [tnloc,spaces], null);\n}\n})();\nvar tnloc = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41689,(0),null);\nvar spaces__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41689,(1),null);\nif((tnloc == null)){\nreturn null;\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(tnloc,new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323))){\nvar G__42359 = rewrite_clj.zip.left_STAR_(nloc);\nvar G__42360 = spaces__$1;\nvar G__42361 = true;\nnloc = G__42359;\nspaces = G__42360;\npassed_nl_QMARK_ = G__42361;\ncontinue;\n} else {\nif(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(tnloc,new cljs.core.Keyword(null,\"comment\",\"comment\",532206069))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(tnloc,new cljs.core.Keyword(null,\"comment-inline\",\"comment-inline\",712944405))))){\nif(cljs.core.truth_((zprint.comment.inlinecomment_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.comment.inlinecomment_QMARK_.cljs$core$IFn$_invoke$arity$1(nloc) : zprint.comment.inlinecomment_QMARK_.call(null,nloc)))){\nvar nloc_length_before = zprint.comment.length_before(nloc);\nvar zloc_length_before = zprint.comment.length_before(zloc);\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(nloc_length_before,zloc_length_before)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [spaces__$1,zloc_length_before], null);\n} else {\nreturn null;\n}\n} else {\nreturn null;\n}\n} else {\nif(cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(tnloc,new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483))){\nif(cljs.core.truth_(passed_nl_QMARK_)){\nreturn null;\n} else {\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [spaces__$1,zprint.comment.length_before(zloc)], null);\n}\n} else {\nvar G__42364 = rewrite_clj.zip.left_STAR_(nloc);\nvar G__42365 = (rewrite_clj.zip.length(nloc) + spaces__$1);\nvar G__42366 = passed_nl_QMARK_;\nnloc = G__42364;\nspaces = G__42365;\npassed_nl_QMARK_ = G__42366;\ncontinue;\n\n}\n}\n}\n}\nbreak;\n}\n});\n/**\n * Take a string and an index, and look for the last space prior to the\n *   index. If we wanted to tie ourselves to 1.8, we could use \n *   clojure.string/last-index-of, but we don't.  However, we use similar\n *   conventions, i.e., if no space is found, return nil, and if the index\n *   is a space return that value, and accept any from-index, including one\n *   larger than the length of the string.\n */\nzprint.comment.last_space = (function zprint$comment$last_space(s,from_index){\nvar from_index__$1 = (function (){var x__5133__auto__ = (cljs.core.count(s) - (1));\nvar y__5134__auto__ = from_index;\nreturn ((x__5133__auto__ < y__5134__auto__) ? x__5133__auto__ : y__5134__auto__);\n})();\nvar rev_seq = cljs.core.reverse(cljs.core.take.cljs$core$IFn$_invoke$arity$2((from_index__$1 + (1)),s));\nvar seq_after_space = cljs.core.take_while.cljs$core$IFn$_invoke$arity$2((function (p1__41701_SHARP_){\nreturn cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(p1__41701_SHARP_,\" \");\n}),rev_seq);\nvar space_index = (from_index__$1 - cljs.core.count(seq_after_space));\nif((space_index < (0))){\nreturn null;\n} else {\nreturn space_index;\n}\n});\n/**\n * Take a string and an index, and look for the next space *after* the\n *   index. If no space is found, return nil. Accept any from-index, \n *   including one larger than the length of the string.\n */\nzprint.comment.next_space = (function zprint$comment$next_space(s,from_index){\nvar from_index__$1 = (from_index + (1));\nif((from_index__$1 < cljs.core.count(s))){\nvar seq_after_space = cljs.core.take_while.cljs$core$IFn$_invoke$arity$2((function (p1__41707_SHARP_){\nreturn cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(p1__41707_SHARP_,\" \");\n}),cljs.core.drop.cljs$core$IFn$_invoke$arity$2(from_index__$1,cljs.core.seq(s)));\nvar space_index = (from_index__$1 + cljs.core.count(seq_after_space));\nif((space_index >= cljs.core.count(s))){\nreturn null;\n} else {\nreturn space_index;\n}\n} else {\nreturn null;\n}\n});\n/**\n * If this is a comment, and it is too long, word wrap it to the right width.\n *   Note that top level comments may well end with a newline, so remove it\n *   and reapply it at the end if that is the case.\n */\nzprint.comment.wrap_comment = (function zprint$comment$wrap_comment(width,p__41713,start){\nvar vec__41714 = p__41713;\nvar s = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41714,(0),null);\nvar color = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41714,(1),null);\nvar stype = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41714,(2),null);\nvar element = vec__41714;\nif((!(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(stype,new cljs.core.Keyword(null,\"comment\",\"comment\",532206069))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(stype,new cljs.core.Keyword(null,\"comment-inline\",\"comment-inline\",712944405))))))){\nreturn element;\n} else {\nvar comment_width = (width - start);\nvar semi_str = cljs.core.re_find(/;*/,s);\nvar rest_str = cljs.core.subs.cljs$core$IFn$_invoke$arity$2(s,cljs.core.count(semi_str));\nvar space_str = cljs.core.re_find(/ */,rest_str);\nvar rest_str__$1 = cljs.core.subs.cljs$core$IFn$_invoke$arity$2(rest_str,cljs.core.count(space_str));\nvar newline_QMARK_ = cljs.core.re_find(/\\n$/,s);\nvar comment_width__$1 = ((comment_width - cljs.core.count(semi_str)) - cljs.core.count(space_str));\nvar comment_str = rest_str__$1;\nvar out = cljs.core.transient$(cljs.core.PersistentVector.EMPTY);\nwhile(true){\nif(cljs.core.empty_QMARK_(comment_str)){\nif((cljs.core.count(out) === (0))){\nif(cljs.core.truth_(newline_QMARK_)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [semi_str,color,stype], null),new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"\\n\",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125),(38)], null)], null);\n} else {\nreturn new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [semi_str,color,stype], null)], null);\n}\n} else {\nreturn cljs.core.persistent_BANG_((cljs.core.truth_(newline_QMARK_)?cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(out,new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"\\n\",new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125),(39)], null)):out));\n}\n} else {\nvar last_space_index = (((((comment_str).length) <= comment_width__$1))?(((comment_str).length) - (1)):(((comment_width__$1 <= (0)))?(function (){var or__5045__auto__ = zprint.comment.next_space(comment_str,(0));\nif(cljs.core.truth_(or__5045__auto__)){\nreturn or__5045__auto__;\n} else {\nreturn (((comment_str).length) - (1));\n}\n})():(function (){var or__5045__auto__ = zprint.comment.last_space(comment_str,comment_width__$1);\nif(cljs.core.truth_(or__5045__auto__)){\nreturn or__5045__auto__;\n} else {\nvar or__5045__auto____$1 = zprint.comment.next_space(comment_str,comment_width__$1);\nif(cljs.core.truth_(or__5045__auto____$1)){\nreturn or__5045__auto____$1;\n} else {\nreturn (((comment_str).length) - (1));\n}\n}\n})()));\nvar next_comment = clojure.string.trimr(cljs.core.subs.cljs$core$IFn$_invoke$arity$3(comment_str,(0),(last_space_index + (1))));\nvar G__42385 = cljs.core.subs.cljs$core$IFn$_invoke$arity$2(comment_str,(last_space_index + (1)));\nvar G__42386 = (((cljs.core.count(out) === (0)))?cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(out,new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[cljs.core.str.cljs$core$IFn$_invoke$arity$1(semi_str),cljs.core.str.cljs$core$IFn$_invoke$arity$1(space_str),next_comment].join(''),color,stype], null)):cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(out,new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.comment.blanks(start))].join(''),new cljs.core.Keyword(null,\"none\",\"none\",1333468478),new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125),(40)], null)),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[cljs.core.str.cljs$core$IFn$_invoke$arity$1(semi_str),cljs.core.str.cljs$core$IFn$_invoke$arity$1(space_str),next_comment].join(''),color,new cljs.core.Keyword(null,\"comment-wrap\",\"comment-wrap\",720664128)], null)));\ncomment_str = G__42385;\nout = G__42386;\ncontinue;\n}\nbreak;\n}\n}\n});\n/**\n * Takes the start of this vector and the vector itself.\n */\nzprint.comment.loc_vec = (function zprint$comment$loc_vec(start,p__41735){\nvar vec__41737 = p__41735;\nvar s = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41737,(0),null);\nvar split = zprint.comment.split_lf(s);\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.count(split),(1))){\nreturn (start + cljs.core.count(s));\n} else {\nreturn cljs.core.count(cljs.core.last(split));\n}\n});\n/**\n * Take a style-vec and produce a style-loc-vec with the starting column\n *   of each element in the style-vec. Accepts a beginning indent.\n */\nzprint.comment.style_loc_vec = (function zprint$comment$style_loc_vec(indent,style_vec){\nreturn cljs.core.butlast(cljs.core.reductions.cljs$core$IFn$_invoke$arity$3(zprint.comment.loc_vec,indent,style_vec));\n});\n/**\n * Take a transient output vector and a vector and lift any style-vec elements\n *   out of the input vector.\n */\nzprint.comment.lift_vec = (function zprint$comment$lift_vec(out_vec,element){\nif(typeof cljs.core.first(element) === 'string'){\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out_vec,element);\n} else {\nvar element_vec = element;\nvar out = out_vec;\nwhile(true){\nif(cljs.core.not(element_vec)){\nreturn out;\n} else {\nvar G__42390 = cljs.core.next(element_vec);\nvar G__42391 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,cljs.core.first(element_vec));\nelement_vec = G__42390;\nout = G__42391;\ncontinue;\n}\nbreak;\n}\n}\n});\n/**\n * Take a style-vec [[s color type] [s color type] [[s color type]\n *   [s color type]] [s color type] ...] and lift out the inner vectors.\n */\nzprint.comment.lift_style_vec = (function zprint$comment$lift_style_vec(style_vec){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(zprint.comment.lift_vec,cljs.core.PersistentVector.EMPTY,style_vec);\n});\n/**\n * Take the final output style-vec, and wrap any comments which run over\n *   the width. Looking for \n */\nzprint.comment.fzprint_wrap_comments = (function zprint$comment$fzprint_wrap_comments(p__41755,style_vec){\nvar map__41756 = p__41755;\nvar map__41756__$1 = cljs.core.__destructure_map(map__41756);\nvar options = map__41756__$1;\nvar width = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__41756__$1,new cljs.core.Keyword(null,\"width\",\"width\",-384071477));\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-wrap-comments: indent:\",new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125).cljs$core$IFn$_invoke$arity$1(options)], 0));\n} else {\n}\n\nvar start_col = zprint.comment.style_loc_vec((function (){var or__5045__auto__ = new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125).cljs$core$IFn$_invoke$arity$1(options);\nif(cljs.core.truth_(or__5045__auto__)){\nreturn or__5045__auto__;\n} else {\nreturn (0);\n}\n})(),style_vec);\nvar _ = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-wrap-comments: style-vec:\",cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([style_vec], 0))], 0)):null);\nvar ___$1 = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-wrap-comments: start-col:\",start_col], 0)):null);\nvar wrap_style_vec = cljs.core.mapv.cljs$core$IFn$_invoke$arity$3(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(zprint.comment.wrap_comment,width),style_vec,start_col);\nvar ___$2 = (cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),\"fzprint-wrap-comments: wrap:\",cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([style_vec], 0))], 0)):null);\nvar out_style_vec = zprint.comment.lift_style_vec(wrap_style_vec);\nreturn out_style_vec;\n});\n/**\n * Find a the first element of this type working from the end of a \n *   style-vec.  Return the index of the element.\n */\nzprint.comment.find_element_from_end = (function zprint$comment$find_element_from_end(element_pred_QMARK_,style_vec){\nvar index = (cljs.core.count(style_vec) - (1));\nwhile(true){\nif((index < (0))){\nreturn null;\n} else {\nvar vec__41768 = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(style_vec,index);\nvar _ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41768,(0),null);\nvar ___$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41768,(1),null);\nvar e = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41768,(2),null);\nif(cljs.core.truth_((element_pred_QMARK_.cljs$core$IFn$_invoke$arity$1 ? element_pred_QMARK_.cljs$core$IFn$_invoke$arity$1(e) : element_pred_QMARK_.call(null,e)))){\nreturn index;\n} else {\nvar G__42397 = (index - (1));\nindex = G__42397;\ncontinue;\n}\n}\nbreak;\n}\n});\n/**\n * Given a style-vec, how big is it in actual characters.  This doesn't\n *   handle newlines.\n */\nzprint.comment.line_size = (function zprint$comment$line_size(style_vec){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core._PLUS_,cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(zprint.comment.loc_vec,(0)),style_vec));\n});\n/**\n * Given a style-vec, whose last element in a comment, find the amount\n *   of space before that comment on the line.\n */\nzprint.comment.space_before_comment = (function zprint$comment$space_before_comment(style_vec){\nvar indent_index = zprint.comment.find_element_from_end((function (p1__41771_SHARP_){\nreturn ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(p1__41771_SHARP_,new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(p1__41771_SHARP_,new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323))));\n}),style_vec);\nvar this_line_vec = (cljs.core.truth_(indent_index)?cljs.core.nthnext(style_vec,indent_index):style_vec);\nreturn zprint.comment.line_size(cljs.core.butlast(this_line_vec));\n});\n/**\n * Try to bring inline comments back onto the line on which they belong.\n */\nzprint.comment.fzprint_inline_comments = (function zprint$comment$fzprint_inline_comments(p__41786,style_vec){\nvar map__41787 = p__41786;\nvar map__41787__$1 = cljs.core.__destructure_map(map__41787);\nvar options = map__41787__$1;\nvar width = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__41787__$1,new cljs.core.Keyword(null,\"width\",\"width\",-384071477));\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-inline-comments:\",style_vec], 0))], 0));\n} else {\n}\n\nvar cvec = style_vec;\nvar last_out = new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [\"\",null,null], null);\nvar out = cljs.core.PersistentVector.EMPTY;\nwhile(true){\nif(cljs.core.not(cvec)){\nreturn out;\n} else {\nvar vec__41821 = cljs.core.first(cvec);\nvar s = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41821,(0),null);\nvar c = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41821,(1),null);\nvar e = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41821,(2),null);\nvar element = vec__41821;\nvar vec__41824 = cljs.core.second(cvec);\nvar _ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41824,(0),null);\nvar ___$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41824,(1),null);\nvar ne = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41824,(2),null);\nvar nn = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41824,(3),null);\nvar next_element = vec__41824;\nvar vec__41827 = last_out;\nvar ___$2 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41827,(0),null);\nvar ___$3 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41827,(1),null);\nvar le = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41827,(2),null);\nvar new_element = ((((((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(e,new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(e,new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323))))) && (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(ne,new cljs.core.Keyword(null,\"comment-inline\",\"comment-inline\",712944405)))))?(((!(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(le,new cljs.core.Keyword(null,\"comment\",\"comment\",532206069))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(le,new cljs.core.Keyword(null,\"comment-inline\",\"comment-inline\",712944405)))))))?new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [zprint.comment.blanks(nn),c,new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483),(25)], null):new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.comment.blanks(zprint.comment.space_before_comment(out)))].join(''),c,new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125),(41)], null)):element\n);\nvar G__42402 = cljs.core.next(cvec);\nvar G__42403 = new_element;\nvar G__42404 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,new_element);\ncvec = G__42402;\nlast_out = G__42403;\nout = G__42404;\ncontinue;\n}\nbreak;\n}\n});\nzprint.comment.max_aligned_inline_comment_distance = (5);\n/**\n * Given a style-vec, find previously aligned inline comments and\n *   output the as a sequence of vectors of comments. The previously\n *   aligned comments do not have to be consecutive, but they can't\n *   be separated by more than max-aligned-inline-comment-distance.\n *   Each comment itself is a vector: [indent-index inline-comment-index],\n *   yielding a [[[indent-index inline-comment-index] [indent-index\n *   inline-comment-index] ...] ...].  The indexes are into the\n *   style-vec.\n */\nzprint.comment.find_aligned_inline_comments = (function zprint$comment$find_aligned_inline_comments(style_vec){\nvar cvec = style_vec;\nvar index = (0);\nvar last_indent = (0);\nvar current_seq = cljs.core.PersistentVector.EMPTY;\nvar current_column = (0);\nvar distance = (0);\nvar out = cljs.core.PersistentVector.EMPTY;\nwhile(true){\nif(cljs.core.not(cvec)){\nvar out__$1 = (((cljs.core.count(current_seq) > (1)))?cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,current_seq):out);\nreturn out__$1;\n} else {\nvar vec__41872 = cljs.core.first(cvec);\nvar s = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41872,(0),null);\nvar c = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41872,(1),null);\nvar e = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41872,(2),null);\nvar spaces = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41872,(3),null);\nvar start_column = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41872,(4),null);\nvar element = vec__41872;\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(e,new cljs.core.Keyword(null,\"comment-inline\",\"comment-inline\",712944405))){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(start_column,current_column)){\nvar G__42408 = cljs.core.next(cvec);\nvar G__42409 = (index + (1));\nvar G__42410 = null;\nvar G__42411 = (cljs.core.truth_(last_indent)?cljs.core.conj.cljs$core$IFn$_invoke$arity$2(current_seq,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [last_indent,index], null)):(function(){throw (new Error([\"find-aligned-inline-comments a:\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(index)].join('')))})());\nvar G__42412 = current_column;\nvar G__42413 = (0);\nvar G__42414 = out;\ncvec = G__42408;\nindex = G__42409;\nlast_indent = G__42410;\ncurrent_seq = G__42411;\ncurrent_column = G__42412;\ndistance = G__42413;\nout = G__42414;\ncontinue;\n} else {\nvar G__42425 = cljs.core.next(cvec);\nvar G__42426 = (index + (1));\nvar G__42427 = null;\nvar G__42428 = (cljs.core.truth_(last_indent)?new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [last_indent,index], null)], null):(function(){throw (new Error([\"find-aligned-inline-comments b:\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(index)].join('')))})());\nvar G__42429 = start_column;\nvar G__42430 = (0);\nvar G__42431 = (((cljs.core.count(current_seq) > (1)))?cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,current_seq):out);\ncvec = G__42425;\nindex = G__42426;\nlast_indent = G__42427;\ncurrent_seq = G__42428;\ncurrent_column = G__42429;\ndistance = G__42430;\nout = G__42431;\ncontinue;\n}\n} else {\nif(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(e,new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(e,new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323))))){\nif((distance >= zprint.comment.max_aligned_inline_comment_distance)){\nvar G__42434 = cljs.core.next(cvec);\nvar G__42435 = (index + (1));\nvar G__42436 = index;\nvar G__42437 = cljs.core.PersistentVector.EMPTY;\nvar G__42438 = (0);\nvar G__42439 = (0);\nvar G__42440 = (((cljs.core.count(current_seq) > (1)))?cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,current_seq):out);\ncvec = G__42434;\nindex = G__42435;\nlast_indent = G__42436;\ncurrent_seq = G__42437;\ncurrent_column = G__42438;\ndistance = G__42439;\nout = G__42440;\ncontinue;\n} else {\nvar G__42441 = cljs.core.next(cvec);\nvar G__42442 = (index + (1));\nvar G__42443 = index;\nvar G__42444 = current_seq;\nvar G__42445 = current_column;\nvar G__42446 = (distance + (1));\nvar G__42447 = out;\ncvec = G__42441;\nindex = G__42442;\nlast_indent = G__42443;\ncurrent_seq = G__42444;\ncurrent_column = G__42445;\ndistance = G__42446;\nout = G__42447;\ncontinue;\n}\n} else {\nvar G__42448 = cljs.core.next(cvec);\nvar G__42449 = (index + (1));\nvar G__42450 = last_indent;\nvar G__42451 = current_seq;\nvar G__42452 = current_column;\nvar G__42453 = distance;\nvar G__42454 = out;\ncvec = G__42448;\nindex = G__42449;\nlast_indent = G__42450;\ncurrent_seq = G__42451;\ncurrent_column = G__42452;\ndistance = G__42453;\nout = G__42454;\ncontinue;\n\n}\n}\n}\nbreak;\n}\n});\n/**\n * Given a style-vec, find consecutive inline comments and output\n *   the as a sequence of vectors of comments.  Each comment itself\n *   is a vector: [indent-index inline-comment-index], yielding a\n *   [[[indent-index inline-comment-index] [indent-index inline-comment-index]\n *   ...] ...]\n */\nzprint.comment.find_consecutive_inline_comments = (function zprint$comment$find_consecutive_inline_comments(style_vec){\nvar cvec = style_vec;\nvar index = (0);\nvar last_indent = (0);\nvar current_seq = cljs.core.PersistentVector.EMPTY;\nvar out = cljs.core.PersistentVector.EMPTY;\nwhile(true){\nif(cljs.core.not(cvec)){\nreturn out;\n} else {\nvar vec__41909 = cljs.core.first(cvec);\nvar s = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41909,(0),null);\nvar c = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41909,(1),null);\nvar e = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41909,(2),null);\nvar element = vec__41909;\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(e,new cljs.core.Keyword(null,\"comment-inline\",\"comment-inline\",712944405))){\nvar G__42455 = cljs.core.next(cvec);\nvar G__42456 = (index + (1));\nvar G__42457 = null;\nvar G__42458 = (cljs.core.truth_(last_indent)?cljs.core.conj.cljs$core$IFn$_invoke$arity$2(current_seq,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [last_indent,index], null)):(function(){throw (new Error([\"find-consecutive-inline-comments:\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(index)].join('')))})());\nvar G__42459 = out;\ncvec = G__42455;\nindex = G__42456;\nlast_indent = G__42457;\ncurrent_seq = G__42458;\nout = G__42459;\ncontinue;\n} else {\nif(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(e,new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(e,new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323))))){\nvar G__42460 = cljs.core.next(cvec);\nvar G__42461 = (index + (1));\nvar G__42462 = index;\nvar G__42463 = (cljs.core.truth_(last_indent)?cljs.core.PersistentVector.EMPTY:current_seq);\nvar G__42464 = (cljs.core.truth_(last_indent)?(((cljs.core.count(current_seq) > (1)))?cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,current_seq):out):out);\ncvec = G__42460;\nindex = G__42461;\nlast_indent = G__42462;\ncurrent_seq = G__42463;\nout = G__42464;\ncontinue;\n} else {\nvar G__42466 = cljs.core.next(cvec);\nvar G__42467 = (index + (1));\nvar G__42468 = last_indent;\nvar G__42469 = current_seq;\nvar G__42470 = out;\ncvec = G__42466;\nindex = G__42467;\nlast_indent = G__42468;\ncurrent_seq = G__42469;\nout = G__42470;\ncontinue;\n\n}\n}\n}\nbreak;\n}\n});\n/**\n * Takes a single vector of [indent-index comment-index] and will show the\n *   column on the line in which the comment starts.\n */\nzprint.comment.comment_column = (function zprint$comment$comment_column(p__41932,style_vec){\nvar vec__41933 = p__41932;\nvar indent_index = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41933,(0),null);\nvar comment_index = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41933,(1),null);\nif(cljs.core.vector_QMARK_(style_vec)){\n} else {\nthrow (new Error([\"comment-column: style-vec not a vector!! \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(style_vec)].join('')));\n}\n\nvar index = indent_index;\nvar column = (0);\nwhile(true){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(index,comment_index)){\nreturn column;\n} else {\nvar G__42471 = (index + (1));\nvar G__42472 = zprint.comment.loc_vec(column,cljs.core.nth.cljs$core$IFn$_invoke$arity$2(style_vec,index));\nindex = G__42471;\ncolumn = G__42472;\ncontinue;\n}\nbreak;\n}\n});\n/**\n * Take a single inline comment vector:\n *   [indent-index inline-comment-index] \n *   and replace it with [inline-comment-index start-column spaces-before].\n */\nzprint.comment.comment_vec_column = (function zprint$comment$comment_vec_column(style_vec,p__41939){\nvar vec__41940 = p__41939;\nvar indent_index = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41940,(0),null);\nvar inline_comment_index = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41940,(1),null);\nvar comment_vec = vec__41940;\nvar start_column = zprint.comment.comment_column(comment_vec,style_vec);\nvar spaces_before = zprint.comment.loc_vec((0),cljs.core.nth.cljs$core$IFn$_invoke$arity$2(style_vec,(inline_comment_index - (1))));\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [inline_comment_index,start_column,spaces_before], null);\n});\n/**\n * Take a single vector of inline comments\n *   [[indent-index inline-comment-index] [indent-index inline-comment-index]\n * ...] and replace it with [[inline-comment-index start-column spaces-before]\n * [inline-comment-index start-column spaces-before] ...]\n */\nzprint.comment.comment_vec_seq_column = (function zprint$comment$comment_vec_seq_column(style_vec,comment_vec_seq){\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(zprint.comment.comment_vec_column,style_vec),comment_vec_seq);\n});\n/**\n * Take a seq of all of the comments as produced by \n *   find-consecutive-inline-comments, and turn it into:\n *   [[[inline-comment-index start-column spaces-before] [inline-comment-index\n *   start-column spaces-before]\n *   ...] ...]\n */\nzprint.comment.comment_vec_all_column = (function zprint$comment$comment_vec_all_column(style_vec,comment_vec_all){\nreturn cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(zprint.comment.comment_vec_seq_column,style_vec),comment_vec_all);\n});\n/**\n * Given a set of inline comments:\n *   [[inline-comment-index start-column spaces-before]\n * [inline-comment-index start-column spaces-before] ...], determine\n * the minimum column at which they could be aligned.\n */\nzprint.comment.minimum_column = (function zprint$comment$minimum_column(comment_vec){\nvar minimum_vec = cljs.core.map.cljs$core$IFn$_invoke$arity$2((function (p1__41947_SHARP_){\nreturn ((cljs.core.second(p1__41947_SHARP_) - cljs.core.nth.cljs$core$IFn$_invoke$arity$2(p1__41947_SHARP_,(2))) + (1));\n}),comment_vec);\nvar minimum_col = cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.max,minimum_vec);\nreturn minimum_col;\n});\n/**\n * Given a new start-column, and a vector \n *   [[inline-comment-index start-column spaces-before]\n *   and a style-vec, return a new style-vec with the inline-comment starting\n *   at a new column.\n */\nzprint.comment.change_start_column = (function zprint$comment$change_start_column(new_start_column,style_vec,p__41949){\nvar vec__41950 = p__41949;\nvar inline_comment_index = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41950,(0),null);\nvar start_column = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41950,(1),null);\nvar spaces_before = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41950,(2),null);\nvar comment_vec = vec__41950;\nvar delta_spaces = (new_start_column - start_column);\nvar new_spaces = (spaces_before + delta_spaces);\nvar previous_element_index = (inline_comment_index - (1));\nvar vec__41953 = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(style_vec,previous_element_index);\nvar s = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41953,(0),null);\nvar c = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41953,(1),null);\nvar e = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41953,(2),null);\nvar previous_element = vec__41953;\nvar new_previous_element = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(e,new cljs.core.Keyword(null,\"indent\",\"indent\",-148200125)))?new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\"\\n\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.comment.blanks(new_spaces))].join(''),c,e], null):((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(e,new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483)))?new cljs.core.PersistentVector(null, 4, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.str.cljs$core$IFn$_invoke$arity$1(zprint.comment.blanks(new_spaces)),c,e,(26)], null):(function(){throw (new Error([\"change-start-column: comment preceded by neither\",\" an :indent nor :whitespace!\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(e)].join('')))})()\n));\nreturn cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(style_vec,previous_element_index,new_previous_element);\n});\n/**\n * Given one set of inline comments: \n *   [[inline-comment-index start-column spaces-before]\n * [inline-comment-index start-column spaces-before] ...], align them \n * as best as possible, and return the modified style-vec.\n */\nzprint.comment.align_comment_vec = (function zprint$comment$align_comment_vec(style_vec,comment_vec){\nvar minimum_col = zprint.comment.minimum_column(comment_vec);\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(zprint.comment.change_start_column,minimum_col),style_vec,comment_vec);\n});\n/**\n * Given the current style-vec, align all consecutive inline comments.\n */\nzprint.comment.fzprint_align_inline_comments = (function zprint$comment$fzprint_align_inline_comments(options,style_vec){\nif(cljs.core.truth_(new cljs.core.Keyword(null,\"dbg?\",\"dbg?\",1845730771).cljs$core$IFn$_invoke$arity$1(options))){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,\"dbg-indent\",\"dbg-indent\",1534856778).cljs$core$IFn$_invoke$arity$1(options),cljs.core.pr_str.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"fzprint-align-inline-comments: style-vec:\",style_vec], 0))], 0));\n} else {\n}\n\nvar style = new cljs.core.Keyword(null,\"inline-align-style\",\"inline-align-style\",1548722575).cljs$core$IFn$_invoke$arity$1(new cljs.core.Keyword(null,\"comment\",\"comment\",532206069).cljs$core$IFn$_invoke$arity$1(options));\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(style,new cljs.core.Keyword(null,\"none\",\"none\",1333468478))){\nreturn style_vec;\n} else {\nvar comment_vec = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(style,new cljs.core.Keyword(null,\"aligned\",\"aligned\",-1015148916)))?zprint.comment.find_aligned_inline_comments(style_vec):((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(style,new cljs.core.Keyword(null,\"consecutive\",\"consecutive\",-1628234596)))?zprint.comment.find_consecutive_inline_comments(style_vec):null));\nvar comment_vec_column = zprint.comment.comment_vec_all_column(style_vec,comment_vec);\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(zprint.comment.align_comment_vec,style_vec,comment_vec_column);\n}\n});\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","zprint/comment.cljc","~:line",1,"~:column",14,"~:end-line",1,"~:end-column",28,"~:no-doc",true],"~:ns-aliases",["^ ","~$clojure.spec.alpha","~$cljs.spec.alpha","~$clojure.tools.reader.impl.utils","~$cljs.tools.reader.impl.utils","~$cljs.loader","~$shadow.loader","~$clojure.tools.reader.impl.commons","~$cljs.tools.reader.impl.commons","~$clojure.tools.reader.impl.errors","~$cljs.tools.reader.impl.errors","~$react","~$module$node_modules$react$index","~$clojure.tools.reader.reader-types","~$cljs.tools.reader.reader-types","~$clojure.tools.reader.edn","~$cljs.tools.reader.edn","~$clojure.pprint","~$cljs.pprint","~$react-dom","~$module$node_modules$react_dom$index","~$clojure.repl","~$cljs.repl"],"~:use-macros",["^ ","~$dbg","~$zprint.macros","~$dbg-pr","^U","~$dbg-form","^U","~$dbg-print","^U","~$zfuture","^U"],"~:excludes",["~#set",[]],"~:name","~$zprint.comment","~:reader-aliases",["^ "],"~:op","~:ns","~:imports",null,"~:requires",["^ ","~$clojure.string","^17","~$s","^17","~$zprint.zfns","^18","~$rewrite-clj.zip","^19","~$z","^19","~$cljs.core","^1:","~$goog","^1;"],"~:seen",["^[",["~:require","~:require-macros"]],"~:uses",["^ ","~$zstring","^18","~$ztag","^18","~$left*","^19","~$up*","^19","~$tag","^19","~$length","^19"],"^1>",["^ ","^U","^U","^1:","^1:","^19","^19","~$z","^19"],"~:form",["~#list",["~$ns","^11",["^1>",["^U","~:refer",["^T","^V","^W","^X","^Y"]]],["^1G",["^1=",["^17","~:as","~$s"],["^18","^1I",["^1@","^1A"]],["^19","^1J","~$z","^1I",["^1B","^1C","^1D","^1E"]]]]]],"~:flags",["^ ","^1>",["^[",[]],"^1=",["^[",[]]],"~:js-deps",["^ "],"~:deps",["^1;","^1:","^17","^18","^19"]],"^14","^11","~:resource-id",["~:shadow.build.classpath/resource","zprint/comment.cljc"],"~:compiled-at",1666857667674,"^12",["^ ","^17","^17","~$s","^17","^18","^18","^19","^19","~$z","^19","^1:","^1:","^1;","^1;","^U","^U"],"~:resource-name","zprint/comment.cljc","~:warnings",[],"~:source","(ns ^:no-doc zprint.comment\n  #?@(:cljs [[:require-macros\n              [zprint.macros :refer [dbg dbg-pr dbg-form dbg-print zfuture]]]])\n  (:require #?@(:clj [[zprint.macros :refer\n                       [dbg-pr dbg dbg-form dbg-print zfuture]]])\n            [clojure.string :as s]\n            [zprint.zfns :refer [zstring ztag]]\n            [rewrite-clj.zip :as z :refer [left* up* tag length]]\n            #_[taoensso.tufte :as tufte :refer (p defnp profiled profile)]))\n\n#_(tufte/add-basic-println-handler! {})\n\n;;\n;; # Utility Functions\n;;\n\n;\n; Interestingly, this is faster than (apply str (repeat n \\space)) by\n; about 30%.\n\n(defn blanks\n  \"Produce a blank string of desired size.\"\n  [n]\n  (apply str (repeat n \" \")))\n\n(defn split-lf\n  \"Do split for newlines, instead of using regular expressions.\"\n  [s]\n  (loop [input s\n         out []]\n    (if-not input\n      out\n      (let [next-lf (clojure.string/index-of input \"\\n\")\n            chunk (if next-lf (subs input 0 next-lf) input)]\n        (recur (if next-lf (subs input (inc next-lf)) nil) (conj out chunk))))))\n\n(defn tag-l-size\n  \"Given a tag into which you can go down from rewrite-clj, which must be\n  a collection of some kind, return the size the l-str.  All of the tag\n  values into which you can go down must be in this list for indent-before\n  to work correctly.  It uses these values when it steps up out of one of\n  these things to see how big the thing would have been if it showed up\n  as characters.\"\n  [t]\n  (case t\n    :list 1\n    :vector 1\n    :set 2\n    :map 1\n    :uneval 2\n    :reader-macro 1\n    :meta 1\n    :quote 1\n    :syntax-quote 1\n    :fn 2\n    :unquote 1\n    :deref 1\n    :namespaced-map 1\n    0))\n\n(defn left-or-up\n  \"Take a zloc and move left if possible, or move up if necessary.\n  Return a vector with [up-size new-zloc]\"\n  [zloc]\n  (loop [ploc zloc\n         total-up 0]\n    #_(prn \"left-or-up: ploc:\" (zstring ploc) \"total-up:\" total-up)\n    (let [next-left (left* ploc)]\n      (if next-left\n        [total-up next-left]\n        ; can't go left, what about up?\n        (let [moving-up (up* ploc)\n              up-tag (when moving-up (tag moving-up))\n              up-size (tag-l-size up-tag)]\n          #_(prn \"left-or-up: up-tag:\" up-tag)\n          (if-not moving-up\n            ; can't go up, ran out of expression\n            [total-up nil]\n            (recur moving-up (+ total-up up-size))))))))\n\n(defn length-after-newline\n  \"Given a string, return the number of characters to the right\n  of any newlines in the string.  Will return nil if no newlines\n  in the string.\"\n  [s]\n  (let [nl-split (clojure.string/split (str s \" \") #\"\\n\")\n        nl-num (dec (count nl-split))]\n    (when-not (zero? nl-num) (dec (count (last nl-split))))))\n\n(defn length-before\n  \"Given a zloc, find the amount of printing space before it on its\n  current line.\"\n  [zloc]\n  (let [[up-size next-zloc] (left-or-up zloc)]\n    (loop [ploc next-zloc\n           indent-before up-size]\n      (if-not ploc\n        (do #_(prn \"length-before: if-not ploc:\" indent-before) indent-before)\n        ; we assume we have a ploc\n        (let [zstr (if ploc (zstring ploc) \"\")\n              length-right-of-newline (length-after-newline zstr)\n              [up-size next-zloc] (left-or-up ploc)]\n          #_(prn \"length-before: (nil? ploc):\" (nil? ploc)\n                 \"zstr:\" zstr\n                 \"up-size:\" up-size\n                 \"length-right-of-newline:\" length-right-of-newline\n                 \"(tag ploc):\" (tag ploc)\n                 \"ploc:\" (zstring ploc)\n                 \"next-zloc:\" (zstring next-zloc))\n          (if length-right-of-newline\n            ; hit a newline\n            (do #_(prn \"length-before: length-right-of-newline:\"\n                         length-right-of-newline\n                       \"indent-before:\" indent-before)\n                (+ length-right-of-newline indent-before))\n            (recur next-zloc (+ indent-before (count zstr) up-size))))))))\n\n;;\n;; # Comment Wrap Support\n;;\n\n(defn inlinecomment?\n  \"If this is an inline comment, returns a vector with the amount\n  of space that was between this and the previous element and the\n  starting column of this inline comment.  That means that if we\n  go left, we get something other than whitespace before a newline.\n  If we get only whitespace before a newline, then this is considered\n  an inline comment if the comment at the end of the previous line\n  was an inline comment and we were aligned with that comment.\n  Assumes zloc is a comment.\"\n  [zloc]\n  #_(prn \"inlinecomment? zloc:\" (zstring zloc))\n  (loop [nloc (left* zloc)\n         spaces 0\n         passed-nl? false]\n    (let\n      #?(:clj [tnloc (ztag nloc)]\n         :cljs [[tnloc spaces]\n                (let [tnloc (ztag nloc)]\n                  (if (= tnloc :whitespace)\n                    ; might be whitespace with an embedded comma in cljs\n                    (let [nstr (zstring nloc)\n                          trim-nstr (clojure.string/trimr nstr)]\n                      (if (pos? (count trim-nstr))\n                        ; it had something besides spaces in it\n                        ; we will assume a comma\n                        ;  correct things\n                        [:comma (+ spaces (- (count nstr) (count trim-nstr)))]\n                        ; it was all whitespace -- don't correct\n                        [:whitespace spaces]))\n                    [tnloc spaces]))])\n      #_(prn \"inlinecomment? tnloc:\" tnloc\n             \"spaces:\" spaces\n             \"nloc:\" (zstring nloc))\n      (cond\n        (nil? tnloc) nil  ; the start of the zloc\n        (= tnloc :newline) (recur (left* nloc) spaces true)\n        (or (= tnloc :comment) (= tnloc :comment-inline))\n          ; Two comments in a row don't have a newline showing between\n          ; them, it is captured by the first comment.  Sigh.\n          ; Except now it isn't, as we split the newlines out.\n          (do #_(prn \"inlinecomment? found previous comment!\")\n              ; is it an inline comment?\n              (when (inlinecomment? nloc)\n                ; figure the total alignment from the newline\n                (let [nloc-length-before (length-before nloc)\n                      zloc-length-before (length-before zloc)]\n                  #_(prn \"inlinecomment?:\"\n                         \"nloc-length-before:\" nloc-length-before\n                         \"zloc-length-before:\" zloc-length-before\n                         \"spaces:\" spaces)\n                  (if (= nloc-length-before zloc-length-before)\n                    ; we have a lineup\n                    [spaces zloc-length-before]\n                    nil))))\n        (not= tnloc :whitespace)\n          (if passed-nl? nil [spaces (length-before zloc)])\n        :else (recur (left* nloc)\n                     ^long (+ ^long (length nloc) spaces)\n                     passed-nl?)))))\n\n(defn last-space\n  \"Take a string and an index, and look for the last space prior to the\n  index. If we wanted to tie ourselves to 1.8, we could use \n  clojure.string/last-index-of, but we don't.  However, we use similar\n  conventions, i.e., if no space is found, return nil, and if the index\n  is a space return that value, and accept any from-index, including one\n  larger than the length of the string.\"\n  [s from-index]\n  (let [from-index (min (dec (count s)) from-index)\n        rev-seq (reverse (take (inc from-index) s))\n        seq-after-space (take-while #(not= % \\space) rev-seq)\n        space-index (- from-index (count seq-after-space))]\n    (if (neg? space-index) nil space-index)))\n\n(defn next-space\n  \"Take a string and an index, and look for the next space *after* the\n  index. If no space is found, return nil. Accept any from-index, \n  including one larger than the length of the string.\"\n  [s from-index]\n  (let [from-index (inc from-index)]\n    (when (< from-index (count s))\n      (let [seq-after-space (take-while #(not= % \\space)\n                                        (drop from-index (seq s)))\n            space-index (+ from-index (count seq-after-space))]\n        (if (>= space-index (count s)) nil space-index)))))\n\n; transient may have made this worse\n(defn wrap-comment\n  \"If this is a comment, and it is too long, word wrap it to the right width.\n  Note that top level comments may well end with a newline, so remove it\n  and reapply it at the end if that is the case.\"\n  [width [s color stype :as element] start]\n  (if-not (or (= stype :comment) (= stype :comment-inline))\n    element\n    (let [comment-width (- width start)\n          semi-str (re-find #\";*\" s)\n          rest-str (subs s (count semi-str))\n          space-str (re-find #\" *\" rest-str)\n          rest-str (subs rest-str (count space-str))\n          newline? (re-find #\"\\n$\" s)\n          comment-width (- comment-width (count semi-str) (count space-str))\n          #_(println \"\\ncomment-width:\" comment-width\n                     \"semi-str:\" semi-str\n                     \"space-str:\" space-str\n                     \"rest-str:\" rest-str)]\n      (loop [comment-str rest-str\n             out (transient [])]\n        #_(prn \"comment-str:\" comment-str)\n        (if (empty? comment-str)\n          (if (zero? (count out))\n            (if newline?\n              [[semi-str color stype] [\"\\n\" :none :indent 38]]\n              [[semi-str color stype]])\n            (persistent! (if newline? (conj! out [\"\\n\" :none :indent 39]) out)))\n          (let [last-space-index (if (<= (count comment-str) comment-width)\n                                   (dec (count comment-str))\n                                   (if (<= comment-width 0)\n                                     (or (next-space comment-str 0)\n                                         (dec (count comment-str)))\n                                     (or (last-space comment-str comment-width)\n                                         (next-space comment-str comment-width)\n                                         (dec (count comment-str)))))\n                next-comment (clojure.string/trimr\n                               (subs comment-str 0 (inc last-space-index)))]\n            #_(prn \"last-space-index:\" last-space-index\n                   \"next-comment:\" next-comment)\n            (recur\n              (subs comment-str (inc last-space-index))\n              (if (zero? (count out))\n                ;(empty? out)\n                (conj! out [(str semi-str space-str next-comment) color stype])\n                (conj! (conj! out [(str \"\\n\" (blanks start)) :none :indent 40])\n                       [(str semi-str space-str next-comment) color\n                        :comment-wrap])))))))))\n\n(defn loc-vec\n  \"Takes the start of this vector and the vector itself.\"\n  [start [s]]\n  (let [split (split-lf s)]\n    (if (= (count split) 1) (+ start (count s)) (count (last split)))))\n\n(defn style-loc-vec\n  \"Take a style-vec and produce a style-loc-vec with the starting column\n  of each element in the style-vec. Accepts a beginning indent.\"\n  [indent style-vec]\n  (butlast (reductions loc-vec indent style-vec)))\n\n; Transient didn't help here, rather it hurt a bit.\n\n(defn lift-vec\n  \"Take a transient output vector and a vector and lift any style-vec elements\n  out of the input vector.\"\n  [out-vec element]\n  (if (string? (first element))\n    (conj out-vec element)\n    (loop [element-vec element\n           out out-vec]\n      (if-not element-vec\n        out\n        (recur (next element-vec) (conj out (first element-vec)))))))\n\n(defn lift-style-vec\n  \"Take a style-vec [[s color type] [s color type] [[s color type]\n  [s color type]] [s color type] ...] and lift out the inner vectors.\"\n  [style-vec]\n  (reduce lift-vec [] style-vec))\n\n(defn fzprint-wrap-comments\n  \"Take the final output style-vec, and wrap any comments which run over\n  the width. Looking for \"\n  [{:keys [width], :as options} style-vec]\n  (dbg options \"fzprint-wrap-comments: indent:\" (:indent options))\n  #_(def wcsv style-vec)\n  (let [start-col (style-loc-vec (or (:indent options) 0) style-vec)\n        #_(def stc start-col)\n        _ (dbg options \"fzprint-wrap-comments: style-vec:\" (pr-str style-vec))\n        _ (dbg options \"fzprint-wrap-comments: start-col:\" start-col)\n        wrap-style-vec (mapv (partial wrap-comment width) style-vec start-col)\n        #_(def wsv wrap-style-vec)\n        _ (dbg options \"fzprint-wrap-comments: wrap:\" (pr-str style-vec))\n        out-style-vec (lift-style-vec wrap-style-vec)]\n    out-style-vec))\n\n(defn find-element-from-end\n  \"Find a the first element of this type working from the end of a \n  style-vec.  Return the index of the element.\"\n  [element-pred? style-vec]\n  (loop [index (dec (count style-vec))]\n    (if (neg? index)\n      nil\n      (let [[_ _ e] (nth style-vec index)]\n        (if (element-pred? e) index (recur (dec index)))))))\n\n(defn line-size\n  \"Given a style-vec, how big is it in actual characters.  This doesn't\n  handle newlines.\"\n  [style-vec]\n  (apply + (map (partial loc-vec 0) style-vec)))\n\n(defn space-before-comment\n  \"Given a style-vec, whose last element in a comment, find the amount\n  of space before that comment on the line.\"\n  [style-vec]\n  (let [indent-index (find-element-from-end #(or (= % :indent) (= % :newline))\n                                            style-vec)\n        this-line-vec\n          (if indent-index (nthnext style-vec indent-index) style-vec)]\n    (line-size (butlast this-line-vec))))\n\n(defn fzprint-inline-comments\n  \"Try to bring inline comments back onto the line on which they belong.\"\n  [{:keys [width], :as options} style-vec]\n  #_(def fic style-vec)\n  (dbg-pr options \"fzprint-inline-comments:\" style-vec)\n  (loop [cvec style-vec\n         last-out [\"\" nil nil]\n         out []]\n    (if-not cvec\n      (do #_(def fico out) out)\n      (let [[s c e :as element] (first cvec)\n            [_ _ ne nn :as next-element] (second cvec)\n            [_ _ le] last-out\n            new-element\n              (cond (and (or (= e :indent) (= e :newline))\n                         (= ne :comment-inline))\n                      (if-not (or (= le :comment) (= le :comment-inline))\n                        ; Regular line to get the inline comment\n                        [(blanks nn) c :whitespace 25]\n                        ; Last element was a comment...\n                        ; Can't put a comment on a comment, but\n                        ; we want to indent it like the last\n                        ; comment.\n                        ; How much space before the last comment?\n                        (do #_(prn \"inline:\" (space-before-comment out))\n                            [(str \"\\n\" (blanks (space-before-comment out))) c\n                             :indent 41]\n                            #_element))\n                    :else element)]\n        (recur (next cvec) new-element (conj out new-element))))))\n\n;;\n;; ## Align inline comments\n;;\n\n(def max-aligned-inline-comment-distance 5)\n\n(defn find-aligned-inline-comments\n  \"Given a style-vec, find previously aligned inline comments and\n  output the as a sequence of vectors of comments. The previously\n  aligned comments do not have to be consecutive, but they can't\n  be separated by more than max-aligned-inline-comment-distance.\n  Each comment itself is a vector: [indent-index inline-comment-index],\n  yielding a [[[indent-index inline-comment-index] [indent-index\n  inline-comment-index] ...] ...].  The indexes are into the\n  style-vec.\"\n  [style-vec]\n  #_(def fcic style-vec)\n  (loop [cvec style-vec\n         index 0\n         last-indent 0\n         current-seq []\n         current-column 0\n         distance 0\n         out []]\n    (if-not cvec\n      (let [out (if (> (count current-seq) 1) (conj out current-seq) out)]\n        #_(def fcico out)\n        out)\n      (let [[s c e spaces start-column :as element] (first cvec)]\n        (cond\n          (= e :comment-inline)\n            (if (= start-column current-column)\n              ; include this inline comment in the current-seq, since\n              ; it has the same starting column\n              (recur (next cvec)\n                     (inc index)\n                     nil\n                     (if last-indent\n                       (conj current-seq [last-indent index])\n                       (throw (#?(:clj Exception.\n                                  :cljs js/Error.)\n                               (str \"find-aligned-inline-comments a:\" index))))\n                     current-column\n                     ; distance from last inline comment is zero\n                     0\n                     out)\n              ; start a new current-seq, since this comment's starting\n              ; column doesn't match the current-column of the current-seq\n              (recur (next cvec)\n                     (inc index)\n                     nil\n                     (if last-indent\n                       [[last-indent index]]\n                       (throw (#?(:clj Exception.\n                                  :cljs js/Error.)\n                               (str \"find-aligned-inline-comments b:\" index))))\n                     ; new starting column\n                     start-column\n                     ; distance from the last inline comment is zero\n                     0\n                     ; if we have more than one current inline comments,\n                     ; add them to the out vector\n                     (if (> (count current-seq) 1) (conj out current-seq) out)))\n          (or (= e :indent) (= e :newline))\n            (if (>= distance max-aligned-inline-comment-distance)\n              ; We have gone too far\n              (recur (next cvec)\n                     (inc index)\n                     ; last-indent is this index\n                     index\n                     []\n                     ; current-column\n                     0\n                     ; distance\n                     0\n                     (if (> (count current-seq) 1) (conj out current-seq) out))\n              ; We have not gone too far\n              (recur (next cvec)\n                     (inc index)\n                     ; last-indent is this index\n                     index\n                     current-seq\n                     current-column\n                     ; we've passed another line\n                     (inc distance)\n                     out))\n          :else (recur (next cvec)\n                       (inc index)\n                       last-indent\n                       current-seq\n                       current-column\n                       distance\n                       out))))))\n\n(defn find-consecutive-inline-comments\n  \"Given a style-vec, find consecutive inline comments and output\n  the as a sequence of vectors of comments.  Each comment itself\n  is a vector: [indent-index inline-comment-index], yielding a\n  [[[indent-index inline-comment-index] [indent-index inline-comment-index]\n  ...] ...]\"\n  [style-vec]\n  #_(def fcic style-vec)\n  (loop [cvec style-vec\n         index 0\n         last-indent 0\n         current-seq []\n         out []]\n    (if-not cvec\n      (do #_(def fcico out) out)\n      (let [[s c e :as element] (first cvec)]\n        (cond\n          (= e :comment-inline)\n            (recur (next cvec)\n                   (inc index)\n                   nil\n                   (if last-indent\n                     (conj current-seq [last-indent index])\n                     (throw (#?(:clj Exception.\n                                :cljs js/Error.)\n                             (str \"find-consecutive-inline-comments:\" index))))\n                   out)\n          (or (= e :indent) (= e :newline))\n            (recur (next cvec)\n                   (inc index)\n                   index\n                   (if last-indent\n                     ; if we have a last-indent, then we didn't\n                     ; just have a comment\n                     []\n                     ; if we don't have a last-indent, then we\n                     ; did just have a comment previously, so keep\n                     ; collecting comments\n                     current-seq)\n                   (if last-indent\n                     ; if we have a last-indent, then we didn't\n                     ; just have a comment.  But if we have more\n                     ; than one comment vector in current-seq,\n                     ; make sure we keep track of that\n                     (if (> (count current-seq) 1) (conj out current-seq) out)\n                     ; if we didn't have last-indent, then we\n                     ; just had a comment, so keep collecting\n                     ; them\n                     out))\n          :else (recur (next cvec) (inc index) last-indent current-seq out))))))\n\n(defn comment-column\n  \"Takes a single vector of [indent-index comment-index] and will show the\n  column on the line in which the comment starts.\"\n  [[indent-index comment-index] style-vec]\n  (when-not (vector? style-vec)\n    (throw (#?(:clj Exception.\n               :cljs js/Error.)\n            (str \"comment-column: style-vec not a vector!! \" style-vec))))\n  (loop [index indent-index\n         column 0]\n    (if (= index comment-index)\n      column\n      (recur (inc index) (loc-vec column (nth style-vec index))))))\n\n(defn comment-vec-column\n  \"Take a single inline comment vector:\n  [indent-index inline-comment-index] \n  and replace it with [inline-comment-index start-column spaces-before].\"\n  [style-vec [indent-index inline-comment-index :as comment-vec]]\n  (let [start-column (comment-column comment-vec style-vec)\n        spaces-before (loc-vec 0 (nth style-vec (dec inline-comment-index)))]\n    [inline-comment-index start-column spaces-before]))\n\n(defn comment-vec-seq-column\n  \"Take a single vector of inline comments\n  [[indent-index inline-comment-index] [indent-index inline-comment-index]\n   ...] and replace it with [[inline-comment-index start-column spaces-before]\n   [inline-comment-index start-column spaces-before] ...]\"\n  [style-vec comment-vec-seq]\n  (map (partial comment-vec-column style-vec) comment-vec-seq))\n\n(defn comment-vec-all-column\n  \"Take a seq of all of the comments as produced by \n  find-consecutive-inline-comments, and turn it into:\n  [[[inline-comment-index start-column spaces-before] [inline-comment-index\n  start-column spaces-before]\n  ...] ...]\"\n  [style-vec comment-vec-all]\n  (map (partial comment-vec-seq-column style-vec) comment-vec-all))\n\n(defn minimum-column\n  \"Given a set of inline comments:\n  [[inline-comment-index start-column spaces-before]\n   [inline-comment-index start-column spaces-before] ...], determine\n   the minimum column at which they could be aligned.\"\n  [comment-vec]\n  (let [minimum-vec (map #(inc (- (second %) (nth % 2))) comment-vec)\n        minimum-col (apply max minimum-vec)]\n    minimum-col))\n\n(defn change-start-column\n  \"Given a new start-column, and a vector \n  [[inline-comment-index start-column spaces-before]\n  and a style-vec, return a new style-vec with the inline-comment starting\n  at a new column.\"\n  [new-start-column style-vec\n   [inline-comment-index start-column spaces-before :as comment-vec]]\n  (let [delta-spaces (- new-start-column start-column)\n        new-spaces (+ spaces-before delta-spaces)\n        previous-element-index (dec inline-comment-index)\n        #_(prn \"change-start-column:\"\n               \"spaces-before:\" spaces-before\n               \"delta-spaces:\" delta-spaces\n               \"new-spaces:\" new-spaces)\n        [s c e :as previous-element] (nth style-vec previous-element-index)\n        new-previous-element\n          (cond (= e :indent) [(str \"\\n\" (blanks new-spaces)) c e]\n                (= e :whitespace) [(str (blanks new-spaces)) c e 26]\n                :else (throw\n                        (#?(:clj Exception.\n                            :cljs js/Error.)\n                         (str \"change-start-column: comment preceded by neither\"\n                              \" an :indent nor :whitespace!\"\n                              e))))]\n    (assoc style-vec previous-element-index new-previous-element)))\n\n(defn align-comment-vec\n  \"Given one set of inline comments: \n  [[inline-comment-index start-column spaces-before]\n   [inline-comment-index start-column spaces-before] ...], align them \n   as best as possible, and return the modified style-vec.\"\n  [style-vec comment-vec]\n  (let [minimum-col (minimum-column comment-vec)]\n    (reduce (partial change-start-column minimum-col) style-vec comment-vec)))\n\n(defn fzprint-align-inline-comments\n  \"Given the current style-vec, align all consecutive inline comments.\"\n  [options style-vec]\n  (dbg-pr options \"fzprint-align-inline-comments: style-vec:\" style-vec)\n  (let [style (:inline-align-style (:comment options))]\n    (if (= style :none)\n      style-vec\n      (let [comment-vec (cond (= style :aligned) (find-aligned-inline-comments\n                                                   style-vec)\n                              (= style :consecutive)\n                                (find-consecutive-inline-comments style-vec))\n            comment-vec-column (comment-vec-all-column style-vec comment-vec)]\n        (reduce align-comment-vec style-vec comment-vec-column)))))\n\n","~:reader-features",["^[",["~:cljs"]],"~:cljc",true,"~:source-map-compact",["^ ","mappings","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","names",["zprint.comment/blanks","n","cljs.core.apply","cljs.core/str","cljs.core.repeat","zprint.comment/split-lf","s","input","out","cljs.core/not","next-lf","clojure.string.index_of","chunk","cljs.core.subs","cljs.core.conj","zprint.comment/tag-l-size","t","G__41647","cljs.core/Keyword","zprint.comment/left-or-up","zloc","ploc","total-up","next-left","rewrite-clj.zip/left*","moving-up","rewrite-clj.zip/up*","up-tag","rewrite-clj.zip/tag","up-size","zprint.comment/length-after-newline","nl-split","clojure.string.split","nl-num","cljs.core/count","cljs.core/last","zprint.comment/length-before","vec__41656","cljs.core.nth","next-zloc","indent-before","vec__41670","zstr","zprint.zfns/zstring","length-right-of-newline","zprint.comment/inlinecomment?","nloc","spaces","passed-nl?","vec__41689","tnloc","zprint.zfns/ztag","cljs.core._EQ_","nstr","trim-nstr","clojure.string/trimr","nloc-length-before","zloc-length-before","cljs.core.not_EQ_","rewrite-clj.zip/length","zprint.comment/last-space","from-index","x__5133__auto__","y__5134__auto__","rev-seq","cljs.core/reverse","cljs.core.take","seq-after-space","p1__41701#","cljs.core.take_while","space-index","zprint.comment/next-space","p1__41707#","cljs.core.drop","cljs.core/seq","p__41713","vec__41714","zprint.comment/wrap-comment","width","color","stype","element","start","comment-width","semi-str","cljs.core/re-find","rest-str","space-str","newline?","comment-str","cljs.core/transient","cljs.core/empty?","cljs.core/persistent!","cljs.core.conj_BANG_","last-space-index","or__5045__auto__","next-comment","p__41735","vec__41737","zprint.comment/loc-vec","split","zprint.comment/style-loc-vec","indent","style-vec","cljs.core/butlast","cljs.core.reductions","zprint.comment/lift-vec","out-vec","cljs.core/first","element-vec","cljs.core/next","zprint.comment/lift-style-vec","cljs.core.reduce","p__41755","map__41756","cljs.core/--destructure-map","cljs.core.get","zprint.comment/fzprint-wrap-comments","options","cljs.core.println","start-col","_","cljs.core.pr_str","wrap-style-vec","cljs.core.mapv","cljs.core.partial","out-style-vec","zprint.comment/find-element-from-end","element-pred?","index","vec__41768","e","zprint.comment/line-size","cljs.core/+","cljs.core.map","zprint.comment/space-before-comment","indent-index","p1__41771#","this-line-vec","cljs.core/nthnext","p__41786","map__41787","zprint.comment/fzprint-inline-comments","cvec","last-out","vec__41821","vec__41824","vec__41827","c","ne","nn","next-element","cljs.core/second","le","new-element","zprint.comment/max-aligned-inline-comment-distance","zprint.comment/find-aligned-inline-comments","last-indent","current-seq","current-column","distance","vec__41872","start-column","js/Error","zprint.comment/find-consecutive-inline-comments","vec__41909","p__41932","vec__41933","zprint.comment/comment-column","comment-index","cljs.core/vector?","column","p__41939","vec__41940","zprint.comment/comment-vec-column","inline-comment-index","comment-vec","spaces-before","zprint.comment/comment-vec-seq-column","comment-vec-seq","zprint.comment/comment-vec-all-column","comment-vec-all","zprint.comment/minimum-column","minimum-vec","p1__41947#","minimum-col","cljs.core/max","p__41949","vec__41950","zprint.comment/change-start-column","new-start-column","vec__41953","delta-spaces","new-spaces","previous-element-index","previous-element","new-previous-element","cljs.core.assoc","zprint.comment/align-comment-vec","zprint.comment/fzprint-align-inline-comments","style","comment-vec-column"]],"~:used-vars",["^[",["~$cljs.core/--destructure-map","~$zprint.comment/lift-vec","~$cljs.core/str","~$zprint.comment/length-before","~$rewrite-clj.zip/left*","~$clojure.string/split","~$zprint.comment/fzprint-inline-comments","~$cljs.core/vector?","~$rewrite-clj.zip/up*","~$cljs.core/=","~$zprint.comment/blanks","~$cljs.core/partial","~$cljs.core/take-while","~$clojure.string/index-of","~$zprint.zfns/zstring","~$zprint.comment/find-element-from-end","~$cljs.core/count","~$cljs.core/reduce","~$cljs.core/seq","~$cljs.core/apply","~$cljs.core/Keyword","~$cljs.core/take","~$cljs.core/last","~$cljs.core/mapv","~$cljs.core/not=","~$cljs.core/pr-str","~$zprint.comment/comment-column","~$zprint.comment/line-size","~$cljs.core/empty?","~$zprint.comment/change-start-column","~$zprint.comment/find-aligned-inline-comments","~$zprint.comment/comment-vec-column","~$cljs.core/conj","~$zprint.comment/comment-vec-seq-column","~$zprint.comment/wrap-comment","~$cljs.core/map","~$zprint.zfns/ztag","~$rewrite-clj.zip/length","~$cljs.core/nthnext","~$cljs.core/get","~$clojure.string/trimr","~$zprint.comment/last-space","~$rewrite-clj.zip/tag","~$zprint.comment/split-lf","~$cljs.core/conj!","~$zprint.comment/comment-vec-all-column","~$cljs.core/re-find","~$cljs.core/persistent!","~$zprint.comment/fzprint-align-inline-comments","~$cljs.core/nth","~$cljs.core/max","~$cljs.core/second","~$cljs.core/println","~$cljs.core/next","~$cljs.core/reductions","~$zprint.comment/lift-style-vec","~$cljs.core/transient","~$zprint.comment/tag-l-size","~$zprint.comment/next-space","~$cljs.core/not","~$zprint.comment/length-after-newline","~$zprint.comment/style-loc-vec","~$zprint.comment/space-before-comment","~$cljs.core/assoc","~$zprint.comment/max-aligned-inline-comment-distance","~$zprint.comment/loc-vec","~$zprint.comment/fzprint-wrap-comments","~$cljs.core/reverse","~$zprint.comment/find-consecutive-inline-comments","~$cljs.core/repeat","~$cljs.core/first","~$cljs.core/butlast","~$zprint.comment/minimum-column","~$zprint.comment/align-comment-vec","~$cljs.core/subs","~$cljs.core/+","~$zprint.comment/left-or-up","~$js/Error","~$zprint.comment/inlinecomment?","~$cljs.core/drop"]]],"~:cache-keys",["~#cmap",[["^1O","rewrite_clj/zip/options.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","~:shadow.build.compiler/resolve",["^ ","~:require-id",null,"~:deps-ids",["^[",[]],"~:deps-syms",["^1;","^1:","~$rewrite-clj.node.protocols"]]],["^1O","goog/dom/tagname.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","~$goog.dom.HtmlElement"]]],["^1O","rewrite_clj/zip/walk.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","~$rewrite-clj.zip.move","~$rewrite-clj.zip.subedit"]]],["^1O","cljs/tools/reader/impl/utils.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","^17","~$goog.string"]]],["^1O","rewrite_clj/node/reader_macro.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","^3Y","~$rewrite-clj.node.whitespace"]]],["^1O","rewrite_clj/parser.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","~$rewrite-clj.node.forms","~$rewrite-clj.parser.core","~$rewrite-clj.reader"]]],["^1O","goog/html/trustedtypes.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;"]]],["^1O","goog/string/stringformat.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^41"]]],["^1O","goog/labs/useragent/browser.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","~$goog.array","~$goog.object","~$goog.labs.userAgent.util","~$goog.string.internal"]]],["^1O","goog/html/safeurl.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","~$goog.asserts","~$goog.fs.url","~$goog.html.TrustedResourceUrl","~$goog.i18n.bidi.Dir","~$goog.i18n.bidi.DirectionalString","~$goog.string.Const","~$goog.string.TypedString","^49"]]],["^1O","goog/array/array.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^4:"]]],["^1O","rewrite_clj/parser/whitespace.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","^42","^45"]]],["^1O","rewrite_clj/node/regex.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","^3Y"]]],["^1O","goog/debug/error.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;"]]],["^1O","cljs/tools/reader/edn.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","^F","^J","^@","^D","~$cljs.tools.reader","^41","~$goog.string.StringBuffer"]]],["^1O","goog/dom/nodetype.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;"]]],["^1O","cljs/tools/reader/impl/inspect.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:"]]],["^1O","cljs/tools/reader.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","^J","^@","^D","^F","^46","^41","^4B"]]],["^1O","rewrite_clj/zip/base.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","~$rewrite-clj.custom-zipper.core","^43","^3Y","~$rewrite-clj.parser","~$rewrite-clj.zip.options","~$rewrite-clj.zip.whitespace"]]],["^1O","rewrite_clj/zip/editz.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","^4C","~$rewrite-clj.custom-zipper.utils","^3Y","~$rewrite-clj.node.token","^42","~$rewrite-clj.zip.base","^4E","~$rewrite-clj.zip.removez","^4F"]]],["^1O","rewrite_clj/parser/token.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","^4H","^45"]]],["^1O","rewrite_clj/node/uneval.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","^3Y"]]],["^1O","goog/string/typedstring.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;"]]],["^1O","rewrite_clj/parser/keyword.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","~$rewrite-clj.node.keyword","^45"]]],["^1O","rewrite_clj/zip/seqz.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","^4C","^4I","~$rewrite-clj.zip.editz","~$rewrite-clj.zip.findz","~$rewrite-clj.zip.insert","^3["]]],["^1O","goog/object/object.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;"]]],["^1O","goog/dom/asserts.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^4:"]]],"~:SHADOW-TIMESTAMP",[1666857604000,1666857604000,1666857293000],["^1O","rewrite_clj/node/keyword.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","^3Y"]]],["^1O","rewrite_clj/node/token.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","^3Y"]]],["^1O","goog/math/long.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^4:","~$goog.reflect"]]],["^1O","goog/html/trustedresourceurl.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^4:","~$goog.fs.blob","^4;","~$goog.html.SafeScript","~$goog.html.trustedtypes","^4=","^4>","^4?","^4@"]]],["^1O","rewrite_clj/node/comment.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","^3Y"]]],["^1O","rewrite_clj/zip/subedit.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","^4C","^4I","^4E"]]],["^1O","goog/string/internal.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;"]]],["^1O","goog/functions/functions.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;"]]],["^1O","rewrite_clj/parser/string.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","^17","~$rewrite-clj.node.stringz","^45","^4B"]]],["^1O","goog/html/safestyle.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^4?","~$goog.html.SafeUrl","^4@","^4:","^49"]]],["^1O","goog/dom/safe.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^4:","~$goog.dom.asserts","~$goog.functions","~$goog.html.SafeHtml","^4R","~$goog.html.SafeStyle","^4U","^4<","~$goog.html.uncheckedconversions","^4?","^49"]]],["^1O","rewrite_clj/zip/removez.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","^4C","^4G","^3[","^4F"]]],["^1O","clojure/walk.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:"]]],["^1O","goog/html/safehtml.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^4?","^4=","^4>","^4R","^4Y","~$goog.html.SafeStyleSheet","^4U","~$goog.dom.TagName","^4<","^4@","^4:","~$goog.labs.userAgent.browser","^46","^47","^49","~$goog.dom.tags","^4S"]]],["^1O","rewrite_clj/node/forms.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","^3Y"]]],["^1O","goog/dom/tags.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^47"]]],["^1O","rewrite_clj/node/integer.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","~$rewrite-clj.interop","^3Y"]]],["^1O","rewrite_clj/parser/core.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","~$rewrite-clj.node.comment","~$rewrite-clj.node.fn","~$rewrite-clj.node.meta","^3Y","~$rewrite-clj.node.quote","~$rewrite-clj.node.reader-macro","~$rewrite-clj.node.regex","~$rewrite-clj.node.seq","^4H","~$rewrite-clj.node.uneval","~$rewrite-clj.parser.keyword","~$rewrite-clj.parser.namespaced-map","~$rewrite-clj.parser.string","~$rewrite-clj.parser.token","~$rewrite-clj.parser.whitespace","^45"]]],["^1O","rewrite_clj/node/fn.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","^17","~$clojure.walk","^53","^3Y"]]],["^1O","goog/fs/blob.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;"]]],["^1O","rewrite_clj/node/protocols.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","^17","^53"]]],["^1O","goog/asserts/asserts.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","~$goog.debug.Error","~$goog.dom.NodeType"]]],["^1O","rewrite_clj/zip/whitespace.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","^4C","^54","~$rewrite-clj.node.extras","^42"]]],["^1O","goog/uri/uri.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^46","^4:","~$goog.collections.maps","^41","~$goog.structs","~$goog.uri.utils","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"]]],["^1O","rewrite_clj/node/meta.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","^53","^3Y","^42"]]],["^1O","rewrite_clj/node/stringz.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","^17","^L","^3Y"]]],["^1O","rewrite_clj/parser/namespaced_map.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","~$rewrite-clj.node.namespaced-map","^3Y","^42","^45"]]],["^1O","goog/collections/maps.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;"]]],["^1O","rewrite_clj/node/whitespace.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","^3Y","^45"]]],["^1O","goog/i18n/bidi.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;"]]],["^1O","rewrite_clj/zip/move.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","^4C","^4F"]]],["^1O","goog/fs/url.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;"]]],["^1O","rewrite_clj/node/quote.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","^3Y"]]],["^1O","goog/base.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",[]]],["^1O","goog/structs/structs.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^46","^47"]]],["^1O","cljs/tools/reader/impl/errors.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","^J","^17","~$cljs.tools.reader.impl.inspect"]]],["^1O","rewrite_clj/zip/context.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","^4C","^3Y","~$rewrite-clj.zip.seqz","~$rewrite-clj.zip.walk"]]],["^1O","clojure/string.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","^41","^4B"]]],["^1O","rewrite_clj/zip/findz.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","^4C","^4I","^3["]]],["^1O","rewrite_clj/zip.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","^4C","~$rewrite-clj.node.coercer","^4I","~$rewrite-clj.zip.context","^4L","^4M","^4N","^3[","^4J","^5L","^40","^5M","^4F"]]],["^1O","rewrite_clj/zip/insert.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","^4C","^3Y","^42","^4F"]]],["^1O","zprint/zfns.cljc"],["6c7de285c399d67aaa77693a88b73d129953fa1f","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:"]]],["^1O","rewrite_clj/node/namespaced_map.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","^3Y"]]],["^1O","zprint/comment.cljc"],["6c7de285c399d67aaa77693a88b73d129953fa1f","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","^17","^18","^19"]]],["^1O","goog/string/string.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","~$goog.dom.safe","^4Z","^4?","^49"]]],["^1O","rewrite_clj/custom_zipper/core.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","~$clojure.zip","~$rewrite-clj.custom-zipper.switchable","^3Y"]]],["^1O","goog/reflect/reflect.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;"]]],["^1O","goog/labs/useragent/util.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","~$goog.labs.userAgent","^49"]]],["^1O","clojure/zip.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:"]]],["^1O","goog/string/stringbuffer.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;"]]],["^1O","cljs/tools/reader/reader_types.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","^@","^41","^4B"]]],["^1O","rewrite_clj/reader.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","^L","^D","^F","^@","^J","^53","^4B"]]],["^1O","goog/labs/useragent/useragent.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;"]]],["^1O","rewrite_clj/custom_zipper/utils.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","^4C"]]],["^1O","rewrite_clj/node/coercer.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","^17","^54","^55","^43","~$rewrite-clj.node.integer","^4K","^56","^5J","^3Y","^57","^58","^59","^5:","^4T","^4H","^5;","^42"]]],["^1O","goog/html/uncheckedconversions.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^4:","^4X","^4R","^4Y","^4[","^4U","^4<","^4?","^49","^4="]]],["^1O","cljs/tools/reader/impl/commons.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","^F","^J","^@"]]],["^1O","goog/dom/htmlelement.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;"]]],["^1O","cljs/core.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","~$goog.math.Long","~$goog.math.Integer","^41","^47","^46","~$goog.Uri","^4B"]]],["^1O","rewrite_clj/custom_zipper/switchable.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:"]]],["^1O","goog/html/safescript.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^4?","^4@","^4S","^4:"]]],["^1O","rewrite_clj/node/extras.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","^54","^42"]]],["^1O","goog/html/safestylesheet.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^4?","^4Y","^4@","^47","^4:","^49"]]],["^1O","goog/math/integer.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^4P"]]],["^1O","goog/uri/utils.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^4:","^41"]]],["^1O","goog/string/const.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^4:","^4@"]]],["^1O","rewrite_clj/interop.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","^41","~$goog.string.format"]]],["^1O","rewrite_clj/node/seq.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^3U",["^ ","^3V",null,"^3W",["^[",[]],"^3X",["^1;","^1:","^53","^3Y"]]]]],"~:clj-info",["^ ","jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/string.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/impl/errors.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/env.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/default_data_readers.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/core.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/edn.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/reader.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/reader_types.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/util.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/compiler.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/impl/inspect.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/edn.clj",1666857280000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/passes/and_or.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/pprint.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map/base64_vlq.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/set.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/reader_types.clj",1666857280000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/node/protocols.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/instant.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map/base64.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/interop.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/impl/utils.clj",1666857280000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/custom_zipper/core.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/externs.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/zip.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/impl/commons.clj",1666857280000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/js_deps.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/binaryage/devtools/1.0.6/devtools-1.0.6.jar!/devtools/defaults.clj",1666857314000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/java/io.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/impl/inspect.clj",1666857280000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/node/comment.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/parser.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/node/whitespace.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/zip/whitespace.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/impl.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/custom_zipper/switchable.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/node/forms.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/tagged_literals.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/core.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/zip/subedit.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/parser/core.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/passes.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/node/extras.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/data/json.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/zip/options.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/instant.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/impl/namespaces.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/zip.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/zip/base.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/impl/errors.clj",1666857280000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/cljs/tools/reader/reader_types.clj",1666857280000,"jar:file:/Users/aleksey/.m2/repository/zprint/zprint/1.2.1/zprint-1.2.1.jar!/zprint/macros.cljc",1666857315000],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","zprint/comment.cljc","^7",1,"^8",14,"^9",1,"^:",28,"^;",true],"^<",["^ ","^=","^>","^?","^@","^A","^B","^C","^D","^E","^F","^G","^H","^I","^J","^K","^L","^M","^N","^O","^P","^Q","^R"],"^S",["^ ","^T","^U","^V","^U","^W","^U","^X","^U","^Y","^U"],"^Z",["^[",[]],"^10","^11","^12",["^ "],"^15",null,"^16",["^ ","^17","^17","~$s","^17","^18","^18","^19","^19","~$z","^19","^1:","^1:","^1;","^1;"],"^1<",["^[",["^1=","^1>"]],"~:shadow/js-access-global",["^[",["Error"]],"^1?",["^ ","^1@","^18","^1A","^18","^1B","^19","^1C","^19","^1D","^19","^1E","^19"],"~:defs",["^ ","~$fzprint-inline-comments",["^ ","~:protocol-inline",null,"^5",["^ ","^6","zprint/comment.cljc","^7",331,"^8",7,"^9",331,"^:",30,"~:arglists",["^1G",["~$quote",["^1G",[[["^ ","~:keys",["~$width"],"^1J","~$options"],"~$style-vec"]]]]],"~:doc","Try to bring inline comments back onto the line on which they belong."],"^10","^25","^6","zprint/comment.cljc","^:",30,"~:method-params",["^1G",[["~$p__41786","^7C"]]],"~:protocol-impl",null,"~:arglists-meta",["^1G",[null,null]],"^8",1,"~:variadic?",false,"^7",331,"~:ret-tag",["^[",["~$clj","~$cljs.core/IVector"]],"^9",331,"~:max-fixed-arity",2,"~:fn-var",true,"^7>",["^1G",["^7?",["^1G",[[["^ ","^7@",["^7A"],"^1J","^7B"],"^7C"]]]]],"^7D","Try to bring inline comments back onto the line on which they belong."],"~$blanks",["^ ","^7=",null,"^5",["^ ","^6","zprint/comment.cljc","^7",21,"^8",7,"^9",21,"^:",13,"^7>",["^1G",["^7?",["^1G",[["~$n"]]]]],"^7D","Produce a blank string of desired size."],"^10","^29","^6","zprint/comment.cljc","^:",13,"^7E",["^1G",[["~$n"]]],"^7G",null,"^7H",["^1G",[null,null]],"^8",1,"^7I",false,"^7",21,"^7J","~$any","^9",21,"^7M",1,"^7N",true,"^7>",["^1G",["^7?",["^1G",[["~$n"]]]]],"^7D","Produce a blank string of desired size."],"~$find-element-from-end",["^ ","^7=",null,"^5",["^ ","^6","zprint/comment.cljc","^7",305,"^8",7,"^9",305,"^:",28,"^7>",["^1G",["^7?",["^1G",[["~$element-pred?","^7C"]]]]],"^7D","Find a the first element of this type working from the end of a \n  style-vec.  Return the index of the element."],"^10","^2>","^6","zprint/comment.cljc","^:",28,"^7E",["^1G",[["^7R","^7C"]]],"^7G",null,"^7H",["^1G",[null,null]],"^8",1,"^7I",false,"^7",305,"^7J",["^[",["~$number","~$clj-nil"]],"^9",305,"^7M",2,"^7N",true,"^7>",["^1G",["^7?",["^1G",[["^7R","^7C"]]]]],"^7D","Find a the first element of this type working from the end of a \n  style-vec.  Return the index of the element."],"~$loc-vec",["^ ","^7=",null,"^5",["^ ","^6","zprint/comment.cljc","^7",257,"^8",7,"^9",257,"^:",14,"^7>",["^1G",["^7?",["^1G",[["~$start",["~$s"]]]]]],"^7D","Takes the start of this vector and the vector itself."],"^10","^3D","^6","zprint/comment.cljc","^:",14,"^7E",["^1G",[["^7V","~$p__41735"]]],"^7G",null,"^7H",["^1G",[null,null]],"^8",1,"^7I",false,"^7",257,"^7J","^7S","^9",257,"^7M",2,"^7N",true,"^7>",["^1G",["^7?",["^1G",[["^7V",["~$s"]]]]]],"^7D","Takes the start of this vector and the vector itself."],"~$length-before",["^ ","^7=",null,"^5",["^ ","^6","zprint/comment.cljc","^7",90,"^8",7,"^9",90,"^:",20,"^7>",["^1G",["^7?",["^1G",[["~$zloc"]]]]],"^7D","Given a zloc, find the amount of printing space before it on its\n  current line."],"^10","^22","^6","zprint/comment.cljc","^:",20,"^7E",["^1G",[["^7Y"]]],"^7G",null,"^7H",["^1G",[null,null]],"^8",1,"^7I",false,"^7",90,"^7J",["^[",["^7P","^7S"]],"^9",90,"^7M",1,"^7N",true,"^7>",["^1G",["^7?",["^1G",[["^7Y"]]]]],"^7D","Given a zloc, find the amount of printing space before it on its\n  current line."],"~$comment-vec-column",["^ ","^7=",null,"^5",["^ ","^6","zprint/comment.cljc","^7",521,"^8",7,"^9",521,"^:",25,"^7>",["^1G",["^7?",["^1G",[["^7C",["~$indent-index","~$inline-comment-index","^1J","~$comment-vec"]]]]]],"^7D","Take a single inline comment vector:\n  [indent-index inline-comment-index] \n  and replace it with [inline-comment-index start-column spaces-before]."],"^10","^2N","^6","zprint/comment.cljc","^:",25,"^7E",["^1G",[["^7C","~$p__41939"]]],"^7G",null,"^7H",["^1G",[null,null]],"^8",1,"^7I",false,"^7",521,"^7J","^7L","^9",521,"^7M",2,"^7N",true,"^7>",["^1G",["^7?",["^1G",[["^7C",["^7[","^80","^1J","^81"]]]]]],"^7D","Take a single inline comment vector:\n  [indent-index inline-comment-index] \n  and replace it with [inline-comment-index start-column spaces-before]."],"~$wrap-comment",["^ ","^7=",null,"^5",["^ ","^6","zprint/comment.cljc","^7",209,"^8",7,"^9",209,"^:",19,"^7>",["^1G",["^7?",["^1G",[["^7A",["~$s","~$color","~$stype","^1J","~$element"],"^7V"]]]]],"^7D","If this is a comment, and it is too long, word wrap it to the right width.\n  Note that top level comments may well end with a newline, so remove it\n  and reapply it at the end if that is the case."],"^10","^2Q","^6","zprint/comment.cljc","^:",19,"^7E",["^1G",[["^7A","~$p__41713","^7V"]]],"^7G",null,"^7H",["^1G",[null,null]],"^8",1,"^7I",false,"^7",209,"^7J",["^[",[null,"^7K"]],"^9",209,"^7M",3,"^7N",true,"^7>",["^1G",["^7?",["^1G",[["^7A",["~$s","^84","^85","^1J","^86"],"^7V"]]]]],"^7D","If this is a comment, and it is too long, word wrap it to the right width.\n  Note that top level comments may well end with a newline, so remove it\n  and reapply it at the end if that is the case."],"~$comment-vec-seq-column",["^ ","^7=",null,"^5",["^ ","^6","zprint/comment.cljc","^7",530,"^8",7,"^9",530,"^:",29,"^7>",["^1G",["^7?",["^1G",[["^7C","~$comment-vec-seq"]]]]],"^7D","Take a single vector of inline comments\n  [[indent-index inline-comment-index] [indent-index inline-comment-index]\n   ...] and replace it with [[inline-comment-index start-column spaces-before]\n   [inline-comment-index start-column spaces-before] ...]"],"^10","^2P","^6","zprint/comment.cljc","^:",29,"^7E",["^1G",[["^7C","^89"]]],"^7G",null,"^7H",["^1G",[null,null]],"^8",1,"^7I",false,"^7",530,"^7J","~$cljs.core/LazySeq","^9",530,"^7M",2,"^7N",true,"^7>",["^1G",["^7?",["^1G",[["^7C","^89"]]]]],"^7D","Take a single vector of inline comments\n  [[indent-index inline-comment-index] [indent-index inline-comment-index]\n   ...] and replace it with [[inline-comment-index start-column spaces-before]\n   [inline-comment-index start-column spaces-before] ...]"],"~$lift-style-vec",["^ ","^7=",null,"^5",["^ ","^6","zprint/comment.cljc","^7",283,"^8",7,"^9",283,"^:",21,"^7>",["^1G",["^7?",["^1G",[["^7C"]]]]],"^7D","Take a style-vec [[s color type] [s color type] [[s color type]\n  [s color type]] [s color type] ...] and lift out the inner vectors."],"^10","^3:","^6","zprint/comment.cljc","^:",21,"^7E",["^1G",[["^7C"]]],"^7G",null,"^7H",["^1G",[null,null]],"^8",1,"^7I",false,"^7",283,"^7J",["^[",[null,"^7P"]],"^9",283,"^7M",1,"^7N",true,"^7>",["^1G",["^7?",["^1G",[["^7C"]]]]],"^7D","Take a style-vec [[s color type] [s color type] [[s color type]\n  [s color type]] [s color type] ...] and lift out the inner vectors."],"~$lift-vec",["^ ","^7=",null,"^5",["^ ","^6","zprint/comment.cljc","^7",271,"^8",7,"^9",271,"^:",15,"^7>",["^1G",["^7?",["^1G",[["~$out-vec","^86"]]]]],"^7D","Take a transient output vector and a vector and lift any style-vec elements\n  out of the input vector."],"^10","^20","^6","zprint/comment.cljc","^:",15,"^7E",["^1G",[["^8=","^86"]]],"^7G",null,"^7H",["^1G",[null,null]],"^8",1,"^7I",false,"^7",271,"^7J",["^[",[null,"^7K"]],"^9",271,"^7M",2,"^7N",true,"^7>",["^1G",["^7?",["^1G",[["^8=","^86"]]]]],"^7D","Take a transient output vector and a vector and lift any style-vec elements\n  out of the input vector."],"~$last-space",["^ ","^7=",null,"^5",["^ ","^6","zprint/comment.cljc","^7",182,"^8",7,"^9",182,"^:",17,"^7>",["^1G",["^7?",["^1G",[["~$s","~$from-index"]]]]],"^7D","Take a string and an index, and look for the last space prior to the\n  index. If we wanted to tie ourselves to 1.8, we could use \n  clojure.string/last-index-of, but we don't.  However, we use similar\n  conventions, i.e., if no space is found, return nil, and if the index\n  is a space return that value, and accept any from-index, including one\n  larger than the length of the string."],"^10","^2X","^6","zprint/comment.cljc","^:",17,"^7E",["^1G",[["~$s","^8?"]]],"^7G",null,"^7H",["^1G",[null,null]],"^8",1,"^7I",false,"^7",182,"^7J",["^[",["^7S","^7T"]],"^9",182,"^7M",2,"^7N",true,"^7>",["^1G",["^7?",["^1G",[["~$s","^8?"]]]]],"^7D","Take a string and an index, and look for the last space prior to the\n  index. If we wanted to tie ourselves to 1.8, we could use \n  clojure.string/last-index-of, but we don't.  However, we use similar\n  conventions, i.e., if no space is found, return nil, and if the index\n  is a space return that value, and accept any from-index, including one\n  larger than the length of the string."],"~$comment-vec-all-column",["^ ","^7=",null,"^5",["^ ","^6","zprint/comment.cljc","^7",538,"^8",7,"^9",538,"^:",29,"^7>",["^1G",["^7?",["^1G",[["^7C","~$comment-vec-all"]]]]],"^7D","Take a seq of all of the comments as produced by \n  find-consecutive-inline-comments, and turn it into:\n  [[[inline-comment-index start-column spaces-before] [inline-comment-index\n  start-column spaces-before]\n  ...] ...]"],"^10","^30","^6","zprint/comment.cljc","^:",29,"^7E",["^1G",[["^7C","^8A"]]],"^7G",null,"^7H",["^1G",[null,null]],"^8",1,"^7I",false,"^7",538,"^7J","^8:","^9",538,"^7M",2,"^7N",true,"^7>",["^1G",["^7?",["^1G",[["^7C","^8A"]]]]],"^7D","Take a seq of all of the comments as produced by \n  find-consecutive-inline-comments, and turn it into:\n  [[[inline-comment-index start-column spaces-before] [inline-comment-index\n  start-column spaces-before]\n  ...] ...]"],"~$comment-column",["^ ","^7=",null,"^5",["^ ","^6","zprint/comment.cljc","^7",507,"^8",7,"^9",507,"^:",21,"^7>",["^1G",["^7?",["^1G",[[["^7[","~$comment-index"],"^7C"]]]]],"^7D","Takes a single vector of [indent-index comment-index] and will show the\n  column on the line in which the comment starts."],"^10","^2I","^6","zprint/comment.cljc","^:",21,"^7E",["^1G",[["~$p__41932","^7C"]]],"^7G",null,"^7H",["^1G",[null,null]],"^8",1,"^7I",false,"^7",507,"^7J","^7S","^9",507,"^7M",2,"^7N",true,"^7>",["^1G",["^7?",["^1G",[[["^7[","^8C"],"^7C"]]]]],"^7D","Takes a single vector of [indent-index comment-index] and will show the\n  column on the line in which the comment starts."],"~$line-size",["^ ","^7=",null,"^5",["^ ","^6","zprint/comment.cljc","^7",315,"^8",7,"^9",315,"^:",16,"^7>",["^1G",["^7?",["^1G",[["^7C"]]]]],"^7D","Given a style-vec, how big is it in actual characters.  This doesn't\n  handle newlines."],"^10","^2J","^6","zprint/comment.cljc","^:",16,"^7E",["^1G",[["^7C"]]],"^7G",null,"^7H",["^1G",[null,null]],"^8",1,"^7I",false,"^7",315,"^7J","^7P","^9",315,"^7M",1,"^7N",true,"^7>",["^1G",["^7?",["^1G",[["^7C"]]]]],"^7D","Given a style-vec, how big is it in actual characters.  This doesn't\n  handle newlines."],"~$minimum-column",["^ ","^7=",null,"^5",["^ ","^6","zprint/comment.cljc","^7",547,"^8",7,"^9",547,"^:",21,"^7>",["^1G",["^7?",["^1G",[["^81"]]]]],"^7D","Given a set of inline comments:\n  [[inline-comment-index start-column spaces-before]\n   [inline-comment-index start-column spaces-before] ...], determine\n   the minimum column at which they could be aligned."],"^10","^3K","^6","zprint/comment.cljc","^:",21,"^7E",["^1G",[["^81"]]],"^7G",null,"^7H",["^1G",[null,null]],"^8",1,"^7I",false,"^7",547,"^7J","^7P","^9",547,"^7M",1,"^7N",true,"^7>",["^1G",["^7?",["^1G",[["^81"]]]]],"^7D","Given a set of inline comments:\n  [[inline-comment-index start-column spaces-before]\n   [inline-comment-index start-column spaces-before] ...], determine\n   the minimum column at which they could be aligned."],"~$find-aligned-inline-comments",["^ ","^7=",null,"^5",["^ ","^6","zprint/comment.cljc","^7",368,"^8",7,"^9",368,"^:",35,"^7>",["^1G",["^7?",["^1G",[["^7C"]]]]],"^7D","Given a style-vec, find previously aligned inline comments and\n  output the as a sequence of vectors of comments. The previously\n  aligned comments do not have to be consecutive, but they can't\n  be separated by more than max-aligned-inline-comment-distance.\n  Each comment itself is a vector: [indent-index inline-comment-index],\n  yielding a [[[indent-index inline-comment-index] [indent-index\n  inline-comment-index] ...] ...].  The indexes are into the\n  style-vec."],"^10","^2M","^6","zprint/comment.cljc","^:",35,"^7E",["^1G",[["^7C"]]],"^7G",null,"^7H",["^1G",[null,null]],"^8",1,"^7I",false,"^7",368,"^7J",["^[",["^7K","^7P"]],"^9",368,"^7M",1,"^7N",true,"^7>",["^1G",["^7?",["^1G",[["^7C"]]]]],"^7D","Given a style-vec, find previously aligned inline comments and\n  output the as a sequence of vectors of comments. The previously\n  aligned comments do not have to be consecutive, but they can't\n  be separated by more than max-aligned-inline-comment-distance.\n  Each comment itself is a vector: [indent-index inline-comment-index],\n  yielding a [[[indent-index inline-comment-index] [indent-index\n  inline-comment-index] ...] ...].  The indexes are into the\n  style-vec."],"~$change-start-column",["^ ","^7=",null,"^5",["^ ","^6","zprint/comment.cljc","^7",557,"^8",7,"^9",557,"^:",26,"^7>",["^1G",["^7?",["^1G",[["~$new-start-column","^7C",["^80","~$start-column","~$spaces-before","^1J","^81"]]]]]],"^7D","Given a new start-column, and a vector \n  [[inline-comment-index start-column spaces-before]\n  and a style-vec, return a new style-vec with the inline-comment starting\n  at a new column."],"^10","^2L","^6","zprint/comment.cljc","^:",26,"^7E",["^1G",[["^8I","^7C","~$p__41949"]]],"^7G",null,"^7H",["^1G",[null,null]],"^8",1,"^7I",false,"^7",557,"^7J",["^[",["^7K","^7P"]],"^9",557,"^7M",3,"^7N",true,"^7>",["^1G",["^7?",["^1G",[["^8I","^7C",["^80","^8J","^8K","^1J","^81"]]]]]],"^7D","Given a new start-column, and a vector \n  [[inline-comment-index start-column spaces-before]\n  and a style-vec, return a new style-vec with the inline-comment starting\n  at a new column."],"~$style-loc-vec",["^ ","^7=",null,"^5",["^ ","^6","zprint/comment.cljc","^7",263,"^8",7,"^9",263,"^:",20,"^7>",["^1G",["^7?",["^1G",[["~$indent","^7C"]]]]],"^7D","Take a style-vec and produce a style-loc-vec with the starting column\n  of each element in the style-vec. Accepts a beginning indent."],"^10","^3@","^6","zprint/comment.cljc","^:",20,"^7E",["^1G",[["^8N","^7C"]]],"^7G",null,"^7H",["^1G",[null,null]],"^8",1,"^7I",false,"^7",263,"^7J","~$seq","^9",263,"^7M",2,"^7N",true,"^7>",["^1G",["^7?",["^1G",[["^8N","^7C"]]]]],"^7D","Take a style-vec and produce a style-loc-vec with the starting column\n  of each element in the style-vec. Accepts a beginning indent."],"~$find-consecutive-inline-comments",["^ ","^7=",null,"^5",["^ ","^6","zprint/comment.cljc","^7",456,"^8",7,"^9",456,"^:",39,"^7>",["^1G",["^7?",["^1G",[["^7C"]]]]],"^7D","Given a style-vec, find consecutive inline comments and output\n  the as a sequence of vectors of comments.  Each comment itself\n  is a vector: [indent-index inline-comment-index], yielding a\n  [[[indent-index inline-comment-index] [indent-index inline-comment-index]\n  ...] ...]"],"^10","^3G","^6","zprint/comment.cljc","^:",39,"^7E",["^1G",[["^7C"]]],"^7G",null,"^7H",["^1G",[null,null]],"^8",1,"^7I",false,"^7",456,"^7J","^7P","^9",456,"^7M",1,"^7N",true,"^7>",["^1G",["^7?",["^1G",[["^7C"]]]]],"^7D","Given a style-vec, find consecutive inline comments and output\n  the as a sequence of vectors of comments.  Each comment itself\n  is a vector: [indent-index inline-comment-index], yielding a\n  [[[indent-index inline-comment-index] [indent-index inline-comment-index]\n  ...] ...]"],"~$fzprint-align-inline-comments",["^ ","^7=",null,"^5",["^ ","^6","zprint/comment.cljc","^7",592,"^8",7,"^9",592,"^:",36,"^7>",["^1G",["^7?",["^1G",[["^7B","^7C"]]]]],"^7D","Given the current style-vec, align all consecutive inline comments."],"^10","^33","^6","zprint/comment.cljc","^:",36,"^7E",["^1G",[["^7B","^7C"]]],"^7G",null,"^7H",["^1G",[null,null]],"^8",1,"^7I",false,"^7",592,"^7J",["^[",[null,"^7P"]],"^9",592,"^7M",2,"^7N",true,"^7>",["^1G",["^7?",["^1G",[["^7B","^7C"]]]]],"^7D","Given the current style-vec, align all consecutive inline comments."],"~$align-comment-vec",["^ ","^7=",null,"^5",["^ ","^6","zprint/comment.cljc","^7",583,"^8",7,"^9",583,"^:",24,"^7>",["^1G",["^7?",["^1G",[["^7C","^81"]]]]],"^7D","Given one set of inline comments: \n  [[inline-comment-index start-column spaces-before]\n   [inline-comment-index start-column spaces-before] ...], align them \n   as best as possible, and return the modified style-vec."],"^10","^3L","^6","zprint/comment.cljc","^:",24,"^7E",["^1G",[["^7C","^81"]]],"^7G",null,"^7H",["^1G",[null,null]],"^8",1,"^7I",false,"^7",583,"^7J",["^[",[null,"^7P"]],"^9",583,"^7M",2,"^7N",true,"^7>",["^1G",["^7?",["^1G",[["^7C","^81"]]]]],"^7D","Given one set of inline comments: \n  [[inline-comment-index start-column spaces-before]\n   [inline-comment-index start-column spaces-before] ...], align them \n   as best as possible, and return the modified style-vec."],"~$left-or-up",["^ ","^7=",null,"^5",["^ ","^6","zprint/comment.cljc","^7",61,"^8",7,"^9",61,"^:",17,"^7>",["^1G",["^7?",["^1G",[["^7Y"]]]]],"^7D","Take a zloc and move left if possible, or move up if necessary.\n  Return a vector with [up-size new-zloc]"],"^10","^3O","^6","zprint/comment.cljc","^:",17,"^7E",["^1G",[["^7Y"]]],"^7G",null,"^7H",["^1G",[null,null]],"^8",1,"^7I",false,"^7",61,"^7J","^7L","^9",61,"^7M",1,"^7N",true,"^7>",["^1G",["^7?",["^1G",[["^7Y"]]]]],"^7D","Take a zloc and move left if possible, or move up if necessary.\n  Return a vector with [up-size new-zloc]"],"~$inlinecomment?",["^ ","^7=",null,"^5",["^ ","^6","zprint/comment.cljc","^7",122,"^8",7,"^9",122,"^:",21,"^7>",["^1G",["^7?",["^1G",[["^7Y"]]]]],"^7D","If this is an inline comment, returns a vector with the amount\n  of space that was between this and the previous element and the\n  starting column of this inline comment.  That means that if we\n  go left, we get something other than whitespace before a newline.\n  If we get only whitespace before a newline, then this is considered\n  an inline comment if the comment at the end of the previous line\n  was an inline comment and we were aligned with that comment.\n  Assumes zloc is a comment."],"^10","^3Q","^6","zprint/comment.cljc","^:",21,"^7E",["^1G",[["^7Y"]]],"^7G",null,"^7H",["^1G",[null,null]],"^8",1,"^7I",false,"^7",122,"^7J",["^[",["^7L","^7T"]],"^9",122,"^7M",1,"^7N",true,"^7>",["^1G",["^7?",["^1G",[["^7Y"]]]]],"^7D","If this is an inline comment, returns a vector with the amount\n  of space that was between this and the previous element and the\n  starting column of this inline comment.  That means that if we\n  go left, we get something other than whitespace before a newline.\n  If we get only whitespace before a newline, then this is considered\n  an inline comment if the comment at the end of the previous line\n  was an inline comment and we were aligned with that comment.\n  Assumes zloc is a comment."],"~$tag-l-size",["^ ","^7=",null,"^5",["^ ","^6","zprint/comment.cljc","^7",37,"^8",7,"^9",37,"^:",17,"^7>",["^1G",["^7?",["^1G",[["~$t"]]]]],"^7D","Given a tag into which you can go down from rewrite-clj, which must be\n  a collection of some kind, return the size the l-str.  All of the tag\n  values into which you can go down must be in this list for indent-before\n  to work correctly.  It uses these values when it steps up out of one of\n  these things to see how big the thing would have been if it showed up\n  as characters."],"^10","^3<","^6","zprint/comment.cljc","^:",17,"^7E",["^1G",[["~$t"]]],"^7G",null,"^7H",["^1G",[null,null]],"^8",1,"^7I",false,"^7",37,"^9",37,"^7M",1,"^7N",true,"^7>",["^1G",["^7?",["^1G",[["~$t"]]]]],"^7D","Given a tag into which you can go down from rewrite-clj, which must be\n  a collection of some kind, return the size the l-str.  All of the tag\n  values into which you can go down must be in this list for indent-before\n  to work correctly.  It uses these values when it steps up out of one of\n  these things to see how big the thing would have been if it showed up\n  as characters."],"~$next-space",["^ ","^7=",null,"^5",["^ ","^6","zprint/comment.cljc","^7",196,"^8",7,"^9",196,"^:",17,"^7>",["^1G",["^7?",["^1G",[["~$s","^8?"]]]]],"^7D","Take a string and an index, and look for the next space *after* the\n  index. If no space is found, return nil. Accept any from-index, \n  including one larger than the length of the string."],"^10","^3=","^6","zprint/comment.cljc","^:",17,"^7E",["^1G",[["~$s","^8?"]]],"^7G",null,"^7H",["^1G",[null,null]],"^8",1,"^7I",false,"^7",196,"^7J",["^[",["^7S","^7T"]],"^9",196,"^7M",2,"^7N",true,"^7>",["^1G",["^7?",["^1G",[["~$s","^8?"]]]]],"^7D","Take a string and an index, and look for the next space *after* the\n  index. If no space is found, return nil. Accept any from-index, \n  including one larger than the length of the string."],"~$max-aligned-inline-comment-distance",["^ ","^10","^3C","^6","zprint/comment.cljc","^7",366,"^8",1,"^9",366,"^:",41,"^5",["^ ","^6","zprint/comment.cljc","^7",366,"^8",6,"^9",366,"^:",41],"~:tag","^7S"],"~$space-before-comment",["^ ","^7=",null,"^5",["^ ","^6","zprint/comment.cljc","^7",321,"^8",7,"^9",321,"^:",27,"^7>",["^1G",["^7?",["^1G",[["^7C"]]]]],"^7D","Given a style-vec, whose last element in a comment, find the amount\n  of space before that comment on the line."],"^10","^3A","^6","zprint/comment.cljc","^:",27,"^7E",["^1G",[["^7C"]]],"^7G",null,"^7H",["^1G",[null,null]],"^8",1,"^7I",false,"^7",321,"^7J","^7P","^9",321,"^7M",1,"^7N",true,"^7>",["^1G",["^7?",["^1G",[["^7C"]]]]],"^7D","Given a style-vec, whose last element in a comment, find the amount\n  of space before that comment on the line."],"~$length-after-newline",["^ ","^7=",null,"^5",["^ ","^6","zprint/comment.cljc","^7",81,"^8",7,"^9",81,"^:",27,"^7>",["^1G",["^7?",["^1G",[["~$s"]]]]],"^7D","Given a string, return the number of characters to the right\n  of any newlines in the string.  Will return nil if no newlines\n  in the string."],"^10","^3?","^6","zprint/comment.cljc","^:",27,"^7E",["^1G",[["~$s"]]],"^7G",null,"^7H",["^1G",[null,null]],"^8",1,"^7I",false,"^7",81,"^7J",["^[",["^7S","^7T"]],"^9",81,"^7M",1,"^7N",true,"^7>",["^1G",["^7?",["^1G",[["~$s"]]]]],"^7D","Given a string, return the number of characters to the right\n  of any newlines in the string.  Will return nil if no newlines\n  in the string."],"~$fzprint-wrap-comments",["^ ","^7=",null,"^5",["^ ","^6","zprint/comment.cljc","^7",289,"^8",7,"^9",289,"^:",28,"^7>",["^1G",["^7?",["^1G",[[["^ ","^7@",["^7A"],"^1J","^7B"],"^7C"]]]]],"^7D","Take the final output style-vec, and wrap any comments which run over\n  the width. Looking for "],"^10","^3E","^6","zprint/comment.cljc","^:",28,"^7E",["^1G",[["~$p__41755","^7C"]]],"^7G",null,"^7H",["^1G",[null,null]],"^8",1,"^7I",false,"^7",289,"^7J",["^[",[null,"^7P"]],"^9",289,"^7M",2,"^7N",true,"^7>",["^1G",["^7?",["^1G",[[["^ ","^7@",["^7A"],"^1J","^7B"],"^7C"]]]]],"^7D","Take the final output style-vec, and wrap any comments which run over\n  the width. Looking for "],"~$split-lf",["^ ","^7=",null,"^5",["^ ","^6","zprint/comment.cljc","^7",26,"^8",7,"^9",26,"^:",15,"^7>",["^1G",["^7?",["^1G",[["~$s"]]]]],"^7D","Do split for newlines, instead of using regular expressions."],"^10","^2Z","^6","zprint/comment.cljc","^:",15,"^7E",["^1G",[["~$s"]]],"^7G",null,"^7H",["^1G",[null,null]],"^8",1,"^7I",false,"^7",26,"^7J",["^[",["^7K","^7L"]],"^9",26,"^7M",1,"^7N",true,"^7>",["^1G",["^7?",["^1G",[["~$s"]]]]],"^7D","Do split for newlines, instead of using regular expressions."]],"^1>",["^ ","^U","^U","^1:","^1:","^19","^19","~$z","^19"],"~:cljs.analyzer/constants",["^ ","^1<",["^[",["~:comment-wrap","~:indent","~:whitespace","~:else","~:comma","~:dbg-indent","~:width","~:aligned","~:inline-align-style","~:dbg?","~:comment","~:comment-inline","~:newline","~:consecutive","~:none"]],"~:order",["^95","^97","^9?","^9=","^9>","^96","^9A","^94","^93","^99","^9<","^98","^9;","^9:","^9@"]],"^1K",["^ ","^1>",["^[",[]],"^1=",["^[",[]]],"^1L",["^ "],"^1M",["^1;","^1:","^17","^18","^19"]],"^14","^11","~:ns-specs",["^ "],"~:ns-spec-vars",["^[",[]],"~:compiler-options",["^3T",[["^9E","~:static-fns"],true,["^9E","~:shadow-tweaks"],null,["^9E","~:source-map-inline"],null,["^9E","~:elide-asserts"],false,["^9E","~:optimize-constants"],null,["^9E","^1R"],null,["^9E","~:external-config"],null,["^9E","~:tooling-config"],null,["^9E","~:emit-constants"],null,["^9E","~:load-tests"],null,["^9E","~:form-size-threshold"],null,["^9E","~:global-goog-object&array"],null,["^9E","~:data-readers"],null,["^9E","~:infer-externs"],"~:auto",["^9E","^1T"],null,["~:js-options","~:js-provider"],"~:shadow",["~:mode"],"~:dev",["^9E","~:fn-invoke-direct"],null,["^9E","~:source-map"],"/dev/null"]]]