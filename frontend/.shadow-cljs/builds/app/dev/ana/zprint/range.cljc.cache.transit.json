["^ ","~:output",["^ ","~:js","goog.provide('zprint.range');\n/**\n * If a line number n is in a particular row, return the row map.\n *   If it is not in the row, return +1 or -1 to indicate which direction\n *   to look.\n */\nzprint.range.in_row_QMARK_ = (function zprint$range$in_row_QMARK_(n,row){\nif(cljs.core.truth_(row)){\nif((((new cljs.core.Keyword(null,\"row\",\"row\",-570139521).cljs$core$IFn$_invoke$arity$1(row) <= n)) && ((n <= new cljs.core.Keyword(null,\"end-row\",\"end-row\",-545103581).cljs$core$IFn$_invoke$arity$1(row))))){\nreturn row;\n} else {\nif((n < new cljs.core.Keyword(null,\"row\",\"row\",-570139521).cljs$core$IFn$_invoke$arity$1(row))){\nreturn (-1);\n} else {\nreturn (1);\n}\n}\n} else {\nreturn null;\n}\n});\n/**\n * Given two rows, is the first before the second?\n */\nzprint.range.row_before_QMARK_ = (function zprint$range$row_before_QMARK_(row_a,row_b){\nreturn (new cljs.core.Keyword(null,\"end-row\",\"end-row\",-545103581).cljs$core$IFn$_invoke$arity$1(row_a) < new cljs.core.Keyword(null,\"row\",\"row\",-570139521).cljs$core$IFn$_invoke$arity$1(row_b));\n});\n/**\n * Given two rows, if the linenumber is between the rows, return true, else\n *   nil.\n */\nzprint.range.between_rows_QMARK_ = (function zprint$range$between_rows_QMARK_(linenumber,row_a,row_b){\nif(((cljs.core.map_QMARK_(row_a)) && (cljs.core.map_QMARK_(row_b)))){\nif(zprint.range.row_before_QMARK_(row_a,row_b)){\nreturn (((new cljs.core.Keyword(null,\"end-row\",\"end-row\",-545103581).cljs$core$IFn$_invoke$arity$1(row_a) < linenumber)) && ((linenumber < new cljs.core.Keyword(null,\"row\",\"row\",-570139521).cljs$core$IFn$_invoke$arity$1(row_b))));\n} else {\nreturn (((new cljs.core.Keyword(null,\"end-row\",\"end-row\",-545103581).cljs$core$IFn$_invoke$arity$1(row_b) < linenumber)) && ((linenumber < new cljs.core.Keyword(null,\"row\",\"row\",-570139521).cljs$core$IFn$_invoke$arity$1(row_a))));\n}\n} else {\nreturn null;\n}\n});\n/**\n * Given a row-vec, and a current index into the row-vec, if the\n *   linenumber is within that row, return the index to that row.   If\n *   the linenumber is not in that row, then scan either way for\n *   max-tries looking for a match for this linenumber.  Return the\n *   row index if a row is found containing this linenumber. If it is\n *   between two rows, return the row after.  If we fall off the either\n *   end of the row-vec, then return :before-beginning or :beyone-end.  \n *   If we don't find anything after trying for max-tries, :before or\n *   :after, depending on which way we should try next.\n */\nzprint.range.scan_for_row = (function zprint$range$scan_for_row(row_vec,row_vec_index,linenumber,max_tries){\nvar current_index = row_vec_index;\nvar previous_index = null;\nvar tries = (0);\nwhile(true){\nvar row = cljs.core.get.cljs$core$IFn$_invoke$arity$2(row_vec,current_index);\nvar row_or_direction = zprint.range.in_row_QMARK_(linenumber,row);\nif(cljs.core.map_QMARK_(row_or_direction)){\nreturn current_index;\n} else {\nif((row_or_direction == null)){\nif((current_index > (0))){\nreturn new cljs.core.Keyword(null,\"beyond-end\",\"beyond-end\",487000285);\n} else {\nreturn new cljs.core.Keyword(null,\"before-beginning\",\"before-beginning\",485705715);\n}\n} else {\nif((tries >= max_tries)){\nif((row_or_direction > (0))){\nreturn new cljs.core.Keyword(null,\"after\",\"after\",594996914);\n} else {\nreturn new cljs.core.Keyword(null,\"before\",\"before\",-1633692388);\n}\n} else {\nvar next_index = (current_index + row_or_direction);\nvar next_row = cljs.core.get.cljs$core$IFn$_invoke$arity$2(row_vec,next_index);\nvar row_or_direction__$1 = zprint.range.in_row_QMARK_(linenumber,next_row);\nif(cljs.core.map_QMARK_(row_or_direction__$1)){\nreturn next_index;\n} else {\nif((row_or_direction__$1 == null)){\nif((next_index > (0))){\nreturn new cljs.core.Keyword(null,\"beyond-end\",\"beyond-end\",487000285);\n} else {\nreturn new cljs.core.Keyword(null,\"before-beginning\",\"before-beginning\",485705715);\n}\n} else {\nif(cljs.core.truth_(zprint.range.between_rows_QMARK_(linenumber,row,next_row))){\nif(zprint.range.row_before_QMARK_(row,next_row)){\nreturn next_index;\n} else {\nreturn current_index;\n}\n} else {\nvar G__56764 = (current_index + row_or_direction__$1);\nvar G__56765 = current_index;\nvar G__56766 = (tries + (1));\ncurrent_index = G__56764;\nprevious_index = G__56765;\ntries = G__56766;\ncontinue;\n}\n\n}\n}\n}\n\n}\n}\nbreak;\n}\n});\n/**\n * Given a vector of rows, find the row that contains a line number,\n *   linenumber, and return the number of that row in the vector.\n *   row-vec looks like this: \n *   [{:col 1, :end-col 21, :end-row 7, :row 2}\n * {:col 1, :end-col 6, :end-row 18, :row 9}\n * {:col 1, :end-col 6, :end-row 29, :row 20}]\n *   If none exists, return the next row. Note that line numbers are\n *   1 based, not zero based for this routine and the information in\n *   row-vec, but the index into row-vec that this routine returns is\n *   zero based.  Uses a binary search. If the line number is before\n *   the first information in the row-vec, returns :before-beginning,\n *   and if it is after the last information in the row-vec, returns\n *   :beyond-end. Note that find-row returns an index into row-vec,\n *   and it must be the row-vec that has had nils removed from it (or\n *   this routine would do that for you).\n */\nzprint.range.find_row = (function zprint$range$find_row(var_args){\nvar G__56733 = arguments.length;\nswitch (G__56733) {\ncase 4:\nreturn zprint.range.find_row.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase 3:\nreturn zprint.range.find_row.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(zprint.range.find_row.cljs$core$IFn$_invoke$arity$4 = (function (row_vec,linenumber,dbg_QMARK_,scan_size){\nif(cljs.core.truth_(dbg_QMARK_)){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"find-row: linenumber:\",linenumber,\"scan-size:\",scan_size], 0));\n} else {\n}\n\nvar size = cljs.core.count(row_vec);\nvar row_vec_index = ((size / (2)) | (0));\nvar previous_index = (0);\nvar tries = (0);\nwhile(true){\nif((tries > (10))){\nreturn new cljs.core.Keyword(null,\"fail\",\"fail\",1706214930);\n} else {\nvar maybe_index = zprint.range.scan_for_row(row_vec,row_vec_index,linenumber,scan_size);\nif(typeof maybe_index === 'number'){\nreturn maybe_index;\n} else {\nif(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(maybe_index,new cljs.core.Keyword(null,\"before-beginning\",\"before-beginning\",485705715))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(maybe_index,new cljs.core.Keyword(null,\"beyond-end\",\"beyond-end\",487000285))))){\nreturn maybe_index;\n} else {\nvar G__56768 = (function (){var G__56739 = row_vec_index;\nvar G__56740 = ((zprint.util.local_abs((row_vec_index - previous_index)) / (2)) | (0));\nvar fexpr__56738 = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(maybe_index,new cljs.core.Keyword(null,\"before\",\"before\",-1633692388)))?cljs.core._:cljs.core._PLUS_);\nreturn (fexpr__56738.cljs$core$IFn$_invoke$arity$2 ? fexpr__56738.cljs$core$IFn$_invoke$arity$2(G__56739,G__56740) : fexpr__56738.call(null,G__56739,G__56740));\n})();\nvar G__56769 = row_vec_index;\nvar G__56770 = (tries + (1));\nrow_vec_index = G__56768;\nprevious_index = G__56769;\ntries = G__56770;\ncontinue;\n\n}\n}\n}\nbreak;\n}\n}));\n\n(zprint.range.find_row.cljs$core$IFn$_invoke$arity$3 = (function (row_vec,n,dbg_QMARK_){\nreturn zprint.range.find_row.cljs$core$IFn$_invoke$arity$4(row_vec,n,dbg_QMARK_,(4));\n}));\n\n(zprint.range.find_row.cljs$lang$maxFixedArity = 4);\n\n/**\n * Given a sequence of lines and a starting line index in that sequence,\n *   return the index of the first non-blank line including or after that\n *   starting line index.\n */\nzprint.range.next_non_blank_line = (function zprint$range$next_non_blank_line(line_vec,index){\nvar max_idx = (cljs.core.count(line_vec) - (1));\nvar idx = index;\nwhile(true){\nvar line = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(line_vec,idx);\nif((((!(cljs.core.empty_QMARK_(clojure.string.trim(line))))) || ((idx >= max_idx)))){\nreturn idx;\n} else {\nvar G__56771 = (idx + (1));\nidx = G__56771;\ncontinue;\n}\nbreak;\n}\n});\n/**\n * Given a sequence of lines and a starting line index in that sequence,\n *   return the index of the first previous non-blank line including or before\n *   that starting line index.  Returns -1 if no non-blank line found.\n */\nzprint.range.previous_non_blank_line = (function zprint$range$previous_non_blank_line(line_vec,index){\nvar idx = index;\nwhile(true){\nvar line = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(line_vec,idx);\nif((!(cljs.core.empty_QMARK_(clojure.string.trim(line))))){\nreturn idx;\n} else {\nif((idx === (0))){\nreturn (-1);\n} else {\nvar G__56772 = (idx - (1));\nidx = G__56772;\ncontinue;\n\n}\n}\nbreak;\n}\n});\n/**\n * Given a string which contains lines and a vector of those lines,\n *   and a range of lines inside of them, expand the range such that\n *   it covers everything from the first non-blank line beyond the\n *   previous top level expression before the start to the end of the\n *   top level expression containing the end of the range.  Returns\n *   [actual-start actual-end].  Note that start, end, actual-start\n *   and actual-end are all zero based line numbers.\n */\nzprint.range.expand_range_to_top_level = (function zprint$range$expand_range_to_top_level(filestring,lines,start,end,dbg_QMARK_){\nif(cljs.core.truth_(dbg_QMARK_)){\ncljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"expand-range-to-top-level: start:\",start,\"end:\",end], 0));\n} else {\n}\n\nvar line_count = cljs.core.count(lines);\nvar start__$1 = ((typeof start === 'number')?start:(0));\nvar end__$1 = ((typeof end === 'number')?end:line_count);\nvar end__$2 = (((end__$1 < start__$1))?start__$1:end__$1);\nvar row_vec = cljs.core.mapv.cljs$core$IFn$_invoke$arity$2(cljs.core.meta,cljs.core.remove.cljs$core$IFn$_invoke$arity$2((function (p1__56746_SHARP_){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(rewrite_clj.node.tag(p1__56746_SHARP_),new cljs.core.Keyword(null,\"comment\",\"comment\",532206069));\n}),cljs.core.remove.cljs$core$IFn$_invoke$arity$2(rewrite_clj.node.whitespace_QMARK_,rewrite_clj.node.children(rewrite_clj.parser.parse_string_all(filestring)))));\nvar _ = (cljs.core.truth_(dbg_QMARK_)?cljs.core.prn.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([row_vec], 0)):null);\nvar start_row_idx = (cljs.core.truth_(row_vec)?zprint.range.find_row.cljs$core$IFn$_invoke$arity$3(row_vec,(start__$1 + (1)),dbg_QMARK_):new cljs.core.Keyword(null,\"fail\",\"fail\",1706214930));\nvar ___$1 = (cljs.core.truth_(dbg_QMARK_)?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"expand-range-to-top-level start-row-idx:\",start_row_idx,((typeof start_row_idx === 'number')?[\"row:\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.nth.cljs$core$IFn$_invoke$arity$2(row_vec,start_row_idx)),\" previous row:\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.nth.cljs$core$IFn$_invoke$arity$2(row_vec,(function (){var x__5130__auto__ = (0);\nvar y__5131__auto__ = (start_row_idx - (1));\nreturn ((x__5130__auto__ > y__5131__auto__) ? x__5130__auto__ : y__5131__auto__);\n})()))].join(''):\"\")], 0)):null);\nvar actual_start = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(start_row_idx,new cljs.core.Keyword(null,\"fail\",\"fail\",1706214930)))?(-1):((((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(start_row_idx,new cljs.core.Keyword(null,\"before-beginning\",\"before-beginning\",485705715))) && ((!((start__$1 < (0)))))))?(0):((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(start_row_idx,new cljs.core.Keyword(null,\"before-beginning\",\"before-beginning\",485705715)))?(-1):((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(start_row_idx,(0)))?(0):((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(start_row_idx,new cljs.core.Keyword(null,\"beyond-end\",\"beyond-end\",487000285)))?(-1):new cljs.core.Keyword(null,\"end-row\",\"end-row\",-545103581).cljs$core$IFn$_invoke$arity$1(cljs.core.get.cljs$core$IFn$_invoke$arity$2(row_vec,(start_row_idx - (1))))\n)))));\nvar actual_start__$1 = (((((actual_start < (1))) || ((actual_start >= line_count))))?actual_start:zprint.range.next_non_blank_line(lines,actual_start));\nvar end_row_idx = (cljs.core.truth_(row_vec)?zprint.range.find_row.cljs$core$IFn$_invoke$arity$3(row_vec,(end__$2 + (1)),dbg_QMARK_):new cljs.core.Keyword(null,\"fail\",\"fail\",1706214930));\nvar ___$2 = (cljs.core.truth_(dbg_QMARK_)?cljs.core.println.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"expand-range-to-top-level end-row-idx:\",end_row_idx,((typeof end_row_idx === 'number')?[\"row:\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.nth.cljs$core$IFn$_invoke$arity$2(row_vec,end_row_idx))].join(''):\"\")], 0)):null);\nvar actual_end = ((((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(end_row_idx,new cljs.core.Keyword(null,\"fail\",\"fail\",1706214930))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(end_row_idx,new cljs.core.Keyword(null,\"beyond-end\",\"beyond-end\",487000285)))))?((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(start_row_idx,new cljs.core.Keyword(null,\"beyond-end\",\"beyond-end\",487000285)))?(-1):line_count):((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(end_row_idx,new cljs.core.Keyword(null,\"before-beginning\",\"before-beginning\",485705715)))?new cljs.core.Keyword(null,\"do-nothing\",\"do-nothing\",1030476282):(function (){var end_row = cljs.core.get.cljs$core$IFn$_invoke$arity$2(row_vec,end_row_idx);\nif(((end__$2 + (1)) < new cljs.core.Keyword(null,\"row\",\"row\",-570139521).cljs$core$IFn$_invoke$arity$1(end_row))){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(end_row_idx,start_row_idx)){\nreturn new cljs.core.Keyword(null,\"do-nothing\",\"do-nothing\",1030476282);\n} else {\nreturn zprint.range.previous_non_blank_line(lines,end__$2);\n}\n} else {\nreturn (new cljs.core.Keyword(null,\"end-row\",\"end-row\",-545103581).cljs$core$IFn$_invoke$arity$1(end_row) - (1));\n}\n})()\n));\nvar actual_start__$2 = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(actual_end,new cljs.core.Keyword(null,\"do-nothing\",\"do-nothing\",1030476282)))?(-1):actual_start__$1);\nvar actual_end__$1 = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(actual_end,new cljs.core.Keyword(null,\"do-nothing\",\"do-nothing\",1030476282)))?(-1):actual_end);\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [actual_start__$2,actual_end__$1], null);\n});\n/**\n * Given lines, a sequence of lines, and a start and end of a range,\n *   split the sequence of lines into three parts: [before-lines range\n *   after-lines].  If any of these collections would be empty, return\n *   an empty sequence. End must be equal to or greater than start. If\n *   end is neg?, there will be no range. Note that for begin and range\n *   if they have something after them, we will add a null string to them,\n *   so that a join will have a newline on the end of it.\n */\nzprint.range.split_out_range = (function zprint$range$split_out_range(lines,start,end){\nvar start__$1 = (function (){var x__5130__auto__ = start;\nvar y__5131__auto__ = (0);\nreturn ((x__5130__auto__ > y__5131__auto__) ? x__5130__auto__ : y__5131__auto__);\n})();\nvar before = start__$1;\nvar range = (((end < (0)))?(0):((end - start__$1) + (1)));\nvar after = ((cljs.core.count(lines) - (1)) - end);\nvar before_lines = cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentVector.EMPTY,cljs.core.take.cljs$core$IFn$_invoke$arity$2(before,lines));\nvar range_lines = cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentVector.EMPTY,cljs.core.take.cljs$core$IFn$_invoke$arity$2(range,cljs.core.drop.cljs$core$IFn$_invoke$arity$2(before,lines)));\nvar after_lines = cljs.core.take.cljs$core$IFn$_invoke$arity$2(after,cljs.core.drop.cljs$core$IFn$_invoke$arity$2((before + range),lines));\nvar before_lines__$1 = (((!(cljs.core.empty_QMARK_(range_lines))))?cljs.core.conj.cljs$core$IFn$_invoke$arity$2(before_lines,\"\"):before_lines);\nvar range_lines__$1 = (((!(cljs.core.empty_QMARK_(after_lines))))?cljs.core.conj.cljs$core$IFn$_invoke$arity$2(range_lines,\"\"):range_lines);\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [before_lines__$1,range_lines__$1,after_lines], null);\n});\n/**\n * Given before-lines, range, and after-lines where before-lines\n *   and after-lines are sequences of lines, and range is a string\n *   which has been formatted, reassemble these three chunks into a\n *   single string.  Because split-out-range worked hard to figure\n *   out how to terminate before-lines and range with a newline,\n *   this is really pretty simple.\n */\nzprint.range.reassemble_range = (function zprint$range$reassemble_range(before_lines,range,after_lines){\nvar before_str = clojure.string.join.cljs$core$IFn$_invoke$arity$2(\"\\n\",before_lines);\nvar after_str = clojure.string.join.cljs$core$IFn$_invoke$arity$2(\"\\n\",after_lines);\nreturn [before_str,cljs.core.str.cljs$core$IFn$_invoke$arity$1(range),after_str].join('');\n});\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","zprint/range.cljc","~:line",1,"~:column",14,"~:end-line",1,"~:end-column",26,"~:no-doc",true],"~:ns-aliases",["^ ","~$clojure.spec.alpha","~$cljs.spec.alpha","~$clojure.tools.reader.impl.utils","~$cljs.tools.reader.impl.utils","~$cljs.loader","~$shadow.loader","~$clojure.tools.reader.impl.commons","~$cljs.tools.reader.impl.commons","~$clojure.tools.reader.impl.errors","~$cljs.tools.reader.impl.errors","~$react","~$module$node_modules$react$index","~$clojure.tools.reader.reader-types","~$cljs.tools.reader.reader-types","~$clojure.tools.reader.edn","~$cljs.tools.reader.edn","~$clojure.pprint","~$cljs.pprint","~$react-dom","~$module$node_modules$react_dom$index","~$clojure.repl","~$cljs.repl"],"~:use-macros",null,"~:excludes",["~#set",[]],"~:name","~$zprint.range","~:reader-aliases",["^ "],"~:op","~:ns","~:imports",null,"~:requires",["^ ","~$rewrite-clj.parser","^11","~$p","^11","~$rewrite-clj.node","^12","~$rewrite-clj.zip","^13","~$cljs.core","^14","~$goog","^15","~$n","^12","~$s","~$clojure.string","~$z","^13","^16","^16","~$zprint.util","^17"],"~:seen",["^U",["~:require"]],"~:uses",["^ ","~$local-abs","^17"],"~:require-macros",["^ ","^14","^14","^13","^13","~$z","^13"],"~:form",["~#list",["~$ns","^W",["^1>",["^19",["^16","~:as","~$s"],["^17","~:refer",["^1;"]],["^11","^1@","~$p"],["^12","^1@","~$n"],["^13","^1@","~$z"]]]]],"~:flags",["^ ","^19",["^U",[]]],"~:js-deps",["^ "],"~:deps",["^15","^14","^16","^17","^11","^12","^13"]],"^Z","^W","~:resource-id",["~:shadow.build.classpath/resource","zprint/range.cljc"],"~:compiled-at",1666857672074,"^X",["^ ","^11","^11","~$p","^11","^12","^12","^13","^13","^14","^14","^15","^15","~$n","^12","~$s","^16","~$z","^13","^16","^16","^17","^17"],"~:resource-name","zprint/range.cljc","~:warnings",[],"~:source","(ns ^:no-doc zprint.range\n  (:require [clojure.string :as s]\n            [zprint.util :refer [local-abs]]\n            [rewrite-clj.parser :as p]\n            [rewrite-clj.node :as n]\n            [rewrite-clj.zip :as z]))\n\n;;\n;; # Handle range specification\n;;\n\n(defn in-row?\n  \"If a line number n is in a particular row, return the row map.\n  If it is not in the row, return +1 or -1 to indicate which direction\n  to look.\"\n  [n row]\n  #_(println \"n:\" n \"row:\" row)\n  (when row\n    (if (<= (:row row) n (:end-row row)) row (if (< n (:row row)) -1 +1))))\n\n(defn row-before?\n  \"Given two rows, is the first before the second?\"\n  [row-a row-b]\n  #_(println \"row-before? row-a:\" row-a \"row-b:\" row-b)\n  (< (:end-row row-a) (:row row-b)))\n\n(defn between-rows?\n  \"Given two rows, if the linenumber is between the rows, return true, else\n  nil.\"\n  [linenumber row-a row-b]\n  #_(println \"between-rows? linenumber:\" linenumber\n             \"row-a:\" row-a\n             \"row-b:\" row-b)\n  (when (and (map? row-a) (map? row-b))\n    (if (row-before? row-a row-b)\n      (< (:end-row row-a) linenumber (:row row-b))\n      (< (:end-row row-b) linenumber (:row row-a)))))\n\n(defn scan-for-row\n  \"Given a row-vec, and a current index into the row-vec, if the\n  linenumber is within that row, return the index to that row.   If\n  the linenumber is not in that row, then scan either way for\n  max-tries looking for a match for this linenumber.  Return the\n  row index if a row is found containing this linenumber. If it is\n  between two rows, return the row after.  If we fall off the either\n  end of the row-vec, then return :before-beginning or :beyone-end.  \n  If we don't find anything after trying for max-tries, :before or\n  :after, depending on which way we should try next.\"\n  [row-vec row-vec-index linenumber max-tries]\n  (loop [current-index row-vec-index\n         previous-index nil\n         tries 0]\n    (let [row (get row-vec current-index)\n          row-or-direction (in-row? linenumber row)]\n      #_(println \"scan-for-row current-index:\" current-index\n                 \"previous-index:\" previous-index\n                 \"tries:\" tries\n                 \"row:\" row\n                 \"row-or-direction\" row-or-direction)\n      (cond (map? row-or-direction) current-index   ; in this row\n            (nil? row-or-direction)\n              (if (pos? current-index) :beyond-end :before-beginning)\n            :else\n              (if (>= tries max-tries)\n                ; tell caller where to look next\n                (if (pos? row-or-direction) :after :before)\n                (let [next-index (+ current-index row-or-direction)\n                      next-row (get row-vec next-index)\n                      row-or-direction (in-row? linenumber next-row)]\n                  (cond (map? row-or-direction) next-index ; we are in the row,\n                                                           ; return its index\n                        (nil? row-or-direction)\n                          (if (pos? next-index) :beyond-end :before-beginning)\n                        :else (if (between-rows? linenumber row next-row)\n                                ; We are between rows, return later one\n                                (if (row-before? row next-row)\n                                  next-index\n                                  current-index)\n                                ; Keep looking\n                                (recur (+ current-index row-or-direction)\n                                       current-index\n                                       (inc tries))))))))))\n\n(defn find-row\n  \"Given a vector of rows, find the row that contains a line number,\n  linenumber, and return the number of that row in the vector.\n  row-vec looks like this: \n  [{:col 1, :end-col 21, :end-row 7, :row 2}\n   {:col 1, :end-col 6, :end-row 18, :row 9}\n   {:col 1, :end-col 6, :end-row 29, :row 20}]\n  If none exists, return the next row. Note that line numbers are\n  1 based, not zero based for this routine and the information in\n  row-vec, but the index into row-vec that this routine returns is\n  zero based.  Uses a binary search. If the line number is before\n  the first information in the row-vec, returns :before-beginning,\n  and if it is after the last information in the row-vec, returns\n  :beyond-end. Note that find-row returns an index into row-vec,\n  and it must be the row-vec that has had nils removed from it (or\n  this routine would do that for you).\"\n  ([row-vec linenumber dbg? scan-size]\n   (when dbg?\n     (println \"find-row: linenumber:\" linenumber \"scan-size:\" scan-size))\n   (let [size (count row-vec)]\n     ; We are 1 based, because edamame row numbers are 1 based.\n     (loop [row-vec-index (int (/ size 2))\n            previous-index 0\n            tries 0]\n       #_(println \"\\n\\n================== row-vec-index:\" row-vec-index)\n       (if (> tries 10)\n         :fail\n         (let [maybe-index\n                 (scan-for-row row-vec row-vec-index linenumber scan-size)]\n           ; If it is a number, that is the row-vec-index to return\n           ; If it is :before, we ran off the beginning, :after the end\n           ; nil means that we didn't find it, but can keep looking\n           #_(println \"maybe-index:\" maybe-index)\n           (cond\n             (number? maybe-index) maybe-index  ; we found something to return\n             ; is it in this row?\n             (or (= maybe-index :before-beginning) (= maybe-index :beyond-end))\n               maybe-index\n             :else ; Has to be :before or :after\n               (do\n                 #_(println \"find-row: maybe-index:\" maybe-index\n                            \"row-vec-index:\" row-vec-index\n                            \"previous-index:\" previous-index\n                            \"abs:\" (local-abs (- row-vec-index previous-index)))\n                 (recur ((if (= maybe-index :before) - +)\n                          row-vec-index\n                          (int (/ (local-abs (- row-vec-index previous-index))\n                                  2)))\n                        row-vec-index\n                        (inc tries)))))))))\n  ([row-vec n dbg?] (find-row row-vec n dbg? 4)))\n\n(defn next-non-blank-line\n  \"Given a sequence of lines and a starting line index in that sequence,\n  return the index of the first non-blank line including or after that\n  starting line index.\"\n  [line-vec index]\n  (let [max-idx (dec (count line-vec))]\n    (loop [idx index]\n      (let [line (nth line-vec idx)]\n        ; Return current idx if it is non-blank or the last line\n        (if (or (not (empty? (clojure.string/trim line))) (>= idx max-idx))\n          idx\n          (recur (inc idx)))))))\n\n(defn previous-non-blank-line\n  \"Given a sequence of lines and a starting line index in that sequence,\n  return the index of the first previous non-blank line including or before\n  that starting line index.  Returns -1 if no non-blank line found.\"\n  [line-vec index]\n  (loop [idx index]\n    (let [line (nth line-vec idx)]\n      ; Return current idx if it is non-blank\n      (cond (not (empty? (clojure.string/trim line))) idx\n            ; if the first line is not non-blank, then we didn't find one\n            (zero? idx) -1\n            ; keep looking for a non-blank line\n            :else (recur (dec idx))))))\n\n(defn expand-range-to-top-level\n  \"Given a string which contains lines and a vector of those lines,\n  and a range of lines inside of them, expand the range such that\n  it covers everything from the first non-blank line beyond the\n  previous top level expression before the start to the end of the\n  top level expression containing the end of the range.  Returns\n  [actual-start actual-end].  Note that start, end, actual-start\n  and actual-end are all zero based line numbers.\"\n  ; But also note that parse-string-all (and thus row-vec) and\n  ; find-row all operate with one-based line numbers!!!\n  [filestring lines start end dbg?]\n  (when dbg? (println \"expand-range-to-top-level: start:\" start \"end:\" end))\n  (let [line-count (count lines)\n        start (if (number? start) start 0)\n        end (if (number? end) end line-count)\n        ; If end is before start, make them the same\n        end (if (< end start) start end)\n        ; Get a vector of maps describing all top level expressions using\n        ; one based line numbers.  For example:\n        ; [{:col 1, :end-col 21, :end-row 7, :row 2}\n        ;  {:col 1, :end-col 6, :end-row 20, :row 11}\n        ;  {:col 1, :end-col 70, :end-row 26, :row 22}\n        ;  {:col 1, :end-col 48, :end-row 29, :row 27}]\n        row-vec (->> (p/parse-string-all filestring)\n                     n/children\n                     (remove n/whitespace?)\n                     (remove #(= (n/tag %) :comment))\n                     (mapv meta))\n        _ (when dbg? (prn row-vec))\n        ; Figure out which expression start falls within, after making\n        ; it a one-based line number.  -idx are indexes into row-vec,\n        ; *not* linenumbers\n        start-row-idx (if row-vec (find-row row-vec (inc start) dbg?) :fail)\n        _ (when dbg?\n            (println \"expand-range-to-top-level start-row-idx:\"\n                     start-row-idx\n                     (if (number? start-row-idx)\n                       (str \"row:\" (nth row-vec start-row-idx)\n                            \" previous row:\" (nth row-vec\n                                                  (max 0 (dec start-row-idx))))\n                       \"\")))\n        actual-start\n          ; -1 is a signal to not start at the beginning unless the end is\n          ; also -1, in which case it is a signal to put everything in the\n          ; before\n          (cond (= start-row-idx :fail) -1\n                (and (= start-row-idx :before-beginning) (not (neg? start))) 0\n                (= start-row-idx :before-beginning) -1\n                (= start-row-idx 0) 0\n                (= start-row-idx :beyond-end) -1\n                ; normal case -- the line beyond the previous form\n                ; where (dec start-row-idx) is presumably the previous form\n                :else (:end-row (get row-vec (dec start-row-idx))))\n        ; Now, move actual-start to the first non-blank line after or equal to\n        ; actual-start.  But not if it is zero or negative, since we don't\n        ; want to mess with the range if it encompasses the beginning of\n        ; the file.\n        ;\n        ; The point of this is to make sure that we catch any comments that\n        ; might contain zprint directives in them, so ultimately we are\n        ; setting actual-start to the first non-blank line after the end of\n        ; the previous top-level form.\n        actual-start (if (or (< actual-start 1) (>= actual-start line-count))\n                       actual-start\n                       (next-non-blank-line lines actual-start))\n        end-row-idx (if row-vec (find-row row-vec (inc end) dbg?) :fail)\n        _ (when dbg?\n            (println \"expand-range-to-top-level end-row-idx:\"\n                     end-row-idx\n                     (if (number? end-row-idx)\n                       (str \"row:\" (nth row-vec end-row-idx))\n                       \"\")))\n        actual-end (cond\n                     (or (= end-row-idx :fail) (= end-row-idx :beyond-end))\n                       ; We are beyond the end or it didn't parse, say the\n                       ; end is beyond the last line, unless the start was\n                       ; also beyond the last line, in which case we will\n                       ; do nothing.\n                       (if (= start-row-idx :beyond-end) -1 line-count)\n                     (= end-row-idx :before-beginning)\n                       ; Someone is confused here too, say the end is the\n                       ; start.\n                       :do-nothing\n                     :else (let [end-row (get row-vec end-row-idx)]\n                             ; end-row-idx is either the row in which end falls\n                             ; or the next row if it was between rows\n                             ; Note: :row is the start line of a row-map\n                             ;\n                             ; Does end fall between two top-level expressions?\n                             (if (< (inc end) (:row end-row))\n                               ; Yes -- are start and end in same gap\n                               ; between expressions?\n                               (if (= end-row-idx start-row-idx)\n                                 ; Yes, do nothing\n                                 :do-nothing\n                                 ; No, work backward to the first non-blank\n                                 ; line prior to the end\n                                 (previous-non-blank-line lines end))\n                               ; No, end falls inside of an expression, so use\n                               ; the end of that expression.  Make it zero\n                               ; based.\n                               (dec (:end-row end-row)))))\n        actual-start (if (= actual-end :do-nothing) -1 actual-start)\n        actual-end (if (= actual-end :do-nothing) -1 actual-end)]\n    [actual-start actual-end]))\n\n;;\n;; # Take apart a series of lines based on a range\n;;\n\n(defn split-out-range\n  \"Given lines, a sequence of lines, and a start and end of a range,\n  split the sequence of lines into three parts: [before-lines range\n  after-lines].  If any of these collections would be empty, return\n  an empty sequence. End must be equal to or greater than start. If\n  end is neg?, there will be no range. Note that for begin and range\n  if they have something after them, we will add a null string to them,\n  so that a join will have a newline on the end of it.\"\n  [lines start end]\n  (let [start (max start 0)\n        before start\n        range (if (neg? end) 0 (inc (- end start)))\n        after (- (dec (count lines)) end)\n        before-lines (into [] (take before lines))\n        range-lines (into [] (take range (drop before lines)))\n        after-lines (take after (drop (+ before range) lines))\n        ; Fix up newlines at the end of before and range as\n        ; needed to ensure their last lines are terminated.\n        before-lines\n          (if (not (empty? range-lines)) (conj before-lines \"\") before-lines)\n        range-lines\n          (if (not (empty? after-lines)) (conj range-lines \"\") range-lines)]\n    #_(println \"before:\" before \"range:\" range \"after:\" after)\n    [before-lines range-lines after-lines]))\n\n(defn reassemble-range\n  \"Given before-lines, range, and after-lines where before-lines\n  and after-lines are sequences of lines, and range is a string\n  which has been formatted, reassemble these three chunks into a\n  single string.  Because split-out-range worked hard to figure\n  out how to terminate before-lines and range with a newline,\n  this is really pretty simple.\"\n  [before-lines range after-lines]\n  (let [before-str (clojure.string/join \"\\n\" before-lines)\n        after-str (clojure.string/join \"\\n\" after-lines)]\n    (str before-str range after-str)))\n\n","~:reader-features",["^U",["~:cljs"]],"~:cljc",true,"~:source-map-compact",["^ ","mappings","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","names",["zprint.range/in-row?","n","row","zprint.range/row-before?","row-a","row-b","zprint.range/between-rows?","linenumber","cljs.core/map?","zprint.range/scan-for-row","row-vec","row-vec-index","max-tries","current-index","previous-index","tries","cljs.core.get","row-or-direction","next-index","next-row","var_args","G__56733","zprint.range/find-row","js/Error","dbg?","scan-size","cljs.core.println","size","cljs.core/count","maybe-index","cljs.core._EQ_","G__56739","G__56740","fexpr__56738","cljs.core/-","cljs.core/+","zprint.util/local-abs","zprint.range.find_row","zprint.range/next-non-blank-line","line-vec","index","max-idx","idx","line","cljs.core.nth","cljs.core/empty?","clojure.string/trim","zprint.range/previous-non-blank-line","zprint.range/expand-range-to-top-level","filestring","lines","start","end","line-count","rewrite-clj.parser/parse-string-all","rewrite-clj.node/children","cljs.core.remove","rewrite-clj.node/whitespace?","p1__56746#","rewrite-clj.node/tag","cljs.core.mapv","cljs.core/meta","_","cljs.core.prn","start-row-idx","x__5130__auto__","y__5131__auto__","actual-start","end-row-idx","actual-end","end-row","zprint.range/split-out-range","before","range","after","before-lines","cljs.core.into","cljs.core.take","range-lines","cljs.core.drop","after-lines","cljs.core.conj","zprint.range/reassemble-range","before-str","clojure.string.join","after-str"]],"~:used-vars",["^U",["~$clojure.string/join","~$zprint.range/scan-for-row","~$cljs.core/=","~$cljs.core/count","~$zprint.range/reassemble-range","~$cljs.core/prn","~$cljs.core/take","~$cljs.core/mapv","~$zprint.range/find-row","~$rewrite-clj.parser/parse-string-all","~$cljs.core/empty?","~$cljs.core/-","~$zprint.range/row-before?","~$cljs.core/into","~$cljs.core/map?","~$cljs.core/conj","~$rewrite-clj.node/tag","~$zprint.range/next-non-blank-line","~$zprint.range/between-rows?","~$cljs.core/get","~$rewrite-clj.node/whitespace?","~$cljs.core/remove","~$zprint.range/expand-range-to-top-level","~$cljs.core/nth","~$cljs.core/meta","~$cljs.core/println","~$cljs.core/not","~$zprint.range/in-row?","~$rewrite-clj.node/children","~$clojure.string/trim","~$zprint.util/local-abs","~$zprint.range/split-out-range","~$zprint.range/previous-non-blank-line","~$cljs.core/+","~$js/Error","~$cljs.core/drop"]]],"~:cache-keys",["~#cmap",[["^1F","rewrite_clj/zip/options.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","~:shadow.build.compiler/resolve",["^ ","~:require-id",null,"~:deps-ids",["^U",[]],"~:deps-syms",["^15","^14","~$rewrite-clj.node.protocols"]]],["^1F","goog/dom/tagname.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","~$goog.dom.HtmlElement"]]],["^1F","rewrite_clj/zip/walk.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","~$rewrite-clj.zip.move","~$rewrite-clj.zip.subedit"]]],["^1F","cljs/tools/reader/impl/utils.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","^16","~$goog.string"]]],["^1F","rewrite_clj/node/reader_macro.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","^2P","~$rewrite-clj.node.whitespace"]]],["^1F","rewrite_clj/parser.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","~$rewrite-clj.node.forms","~$rewrite-clj.parser.core","~$rewrite-clj.reader"]]],["^1F","goog/html/trustedtypes.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15"]]],["^1F","goog/string/stringformat.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^2T"]]],["^1F","goog/labs/useragent/browser.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","~$goog.array","~$goog.object","~$goog.labs.userAgent.util","~$goog.string.internal"]]],["^1F","goog/html/safeurl.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","~$goog.asserts","~$goog.fs.url","~$goog.html.TrustedResourceUrl","~$goog.i18n.bidi.Dir","~$goog.i18n.bidi.DirectionalString","~$goog.string.Const","~$goog.string.TypedString","^30"]]],["^1F","goog/array/array.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^31"]]],["^1F","rewrite_clj/parser/whitespace.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","^2U","^2X"]]],["^1F","rewrite_clj/node/regex.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","^2P"]]],["^1F","goog/debug/error.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15"]]],["^1F","cljs/tools/reader/edn.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","^F","^J","^@","^D","~$cljs.tools.reader","^2T","~$goog.string.StringBuffer"]]],["^1F","goog/dom/nodetype.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15"]]],["^1F","cljs/tools/reader/impl/inspect.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14"]]],["^1F","cljs/tools/reader.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","^J","^@","^D","^F","^2Y","^2T","^39"]]],["^1F","rewrite_clj/zip/base.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","~$rewrite-clj.custom-zipper.core","^2V","^2P","^11","~$rewrite-clj.zip.options","~$rewrite-clj.zip.whitespace"]]],["^1F","rewrite_clj/zip/editz.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","^3:","~$rewrite-clj.custom-zipper.utils","^2P","~$rewrite-clj.node.token","^2U","~$rewrite-clj.zip.base","^3;","~$rewrite-clj.zip.removez","^3<"]]],["^1F","rewrite_clj/parser/token.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","^3>","^2X"]]],["^1F","rewrite_clj/node/uneval.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","^2P"]]],["^1F","goog/string/typedstring.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15"]]],["^1F","rewrite_clj/parser/keyword.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","~$rewrite-clj.node.keyword","^2X"]]],["^1F","rewrite_clj/zip/seqz.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","^3:","^3?","~$rewrite-clj.zip.editz","~$rewrite-clj.zip.findz","~$rewrite-clj.zip.insert","^2R"]]],["^1F","goog/object/object.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15"]]],["^1F","goog/dom/asserts.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^31"]]],"~:SHADOW-TIMESTAMP",[1666857604000,1666857604000,1666857293000],["^1F","rewrite_clj/node/keyword.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","^2P"]]],["^1F","rewrite_clj/node/token.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","^2P"]]],["^1F","goog/math/long.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^31","~$goog.reflect"]]],["^1F","goog/html/trustedresourceurl.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^31","~$goog.fs.blob","^32","~$goog.html.SafeScript","~$goog.html.trustedtypes","^34","^35","^36","^37"]]],["^1F","rewrite_clj/node.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","~$rewrite-clj.node.coercer","~$rewrite-clj.node.comment","~$rewrite-clj.node.extras","~$rewrite-clj.node.fn","^2V","~$rewrite-clj.node.integer","^3A","~$rewrite-clj.node.meta","~$rewrite-clj.node.namespaced-map","^2P","~$rewrite-clj.node.quote","~$rewrite-clj.node.reader-macro","~$rewrite-clj.node.regex","~$rewrite-clj.node.seq","~$rewrite-clj.node.stringz","^3>","~$rewrite-clj.node.uneval","^2U"]]],["^1F","rewrite_clj/node/comment.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","^2P"]]],["^1F","rewrite_clj/zip/subedit.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","^3:","^3?","^3;"]]],["^1F","goog/string/internal.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15"]]],["^1F","goog/functions/functions.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15"]]],["^1F","rewrite_clj/parser/string.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","^16","^3U","^2X","^39"]]],["^1F","goog/html/safestyle.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^36","~$goog.html.SafeUrl","^37","^31","^30"]]],["^1F","goog/dom/safe.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^31","~$goog.dom.asserts","~$goog.functions","~$goog.html.SafeHtml","^3H","~$goog.html.SafeStyle","^3W","^33","~$goog.html.uncheckedconversions","^36","^30"]]],["^1F","rewrite_clj/zip/removez.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","^3:","^3=","^2R","^3<"]]],["^1F","clojure/walk.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14"]]],["^1F","goog/html/safehtml.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^36","^34","^35","^3H","^3[","~$goog.html.SafeStyleSheet","^3W","~$goog.dom.TagName","^33","^37","^31","~$goog.labs.userAgent.browser","^2Y","^2Z","^30","~$goog.dom.tags","^3I"]]],["^1F","rewrite_clj/node/forms.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","^2P"]]],["^1F","goog/dom/tags.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^2Z"]]],["^1F","rewrite_clj/node/integer.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","~$rewrite-clj.interop","^2P"]]],["^1F","rewrite_clj/parser/core.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","^3K","^3M","^3O","^2P","^3Q","^3R","^3S","^3T","^3>","^3V","~$rewrite-clj.parser.keyword","~$rewrite-clj.parser.namespaced-map","~$rewrite-clj.parser.string","~$rewrite-clj.parser.token","~$rewrite-clj.parser.whitespace","^2X"]]],["^1F","rewrite_clj/node/fn.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","^16","~$clojure.walk","^45","^2P"]]],["^1F","goog/fs/blob.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15"]]],["^1F","rewrite_clj/node/protocols.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","^16","^45"]]],["^1F","goog/asserts/asserts.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","~$goog.debug.Error","~$goog.dom.NodeType"]]],["^1F","rewrite_clj/zip/whitespace.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","^3:","^3K","^3L","^2U"]]],["^1F","goog/uri/uri.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^2Y","^31","~$goog.collections.maps","^2T","~$goog.structs","~$goog.uri.utils","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"]]],["^1F","rewrite_clj/node/meta.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","^45","^2P","^2U"]]],["^1F","rewrite_clj/node/stringz.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","^16","^L","^2P"]]],["^1F","rewrite_clj/parser/namespaced_map.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","^3P","^2P","^2U","^2X"]]],["^1F","goog/collections/maps.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15"]]],["^1F","rewrite_clj/node/whitespace.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","^2P","^2X"]]],["^1F","goog/i18n/bidi.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15"]]],["^1F","rewrite_clj/zip/move.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","^3:","^3<"]]],["^1F","goog/fs/url.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15"]]],["^1F","rewrite_clj/node/quote.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","^2P"]]],["^1F","goog/base.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",[]]],["^1F","goog/structs/structs.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^2Y","^2Z"]]],["^1F","cljs/tools/reader/impl/errors.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","^J","^16","~$cljs.tools.reader.impl.inspect"]]],["^1F","zprint/util.cljc"],["6c7de285c399d67aaa77693a88b73d129953fa1f","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","^16"]]],["^1F","rewrite_clj/zip/context.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","^3:","^2P","~$rewrite-clj.zip.seqz","~$rewrite-clj.zip.walk"]]],["^1F","clojure/string.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","^2T","^39"]]],["^1F","rewrite_clj/zip/findz.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","^3:","^3?","^2R"]]],["^1F","rewrite_clj/zip.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","^3:","^3J","^3?","~$rewrite-clj.zip.context","^3B","^3C","^3D","^2R","^3@","^4D","^2S","^4E","^3<"]]],["^1F","rewrite_clj/zip/insert.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","^3:","^2P","^2U","^3<"]]],["^1F","rewrite_clj/node/namespaced_map.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","^2P"]]],["^1F","goog/string/string.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","~$goog.dom.safe","^40","^36","^30"]]],["^1F","rewrite_clj/custom_zipper/core.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","~$clojure.zip","~$rewrite-clj.custom-zipper.switchable","^2P"]]],["^1F","goog/reflect/reflect.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15"]]],["^1F","goog/labs/useragent/util.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","~$goog.labs.userAgent","^30"]]],["^1F","clojure/zip.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14"]]],["^1F","goog/string/stringbuffer.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15"]]],["^1F","cljs/tools/reader/reader_types.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","^@","^2T","^39"]]],["^1F","rewrite_clj/reader.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","^L","^D","^F","^@","^J","^45","^39"]]],["^1F","goog/labs/useragent/useragent.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15"]]],["^1F","rewrite_clj/custom_zipper/utils.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","^3:"]]],["^1F","rewrite_clj/node/coercer.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","^16","^3K","^3M","^2V","^3N","^3A","^3O","^3P","^2P","^3Q","^3R","^3S","^3T","^3U","^3>","^3V","^2U"]]],["^1F","goog/html/uncheckedconversions.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^31","^3Z","^3H","^3[","^41","^3W","^33","^36","^30","^34"]]],["^1F","zprint/range.cljc"],["6c7de285c399d67aaa77693a88b73d129953fa1f","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","^16","^17","^11","^12","^13"]]],["^1F","cljs/tools/reader/impl/commons.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","^F","^J","^@"]]],["^1F","goog/dom/htmlelement.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15"]]],["^1F","cljs/core.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","~$goog.math.Long","~$goog.math.Integer","^2T","^2Z","^2Y","~$goog.Uri","^39"]]],["^1F","rewrite_clj/custom_zipper/switchable.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14"]]],["^1F","goog/html/safescript.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^36","^37","^3I","^31"]]],["^1F","rewrite_clj/node/extras.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","^3K","^2U"]]],["^1F","goog/html/safestylesheet.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^36","^3[","^37","^2Z","^31","^30"]]],["^1F","goog/math/integer.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^3F"]]],["^1F","goog/uri/utils.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^31","^2T"]]],["^1F","goog/string/const.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^31","^37"]]],["^1F","rewrite_clj/interop.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","^2T","~$goog.string.format"]]],["^1F","rewrite_clj/node/seq.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^2L",["^ ","^2M",null,"^2N",["^U",[]],"^2O",["^15","^14","^45","^2P"]]]]],"~:clj-info",["^ ","jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/string.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/impl/errors.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/env.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/default_data_readers.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/core.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/edn.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/reader.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/reader_types.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/util.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/compiler.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/impl/inspect.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/edn.clj",1666857280000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/passes/and_or.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/pprint.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map/base64_vlq.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/set.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/reader_types.clj",1666857280000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/node/protocols.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/instant.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map/base64.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/interop.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/impl/utils.clj",1666857280000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/custom_zipper/core.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/externs.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/zip.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/impl/commons.clj",1666857280000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/js_deps.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/binaryage/devtools/1.0.6/devtools-1.0.6.jar!/devtools/defaults.clj",1666857314000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/java/io.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/impl/inspect.clj",1666857280000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/node/comment.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/parser.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/node/whitespace.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/zip/whitespace.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/impl.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/custom_zipper/switchable.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/node/forms.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/tagged_literals.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/core.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/zip/subedit.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/parser/core.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/passes.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/node/extras.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/data/json.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/zip/options.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/instant.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/impl/namespaces.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/zip.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/zip/base.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/impl/errors.clj",1666857280000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/cljs/tools/reader/reader_types.clj",1666857280000],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","zprint/range.cljc","^7",1,"^8",14,"^9",1,"^:",26,"^;",true],"^<",["^ ","^=","^>","^?","^@","^A","^B","^C","^D","^E","^F","^G","^H","^I","^J","^K","^L","^M","^N","^O","^P","^Q","^R"],"^S",null,"^T",["^U",[]],"^V","^W","^X",["^ "],"^[",null,"^10",["^ ","^11","^11","~$p","^11","^12","^12","^13","^13","^14","^14","^15","^15","~$n","^12","~$s","^16","~$z","^13","^16","^16","^17","^17"],"^18",["^U",["^19"]],"~:shadow/js-access-global",["^U",["Error"]],"^1:",["^ ","^1;","^17"],"~:defs",["^ ","~$reassemble-range",["^ ","~:protocol-inline",null,"^5",["^ ","^6","zprint/range.cljc","^7",298,"^8",7,"^9",298,"^:",23,"~:arglists",["^1>",["~$quote",["^1>",[["~$before-lines","~$range","~$after-lines"]]]]],"~:doc","Given before-lines, range, and after-lines where before-lines\n  and after-lines are sequences of lines, and range is a string\n  which has been formatted, reassemble these three chunks into a\n  single string.  Because split-out-range worked hard to figure\n  out how to terminate before-lines and range with a newline,\n  this is really pretty simple."],"^V","^1V","^6","zprint/range.cljc","^:",23,"~:method-params",["^1>",[["^65","^66","^67"]]],"~:protocol-impl",null,"~:arglists-meta",["^1>",[null,null]],"^8",1,"~:variadic?",false,"^7",298,"~:ret-tag","~$string","^9",298,"~:max-fixed-arity",3,"~:fn-var",true,"^63",["^1>",["^64",["^1>",[["^65","^66","^67"]]]]],"^68","Given before-lines, range, and after-lines where before-lines\n  and after-lines are sequences of lines, and range is a string\n  which has been formatted, reassemble these three chunks into a\n  single string.  Because split-out-range worked hard to figure\n  out how to terminate before-lines and range with a newline,\n  this is really pretty simple."],"~$expand-range-to-top-level",["^ ","^62",null,"^5",["^ ","^6","zprint/range.cljc","^7",163,"^8",7,"^9",163,"^:",32,"^63",["^1>",["^64",["^1>",[["~$filestring","~$lines","~$start","~$end","~$dbg?"]]]]],"^68","Given a string which contains lines and a vector of those lines,\n  and a range of lines inside of them, expand the range such that\n  it covers everything from the first non-blank line beyond the\n  previous top level expression before the start to the end of the\n  top level expression containing the end of the range.  Returns\n  [actual-start actual-end].  Note that start, end, actual-start\n  and actual-end are all zero based line numbers."],"^V","^2<","^6","zprint/range.cljc","^:",32,"^69",["^1>",[["^6B","^6C","^6D","^6E","^6F"]]],"^6:",null,"^6;",["^1>",[null,null]],"^8",1,"^6<",false,"^7",163,"^6=","~$cljs.core/IVector","^9",163,"^6?",5,"^6@",true,"^63",["^1>",["^64",["^1>",[["^6B","^6C","^6D","^6E","^6F"]]]]],"^68","Given a string which contains lines and a vector of those lines,\n  and a range of lines inside of them, expand the range such that\n  it covers everything from the first non-blank line beyond the\n  previous top level expression before the start to the end of the\n  top level expression containing the end of the range.  Returns\n  [actual-start actual-end].  Note that start, end, actual-start\n  and actual-end are all zero based line numbers."],"~$find-row",["^ ","^62",null,"^5",["^ ","^6","zprint/range.cljc","^7",84,"^8",7,"^9",84,"^:",15,"^63",["^1>",["^64",["^1>",[["~$row-vec","~$linenumber","^6F","~$scan-size"],["^6I","~$n","^6F"]]]]],"^68","Given a vector of rows, find the row that contains a line number,\n  linenumber, and return the number of that row in the vector.\n  row-vec looks like this: \n  [{:col 1, :end-col 21, :end-row 7, :row 2}\n   {:col 1, :end-col 6, :end-row 18, :row 9}\n   {:col 1, :end-col 6, :end-row 29, :row 20}]\n  If none exists, return the next row. Note that line numbers are\n  1 based, not zero based for this routine and the information in\n  row-vec, but the index into row-vec that this routine returns is\n  zero based.  Uses a binary search. If the line number is before\n  the first information in the row-vec, returns :before-beginning,\n  and if it is after the last information in the row-vec, returns\n  :beyond-end. Note that find-row returns an index into row-vec,\n  and it must be the row-vec that has had nils removed from it (or\n  this routine would do that for you).","~:top-fn",["^ ","^6<",false,"~:fixed-arity",4,"^6?",4,"^69",[["^6I","^6J","^6F","^6K"],["^6I","~$n","^6F"]],"^63",["^1>",[["^6I","^6J","^6F","^6K"],["^6I","~$n","^6F"]]],"^6;",["^1>",[null,null]]]],"^V","^1Z","^6","zprint/range.cljc","^:",15,"^6L",["^ ","^6<",false,"^6M",4,"^6?",4,"^69",[["^6I","^6J","^6F","^6K"],["^6I","~$n","^6F"]],"^63",["^1>",[["^6I","^6J","^6F","^6K"],["^6I","~$n","^6F"]]],"^6;",["^1>",[null,null]]],"^69",[["^6I","^6J","^6F","^6K"],["^6I","~$n","^6F"]],"^6:",null,"^6M",4,"^6;",["^1>",[null,null]],"^8",1,"^6<",false,"~:methods",[["^ ","^6M",4,"^6<",false,"~:tag",["^U",["~$any","~$cljs.core/Keyword","~$number"]]],["^ ","^6M",3,"^6<",false,"^6O",["^U",["^6P","^6Q","^6R"]]]],"^7",84,"^9",84,"^6?",4,"^6@",true,"^63",["^1>",[["^6I","^6J","^6F","^6K"],["^6I","~$n","^6F"]]],"^68","Given a vector of rows, find the row that contains a line number,\n  linenumber, and return the number of that row in the vector.\n  row-vec looks like this: \n  [{:col 1, :end-col 21, :end-row 7, :row 2}\n   {:col 1, :end-col 6, :end-row 18, :row 9}\n   {:col 1, :end-col 6, :end-row 29, :row 20}]\n  If none exists, return the next row. Note that line numbers are\n  1 based, not zero based for this routine and the information in\n  row-vec, but the index into row-vec that this routine returns is\n  zero based.  Uses a binary search. If the line number is before\n  the first information in the row-vec, returns :before-beginning,\n  and if it is after the last information in the row-vec, returns\n  :beyond-end. Note that find-row returns an index into row-vec,\n  and it must be the row-vec that has had nils removed from it (or\n  this routine would do that for you)."],"~$scan-for-row",["^ ","^62",null,"^5",["^ ","^6","zprint/range.cljc","^7",39,"^8",7,"^9",39,"^:",19,"^63",["^1>",["^64",["^1>",[["^6I","~$row-vec-index","^6J","~$max-tries"]]]]],"^68","Given a row-vec, and a current index into the row-vec, if the\n  linenumber is within that row, return the index to that row.   If\n  the linenumber is not in that row, then scan either way for\n  max-tries looking for a match for this linenumber.  Return the\n  row index if a row is found containing this linenumber. If it is\n  between two rows, return the row after.  If we fall off the either\n  end of the row-vec, then return :before-beginning or :beyone-end.  \n  If we don't find anything after trying for max-tries, :before or\n  :after, depending on which way we should try next."],"^V","^1S","^6","zprint/range.cljc","^:",19,"^69",["^1>",[["^6I","^6T","^6J","^6U"]]],"^6:",null,"^6;",["^1>",[null,null]],"^8",1,"^6<",false,"^7",39,"^6=",["^U",["^6P","^6Q","^6R"]],"^9",39,"^6?",4,"^6@",true,"^63",["^1>",["^64",["^1>",[["^6I","^6T","^6J","^6U"]]]]],"^68","Given a row-vec, and a current index into the row-vec, if the\n  linenumber is within that row, return the index to that row.   If\n  the linenumber is not in that row, then scan either way for\n  max-tries looking for a match for this linenumber.  Return the\n  row index if a row is found containing this linenumber. If it is\n  between two rows, return the row after.  If we fall off the either\n  end of the row-vec, then return :before-beginning or :beyone-end.  \n  If we don't find anything after trying for max-tries, :before or\n  :after, depending on which way we should try next."],"~$row-before?",["^ ","^62",null,"^5",["^ ","^6","zprint/range.cljc","^7",21,"^8",7,"^9",21,"^:",18,"^63",["^1>",["^64",["^1>",[["~$row-a","~$row-b"]]]]],"^68","Given two rows, is the first before the second?"],"^V","^22","^6","zprint/range.cljc","^:",18,"^69",["^1>",[["^6W","^6X"]]],"^6:",null,"^6;",["^1>",[null,null]],"^8",1,"^6<",false,"^7",21,"^6=","~$boolean","^9",21,"^6?",2,"^6@",true,"^63",["^1>",["^64",["^1>",[["^6W","^6X"]]]]],"^68","Given two rows, is the first before the second?"],"~$split-out-range",["^ ","^62",null,"^5",["^ ","^6","zprint/range.cljc","^7",273,"^8",7,"^9",273,"^:",22,"^63",["^1>",["^64",["^1>",[["^6C","^6D","^6E"]]]]],"^68","Given lines, a sequence of lines, and a start and end of a range,\n  split the sequence of lines into three parts: [before-lines range\n  after-lines].  If any of these collections would be empty, return\n  an empty sequence. End must be equal to or greater than start. If\n  end is neg?, there will be no range. Note that for begin and range\n  if they have something after them, we will add a null string to them,\n  so that a join will have a newline on the end of it."],"^V","^2E","^6","zprint/range.cljc","^:",22,"^69",["^1>",[["^6C","^6D","^6E"]]],"^6:",null,"^6;",["^1>",[null,null]],"^8",1,"^6<",false,"^7",273,"^6=","^6G","^9",273,"^6?",3,"^6@",true,"^63",["^1>",["^64",["^1>",[["^6C","^6D","^6E"]]]]],"^68","Given lines, a sequence of lines, and a start and end of a range,\n  split the sequence of lines into three parts: [before-lines range\n  after-lines].  If any of these collections would be empty, return\n  an empty sequence. End must be equal to or greater than start. If\n  end is neg?, there will be no range. Note that for begin and range\n  if they have something after them, we will add a null string to them,\n  so that a join will have a newline on the end of it."],"~$next-non-blank-line",["^ ","^62",null,"^5",["^ ","^6","zprint/range.cljc","^7",136,"^8",7,"^9",136,"^:",26,"^63",["^1>",["^64",["^1>",[["~$line-vec","~$index"]]]]],"^68","Given a sequence of lines and a starting line index in that sequence,\n  return the index of the first non-blank line including or after that\n  starting line index."],"^V","^27","^6","zprint/range.cljc","^:",26,"^69",["^1>",[["^70","^71"]]],"^6:",null,"^6;",["^1>",[null,null]],"^8",1,"^6<",false,"^7",136,"^9",136,"^6?",2,"^6@",true,"^63",["^1>",["^64",["^1>",[["^70","^71"]]]]],"^68","Given a sequence of lines and a starting line index in that sequence,\n  return the index of the first non-blank line including or after that\n  starting line index."],"~$between-rows?",["^ ","^62",null,"^5",["^ ","^6","zprint/range.cljc","^7",27,"^8",7,"^9",27,"^:",20,"^63",["^1>",["^64",["^1>",[["^6J","^6W","^6X"]]]]],"^68","Given two rows, if the linenumber is between the rows, return true, else\n  nil."],"^V","^28","^6","zprint/range.cljc","^:",20,"^69",["^1>",[["^6J","^6W","^6X"]]],"^6:",null,"^6;",["^1>",[null,null]],"^8",1,"^6<",false,"^7",27,"^6=",["^U",["^6Y","~$clj-nil"]],"^9",27,"^6?",3,"^6@",true,"^63",["^1>",["^64",["^1>",[["^6J","^6W","^6X"]]]]],"^68","Given two rows, if the linenumber is between the rows, return true, else\n  nil."],"~$in-row?",["^ ","^62",null,"^5",["^ ","^6","zprint/range.cljc","^7",12,"^8",7,"^9",12,"^:",14,"^63",["^1>",["^64",["^1>",[["~$n","~$row"]]]]],"^68","If a line number n is in a particular row, return the row map.\n  If it is not in the row, return +1 or -1 to indicate which direction\n  to look."],"^V","^2A","^6","zprint/range.cljc","^:",14,"^69",["^1>",[["~$n","^75"]]],"^6:",null,"^6;",["^1>",[null,null]],"^8",1,"^6<",false,"^7",12,"^6=",["^U",[null,"^6R","^73"]],"^9",12,"^6?",2,"^6@",true,"^63",["^1>",["^64",["^1>",[["~$n","^75"]]]]],"^68","If a line number n is in a particular row, return the row map.\n  If it is not in the row, return +1 or -1 to indicate which direction\n  to look."],"~$previous-non-blank-line",["^ ","^62",null,"^5",["^ ","^6","zprint/range.cljc","^7",149,"^8",7,"^9",149,"^:",30,"^63",["^1>",["^64",["^1>",[["^70","^71"]]]]],"^68","Given a sequence of lines and a starting line index in that sequence,\n  return the index of the first previous non-blank line including or before\n  that starting line index.  Returns -1 if no non-blank line found."],"^V","^2F","^6","zprint/range.cljc","^:",30,"^69",["^1>",[["^70","^71"]]],"^6:",null,"^6;",["^1>",[null,null]],"^8",1,"^6<",false,"^7",149,"^6=",["^U",[null,"^6R"]],"^9",149,"^6?",2,"^6@",true,"^63",["^1>",["^64",["^1>",[["^70","^71"]]]]],"^68","Given a sequence of lines and a starting line index in that sequence,\n  return the index of the first previous non-blank line including or before\n  that starting line index.  Returns -1 if no non-blank line found."]],"^1<",["^ ","^14","^14","^13","^13","~$z","^13"],"~:cljs.analyzer/constants",["^ ","^18",["^U",["~:end-row","~:else","~:fail","~:after","~:before-beginning","~:comment","~:do-nothing","~:before","~:beyond-end","~:row"]],"~:order",["^7A","^78","^7@","^7<","^79","^7;","^7?","^7:","^7=","^7>"]],"^1B",["^ ","^19",["^U",[]]],"^1C",["^ "],"^1D",["^15","^14","^16","^17","^11","^12","^13"]],"^Z","^W","~:ns-specs",["^ "],"~:ns-spec-vars",["^U",[]],"~:compiler-options",["^2K",[["^7E","~:static-fns"],true,["^7E","~:shadow-tweaks"],null,["^7E","~:source-map-inline"],null,["^7E","~:elide-asserts"],false,["^7E","~:optimize-constants"],null,["^7E","^1I"],null,["^7E","~:external-config"],null,["^7E","~:tooling-config"],null,["^7E","~:emit-constants"],null,["^7E","~:load-tests"],null,["^7E","~:form-size-threshold"],null,["^7E","~:global-goog-object&array"],null,["^7E","~:data-readers"],null,["^7E","~:infer-externs"],"~:auto",["^7E","^1K"],null,["~:js-options","~:js-provider"],"~:shadow",["~:mode"],"~:dev",["^7E","~:fn-invoke-direct"],null,["^7E","~:source-map"],"/dev/null"]]]