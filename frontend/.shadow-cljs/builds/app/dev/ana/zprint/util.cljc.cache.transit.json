["^ ","~:output",["^ ","~:js","goog.provide('zprint.util');\n/**\n * Return the absolute value of a number.\n */\nzprint.util.local_abs = (function zprint$util$local_abs(n){\nif((n < (0))){\nreturn (- n);\n} else {\nreturn n;\n}\n});\n/**\n * Return the size of an sexpr, essentially the number of characters\n *   in its string representation.  If the sexpr is already a string,\n *   return the number of characters in the string plus 2 to account\n *   for the double quotes, unless no-string-adj? is non-nil.  In that\n *   case, simply return the character count of the string.  If sexpr\n *   is nil, return nil.\n */\nzprint.util.size = (function zprint$util$size(var_args){\nvar G__41641 = arguments.length;\nswitch (G__41641) {\ncase 2:\nreturn zprint.util.size.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 1:\nreturn zprint.util.size.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(zprint.util.size.cljs$core$IFn$_invoke$arity$2 = (function (sexpr,no_string_adj_QMARK_){\nif(cljs.core.truth_(sexpr)){\nvar s = cljs.core.str.cljs$core$IFn$_invoke$arity$1(sexpr);\nvar s__$1 = ((clojure.string.starts_with_QMARK_(s,\":zprint.core/\"))?clojure.string.replace(s,\":zprint.core/\",\"::\"):((clojure.string.starts_with_QMARK_(s,\":clojure.core/\"))?clojure.string.replace(s,\":clojure.core/\",\"::\"):s\n));\nvar s_count = ((s__$1).length);\nif(((cljs.core.not(no_string_adj_QMARK_)) && (typeof sexpr === 'string'))){\nreturn (s_count + (2));\n} else {\nreturn s_count;\n}\n} else {\nreturn null;\n}\n}));\n\n(zprint.util.size.cljs$core$IFn$_invoke$arity$1 = (function (sexpr){\nreturn zprint.util.size.cljs$core$IFn$_invoke$arity$2(sexpr,null);\n}));\n\n(zprint.util.size.cljs$lang$maxFixedArity = 2);\n\n/**\n * Find the median of a series of numbers.\n */\nzprint.util.median = (function zprint$util$median(coll){\nvar sorted_coll = cljs.core.sort.cljs$core$IFn$_invoke$arity$1(coll);\nvar len = cljs.core.count(coll);\nvar middle = (len / (2));\nif(cljs.core.odd_QMARK_(len)){\nreturn cljs.core.nth.cljs$core$IFn$_invoke$arity$2(sorted_coll,middle);\n} else {\nvar lower = (middle - (1));\nvar lower_middle = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(sorted_coll,lower);\nvar upper_middle = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(sorted_coll,middle);\nreturn ((lower_middle + upper_middle) / (2));\n}\n});\n/**\n * Find the mean of a series of numbers.\n */\nzprint.util.mean = (function zprint$util$mean(coll){\nif((!(cljs.core.empty_QMARK_(coll)))){\nreturn (cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core._PLUS_,coll) / cljs.core.count(coll));\n} else {\nreturn null;\n}\n});\n/**\n * Return the percentage of numbers greater than n.\n */\nzprint.util.percent_gt_n = (function zprint$util$percent_gt_n(n,coll){\nif((!(cljs.core.empty_QMARK_(coll)))){\nvar count_gt = cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (cnt,m){\nif((m > n)){\nreturn (cnt + (1));\n} else {\nreturn cnt;\n}\n}),(0),coll);\nvar percentage = (((count_gt / cljs.core.count(coll)) * (100)) | (0));\nreturn percentage;\n} else {\nreturn null;\n}\n});\n/**\n * Return the variance of a sequence of numbers. Ignore nil values.\n *   Return the variance or nil if there are no numbers.\n */\nzprint.util.variance = (function zprint$util$variance(coll){\nvar coll__$1 = cljs.core.remove.cljs$core$IFn$_invoke$arity$2(cljs.core.nil_QMARK_,coll);\nvar len = cljs.core.count(coll__$1);\nif((!((len === (0))))){\nvar mean = (cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core._PLUS_,coll__$1) / len);\nvar dev_from_mean = cljs.core.mapv.cljs$core$IFn$_invoke$arity$2(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(cljs.core._,mean),coll__$1);\nvar sq_dev_from_mean = cljs.core.mapv.cljs$core$IFn$_invoke$arity$2((function (p1__41677_SHARP_){\nreturn (p1__41677_SHARP_ * p1__41677_SHARP_);\n}),dev_from_mean);\nvar variance = ((cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core._PLUS_,sq_dev_from_mean) / len) | (0));\nreturn variance;\n} else {\nreturn null;\n}\n});\n/**\n * Given a sequence of numbers, return the indices of all of the\n *   numbers that are equal to the maximum number.  Returns: \n *   [max-number [indicies-of-max-number] length-of-sequence]\n */\nzprint.util.find_max = (function zprint$util$find_max(coll){\nvar indicies = cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (p__41679,n){\nvar vec__41680 = p__41679;\nvar max_so_far = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41680,(0),null);\nvar indicies = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41680,(1),null);\nvar index = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41680,(2),null);\nif((n == null)){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [max_so_far,indicies,(index + (1))], null);\n} else {\nif((n > max_so_far)){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [n,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [index], null),(index + (1))], null);\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(n,max_so_far)){\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [max_so_far,cljs.core.conj.cljs$core$IFn$_invoke$arity$2(indicies,index),(index + (1))], null);\n} else {\nreturn new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [max_so_far,indicies,(index + (1))], null);\n\n}\n}\n}\n}),new cljs.core.PersistentVector(null, 3, 5, cljs.core.PersistentVector.EMPTY_NODE, [(0),cljs.core.PersistentVector.EMPTY,(0)], null),coll);\nreturn indicies;\n});\n/**\n * Given a vector, set specific indicies to nil.\n */\nzprint.util.remove_indicies = (function zprint$util$remove_indicies(indicies,coll){\nif(cljs.core.truth_(indicies)){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$3(cljs.core.assoc,coll,cljs.core.interleave.cljs$core$IFn$_invoke$arity$2(indicies,cljs.core.repeat.cljs$core$IFn$_invoke$arity$1(null)));\n} else {\nreturn coll;\n}\n});\n/**\n * Given a vector of numbers, remove every instance of the maximum number \n *   from the vector and replace it with nil, unless it would remove more \n *   than half of the numbers in the vector, in which case return the vector\n *   unchanged. Returns: [indicies-removed vector-with-max-removed]\n */\nzprint.util.remove_max_not_half = (function zprint$util$remove_max_not_half(coll_vec){\nvar vec__41702 = zprint.util.find_max(coll_vec);\nvar max_number = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41702,(0),null);\nvar indicies = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41702,(1),null);\nvar length = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41702,(2),null);\nif((cljs.core.count(indicies) > (length / (2)))){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [null,coll_vec], null);\n} else {\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [indicies,zprint.util.remove_indicies(indicies,coll_vec)], null);\n}\n});\n/**\n * Given a vector of indicies and a vector of vectors (columns), remove \n *   the specified indicies from the columns by replacing them with nil, starting\n *   at the vector specified by the index.\n */\nzprint.util.remove_indicies_from_columns = (function zprint$util$remove_indicies_from_columns(index,indicies,columns){\nif((index < cljs.core.count(columns))){\nvar vec__41708 = cljs.core.split_at(index,columns);\nvar beginning = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41708,(0),null);\nvar end = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41708,(1),null);\nvar beginning__$1 = cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentVector.EMPTY,beginning);\nvar end__$1 = cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentVector.EMPTY,end);\nvar new_end = cljs.core.mapv.cljs$core$IFn$_invoke$arity$2(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(zprint.util.remove_indicies,indicies),end__$1);\nreturn cljs.core.into.cljs$core$IFn$_invoke$arity$2(beginning__$1,new_end);\n} else {\nreturn columns;\n}\n});\n/**\n * Count the non-nil items in a sequence.\n */\nzprint.util.count_non_nil = (function zprint$util$count_non_nil(coll){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (cnt,x){\nif((x == null)){\nreturn cnt;\n} else {\nreturn (cnt + (1));\n}\n}),(0),coll);\n});\n/**\n * Given a vector of vectors, where each vector represents the sizes\n *   in a column, find the variance of the column, and if it is too high\n *   remove the largest and then second largest values to see if we can\n *   get it low enough for alignment.  If yes, return the alignment and the\n *   new vector of vectors (where the rows that were not considered for the\n *   successful variance calculation have been removed from all (inc index)\n *   columns).  If no, return nil and the unchanged vector of vectors. \n *   Returns: [max-width-or-nil columns]\n */\nzprint.util.column_width_variance = (function zprint$util$column_width_variance(max_variance,columns,index){\nif((index >= cljs.core.count(columns))){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [null,columns], null);\n} else {\nvar column = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(columns,index);\nvar beginning_variance = zprint.util.variance(column);\nvar row_count = zprint.util.count_non_nil(column);\nif((beginning_variance == null)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [null,columns], null);\n} else {\nif((max_variance > beginning_variance)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.first(zprint.util.find_max(column)),columns], null);\n} else {\nif((row_count > (2))){\nvar vec__41719 = zprint.util.remove_max_not_half(column);\nvar first_indicies = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41719,(0),null);\nvar first_column_wo_max = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41719,(1),null);\nvar first_variance = zprint.util.variance(first_column_wo_max);\nif((first_variance == null)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [null,columns], null);\n} else {\nif((max_variance > first_variance)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.first(zprint.util.find_max(first_column_wo_max)),zprint.util.remove_indicies_from_columns((index + (1)),first_indicies,columns)], null);\n} else {\nvar vec__41728 = zprint.util.remove_max_not_half(first_column_wo_max);\nvar second_indicies = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41728,(0),null);\nvar second_column_wo_max = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41728,(1),null);\nvar second_variance = zprint.util.variance(second_column_wo_max);\nif((second_variance == null)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [null,columns], null);\n} else {\nif(((cljs.core.count(first_indicies) + cljs.core.count(second_indicies)) >= (row_count / (2)))){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [null,columns], null);\n} else {\nif((max_variance > second_variance)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.first(zprint.util.find_max(second_column_wo_max)),zprint.util.remove_indicies_from_columns((index + (1)),cljs.core.into.cljs$core$IFn$_invoke$arity$2(first_indicies,second_indicies),columns)], null);\n} else {\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [null,columns], null);\n\n}\n}\n}\n\n}\n}\n} else {\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [null,columns], null);\n\n}\n}\n}\n}\n});\n/**\n * Given a seq and a length, return a vector which contains the\n *   size of every element in the seq and is the length specified.  If\n *   the element is already a string, the size is the number of\n *   characters plus 2 for the surrounding double quotes, unless\n *   no-string-adj? is non-nil, in which case just the character count\n *   of an actual string is used.  If the length is less than the\n *   length of the input seq, then skip the remaining elements.  If\n *   the length is greater than the length of the input seq, fill out\n *   the missing elements with nils, and ensure that the last element\n *   is replaced by a nil (to avoid influencing the spacing of a column\n *   that it doesn't have).\n */\nzprint.util.size_and_extend = (function zprint$util$size_and_extend(length,no_string_adj_QMARK_,coll){\nvar last_good_col = (cljs.core.count(coll) - (1));\nvar coll__$1 = coll;\nvar index = (0);\nvar out = cljs.core.PersistentVector.EMPTY;\nwhile(true){\nif((index >= length)){\nreturn out;\n} else {\nvar G__41852 = cljs.core.next(coll__$1);\nvar G__41853 = (index + (1));\nvar G__41854 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,(((index >= last_good_col))?null:zprint.util.size.cljs$core$IFn$_invoke$arity$2(cljs.core.first(coll__$1),no_string_adj_QMARK_)));\ncoll__$1 = G__41852;\nindex = G__41853;\nout = G__41854;\ncontinue;\n}\nbreak;\n}\n});\n/**\n * Given a sequence of seqs, produce a new sequence of seqs where\n *   each element in the seq is replaced by the size of that element.\n *   If the element is already a string, the size is the number of\n *   characters plus 2 for the surrounding double quotes, unless\n *   no-string-adj? is non-nil, in which case just the character count\n *   of an actual string is used.  Do this for all of the elements in\n *   every seq but the last.  In addition, for every seq that is shorter\n *   than the longest one, fill out the missing elements with nils.\n */\nzprint.util.size_and_extend_butlast = (function zprint$util$size_and_extend_butlast(var_args){\nvar G__41740 = arguments.length;\nswitch (G__41740) {\ncase 3:\nreturn zprint.util.size_and_extend_butlast.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 1:\nreturn zprint.util.size_and_extend_butlast.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn zprint.util.size_and_extend_butlast.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(zprint.util.size_and_extend_butlast.cljs$core$IFn$_invoke$arity$3 = (function (seq_of_seqs,max_len,no_string_adj_QMARK_){\nvar len = (cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.max,cljs.core.map.cljs$core$IFn$_invoke$arity$2(cljs.core.count,seq_of_seqs)) - (1));\nvar len__$1 = (cljs.core.truth_(max_len)?(function (){var x__5133__auto__ = max_len;\nvar y__5134__auto__ = len;\nreturn ((x__5133__auto__ < y__5134__auto__) ? x__5133__auto__ : y__5134__auto__);\n})():len);\nvar seq_of_sizes = cljs.core.mapv.cljs$core$IFn$_invoke$arity$2(cljs.core.partial.cljs$core$IFn$_invoke$arity$3(zprint.util.size_and_extend,len__$1,no_string_adj_QMARK_),seq_of_seqs);\nreturn seq_of_sizes;\n}));\n\n(zprint.util.size_and_extend_butlast.cljs$core$IFn$_invoke$arity$1 = (function (seq_of_seqs){\nreturn zprint.util.size_and_extend_butlast.cljs$core$IFn$_invoke$arity$3(seq_of_seqs,null,null);\n}));\n\n(zprint.util.size_and_extend_butlast.cljs$core$IFn$_invoke$arity$2 = (function (seq_of_seqs,max_len){\nreturn zprint.util.size_and_extend_butlast.cljs$core$IFn$_invoke$arity$3(seq_of_seqs,max_len,null);\n}));\n\n(zprint.util.size_and_extend_butlast.cljs$lang$maxFixedArity = 3);\n\n/**\n * Given a seq of seqs, create a vector of vectors where every\n *   internal vector contains a series of integers representing the\n *   width of the element in that column across all of the seqs.  The\n *   width for the elements is their string length. Note that the\n *   length of actual strings is increased by two to account for the\n *   double quotes unless no-string-adj? is non-nil, in which case\n *   these routines assume that was already handled.  The various input\n *   seqs do not have to be the same length, and there will be as many\n *   columns as one less than the count of elements in the longest seq\n *   (or number-of-columns if it is specified and less than the count\n *   of the elements in the longest seq).  For seqs which do not extend\n *   to the maximum length, their positions in the column vectors will\n *   be filled with nil.\n */\nzprint.util.create_columns = (function zprint$util$create_columns(var_args){\nvar G__41753 = arguments.length;\nswitch (G__41753) {\ncase 3:\nreturn zprint.util.create_columns.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ncase 1:\nreturn zprint.util.create_columns.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn zprint.util.create_columns.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(zprint.util.create_columns.cljs$core$IFn$_invoke$arity$3 = (function (seq_of_seqs,number_of_columns,no_string_adj_QMARK_){\nvar seq_of_sizes = zprint.util.size_and_extend_butlast.cljs$core$IFn$_invoke$arity$3(seq_of_seqs,number_of_columns,no_string_adj_QMARK_);\nvar transpose = cljs.core.apply.cljs$core$IFn$_invoke$arity$3(cljs.core.mapv,cljs.core.vector,seq_of_sizes);\nreturn transpose;\n}));\n\n(zprint.util.create_columns.cljs$core$IFn$_invoke$arity$1 = (function (seq_of_seqs){\nreturn zprint.util.create_columns.cljs$core$IFn$_invoke$arity$3(seq_of_seqs,null,null);\n}));\n\n(zprint.util.create_columns.cljs$core$IFn$_invoke$arity$2 = (function (seq_of_seqs,number_of_columns){\nreturn zprint.util.create_columns.cljs$core$IFn$_invoke$arity$3(seq_of_seqs,number_of_columns,null);\n}));\n\n(zprint.util.create_columns.cljs$lang$maxFixedArity = 3);\n\n/**\n * Given a seq-of-seqs which contain elements to justify, return a\n *   vector with the size of the maximum element in each column that\n *   should be used to justify the next column.  Note that the length\n *   of actual strings is increased by two to account for the double\n *   quotes unless no-string-adj? is non-nil, in which case these\n *   routines assume that was already handled.  If number-of-columns\n *   is given, only justify that many columns, else justify all but\n *   the last. Note that if the max-variance is exceeded after having\n *   skipped the largest and second largest in a column, then the return\n *   is nil, signifying that justification is not possible.\n */\nzprint.util.column_alignment = (function zprint$util$column_alignment(var_args){\nvar G__41759 = arguments.length;\nswitch (G__41759) {\ncase 4:\nreturn zprint.util.column_alignment.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));\n\nbreak;\ncase 2:\nreturn zprint.util.column_alignment.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn zprint.util.column_alignment.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(zprint.util.column_alignment.cljs$core$IFn$_invoke$arity$4 = (function (max_variance,seq_of_seqs,number_of_columns,no_string_adj_QMARK_){\nvar columns = zprint.util.create_columns.cljs$core$IFn$_invoke$arity$3(seq_of_seqs,number_of_columns,no_string_adj_QMARK_);\nvar max_width_vec = cljs.core.second(cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (p__41760,index){\nvar vec__41761 = p__41760;\nvar columns__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41761,(0),null);\nvar max_width_vec = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41761,(1),null);\nvar vec__41765 = zprint.util.column_width_variance(max_variance,columns__$1,index);\nvar max_width = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41765,(0),null);\nvar new_columns = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41765,(1),null);\nif(cljs.core.truth_(max_width)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new_columns,cljs.core.conj.cljs$core$IFn$_invoke$arity$2(max_width_vec,max_width)], null);\n} else {\nreturn cljs.core.reduced(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [columns__$1,null], null));\n}\n}),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [columns,cljs.core.PersistentVector.EMPTY], null),cljs.core.range.cljs$core$IFn$_invoke$arity$1(cljs.core.count(columns))));\nreturn max_width_vec;\n}));\n\n(zprint.util.column_alignment.cljs$core$IFn$_invoke$arity$2 = (function (max_variance,seq_of_seqs){\nreturn zprint.util.column_alignment.cljs$core$IFn$_invoke$arity$4(max_variance,seq_of_seqs,null,null);\n}));\n\n(zprint.util.column_alignment.cljs$core$IFn$_invoke$arity$3 = (function (max_variance,seq_of_seqs,number_of_columns){\nreturn zprint.util.column_alignment.cljs$core$IFn$_invoke$arity$4(max_variance,seq_of_seqs,number_of_columns,null);\n}));\n\n(zprint.util.column_alignment.cljs$lang$maxFixedArity = 4);\n\n/**\n * Given a vector of max-widths from column-alignment, produce a vector\n *   of the cumulative alignment positions for the second through nth columns.\n */\nzprint.util.cumulative_alignment = (function zprint$util$cumulative_alignment(max_width_vec){\nreturn cljs.core.second(cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (p__41772,column_max_width){\nvar vec__41774 = p__41772;\nvar current_width = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41774,(0),null);\nvar cumulative_widths = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41774,(1),null);\nvar this_alignment = (current_width + (column_max_width + (1)));\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [this_alignment,cljs.core.conj.cljs$core$IFn$_invoke$arity$2(cumulative_widths,this_alignment)], null);\n}),new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [(0),cljs.core.PersistentVector.EMPTY], null),max_width_vec));\n});\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","zprint/util.cljc","~:line",1,"~:column",14,"~:end-line",1,"~:end-column",25,"~:no-doc",true],"~:ns-aliases",["^ ","~$clojure.spec.alpha","~$cljs.spec.alpha","~$clojure.tools.reader.impl.utils","~$cljs.tools.reader.impl.utils","~$cljs.loader","~$shadow.loader","~$clojure.tools.reader.impl.commons","~$cljs.tools.reader.impl.commons","~$clojure.tools.reader.impl.errors","~$cljs.tools.reader.impl.errors","~$react","~$module$node_modules$react$index","~$clojure.tools.reader.reader-types","~$cljs.tools.reader.reader-types","~$clojure.tools.reader.edn","~$cljs.tools.reader.edn","~$clojure.pprint","~$cljs.pprint","~$react-dom","~$module$node_modules$react_dom$index","~$clojure.repl","~$cljs.repl"],"~:use-macros",null,"~:excludes",["~#set",[]],"~:name","~$zprint.util","~:reader-aliases",["^ "],"~:op","~:ns","~:imports",null,"~:requires",["^ ","~$clojure.string","^11","~$s","^11","~$cljs.core","^12","~$goog","^13"],"~:seen",["^U",["~:require"]],"~:uses",null,"~:require-macros",["^ ","^12","^12"],"~:form",["~#list",["~$ns","^W",["^19",["^15",["^11","~:as","~$s"]]]]],"~:flags",["^ ","^15",["^U",[]]],"~:js-deps",["^ "],"~:deps",["^13","^12","^11"]],"^Z","^W","~:resource-id",["~:shadow.build.classpath/resource","zprint/util.cljc"],"~:compiled-at",1666857667481,"^X",["^ ","^11","^11","~$s","^11","^12","^12","^13","^13"],"~:resource-name","zprint/util.cljc","~:warnings",[],"~:source","(ns ^:no-doc zprint.util\n  (:require [clojure.string :as s]))\n\n(defn local-abs\n  \"Return the absolute value of a number.\"\n  [n]\n  (if (neg? n) (- n) n))\n\n(defn size\n  \"Return the size of an sexpr, essentially the number of characters\n  in its string representation.  If the sexpr is already a string,\n  return the number of characters in the string plus 2 to account\n  for the double quotes, unless no-string-adj? is non-nil.  In that\n  case, simply return the character count of the string.  If sexpr\n  is nil, return nil.\"\n  ([sexpr no-string-adj?]\n   (when sexpr\n     #_(prn \"size:\" sexpr \"string?\" (string? sexpr))\n     (let [s (str sexpr)\n           s (cond (clojure.string/starts-with? s \":zprint.core/\")\n                     (clojure.string/replace s \":zprint.core/\" \"::\")\n                   (clojure.string/starts-with? s \":clojure.core/\")\n                     (clojure.string/replace s \":clojure.core/\" \"::\")\n                   :else s)\n           s-count (count s)]\n       (if (and (not no-string-adj?) (string? sexpr)) (+ s-count 2) s-count))))\n  ([sexpr] (size sexpr nil)))\n\n(defn median\n  \"Find the median of a series of numbers.\"\n  [coll]\n  (let [sorted-coll (sort coll)\n        len (count coll)\n        middle (/ len 2)]\n    (if (odd? len)\n      (nth sorted-coll middle)\n      (let [lower (dec middle)\n            lower-middle (nth sorted-coll lower)\n            upper-middle (nth sorted-coll middle)]\n        (/ (+ lower-middle upper-middle) 2)))))\n\n(defn mean\n  \"Find the mean of a series of numbers.\"\n  [coll]\n  (when (not (empty? coll)) (/ (apply + coll) (count coll))))\n\n(defn percent-gt-n\n  \"Return the percentage of numbers greater than n.\"\n  [n coll]\n  (when (not (empty? coll))\n    (let [count-gt (reduce (fn [cnt m] (if (> m n) (inc cnt) cnt)) 0 coll)\n          percentage (int (* (/ count-gt (count coll)) 100))]\n      percentage)))\n\n(defn variance\n  \"Return the variance of a sequence of numbers. Ignore nil values.\n  Return the variance or nil if there are no numbers.\"\n  [coll]\n  (let [coll (remove nil? coll)\n        #_(println \"coll:\" coll \"len:\" (count coll))\n        len (count coll)]\n    (when (not (zero? len))\n      (let [mean (/ (apply + coll) len)\n            dev-from-mean (mapv (partial - mean) coll)\n            sq-dev-from-mean (mapv #(* % %) dev-from-mean)\n            variance (int (/ (apply + sq-dev-from-mean) len))]\n        #_(println \"variance:\" variance)\n        variance))))\n\n(defn find-max\n  \"Given a sequence of numbers, return the indices of all of the\n  numbers that are equal to the maximum number.  Returns: \n  [max-number [indicies-of-max-number] length-of-sequence]\"\n  [coll]\n  (let [indicies (reduce (fn [[max-so-far indicies index] n]\n                           (cond (nil? n) [max-so-far indicies (inc index)]\n                                 (> n max-so-far) [n [index] (inc index)]\n                                 (= n max-so-far) [max-so-far\n                                                   (conj indicies index)\n                                                   (inc index)]\n                                 :else [max-so-far indicies (inc index)]))\n                   [0 [] 0]\n                   coll)]\n    indicies))\n\n(defn remove-indicies\n  \"Given a vector, set specific indicies to nil.\"\n  [indicies coll]\n  (if indicies (apply assoc coll (interleave indicies (repeat nil))) coll))\n\n(defn remove-max-not-half\n  \"Given a vector of numbers, remove every instance of the maximum number \n  from the vector and replace it with nil, unless it would remove more \n  than half of the numbers in the vector, in which case return the vector\n  unchanged. Returns: [indicies-removed vector-with-max-removed]\"\n  [coll-vec]\n  (let [[max-number indicies length] (find-max coll-vec)]\n    (if (> (count indicies) (/ length 2))\n      [nil coll-vec]\n      [indicies (remove-indicies indicies coll-vec)])))\n\n(defn remove-indicies-from-columns\n  \"Given a vector of indicies and a vector of vectors (columns), remove \n  the specified indicies from the columns by replacing them with nil, starting\n  at the vector specified by the index.\"\n  [index indicies columns]\n  (if (< index (count columns))\n    (let [[beginning end] (split-at index columns)\n          beginning (into [] beginning)\n          end (into [] end)\n          new-end (mapv (partial remove-indicies indicies) end)]\n      (into beginning new-end))\n    columns))\n\n(defn count-non-nil\n  \"Count the non-nil items in a sequence.\"\n  [coll]\n  (reduce (fn [cnt x] (if (nil? x) cnt (inc cnt))) 0 coll))\n\n(defn column-width-variance\n  \"Given a vector of vectors, where each vector represents the sizes\n  in a column, find the variance of the column, and if it is too high\n  remove the largest and then second largest values to see if we can\n  get it low enough for alignment.  If yes, return the alignment and the\n  new vector of vectors (where the rows that were not considered for the\n  successful variance calculation have been removed from all (inc index)\n  columns).  If no, return nil and the unchanged vector of vectors. \n  Returns: [max-width-or-nil columns]\"\n  [max-variance columns index]\n  (if (>= index (count columns))\n    [nil columns]\n    (let [column (nth columns index)\n          #_(println \"column:\" column \"index:\" index)\n          beginning-variance (variance column)\n          row-count (count-non-nil column)]\n      #_(println \"beginning-variance:\" beginning-variance)\n      (cond\n        (nil? beginning-variance) [nil columns]\n        (> max-variance beginning-variance) [(first (find-max column)) columns]\n        ; Unless we have at least 3 rows, we aren't removing anything to\n        ; try and get the variance to work!\n        (> row-count 2)\n          (let [[first-indicies first-column-wo-max] (remove-max-not-half\n                                                       column)\n                #_(println \"column:\" column)\n                #_(println \"first-column-wo-max:\" first-column-wo-max)\n                first-variance (variance first-column-wo-max)]\n            (cond (nil? first-variance) [nil columns]\n                  (> max-variance first-variance)\n                    [(first (find-max first-column-wo-max))\n                     (remove-indicies-from-columns (inc index)\n                                                   first-indicies\n                                                   columns)]\n                  :else\n                    (let [[second-indicies second-column-wo-max]\n                            (remove-max-not-half first-column-wo-max)\n                          second-variance (variance second-column-wo-max)]\n                      (cond (nil? second-variance) [nil columns]\n                            ; Have we removed half of the rows\n                            ; between the first and second rounds?\n                            (>= (+ (count first-indicies)\n                                   (count second-indicies))\n                                (/ row-count 2))\n                              [nil columns]\n                            (> max-variance second-variance)\n                              [(first (find-max second-column-wo-max))\n                               (remove-indicies-from-columns\n                                 (inc index)\n                                 (into first-indicies second-indicies)\n                                 columns)]\n                            :else [nil columns]))))\n        :else [nil columns]))))\n\n(defn size-and-extend\n  \"Given a seq and a length, return a vector which contains the\n  size of every element in the seq and is the length specified.  If\n  the element is already a string, the size is the number of\n  characters plus 2 for the surrounding double quotes, unless\n  no-string-adj? is non-nil, in which case just the character count\n  of an actual string is used.  If the length is less than the\n  length of the input seq, then skip the remaining elements.  If\n  the length is greater than the length of the input seq, fill out\n  the missing elements with nils, and ensure that the last element\n  is replaced by a nil (to avoid influencing the spacing of a column\n  that it doesn't have).\"\n  [length no-string-adj? coll]\n  (let [last-good-col (dec (count coll))]\n    (loop [coll coll\n           index 0\n           out []]\n      (if (>= index length)\n        out\n        (recur (next coll)\n               (inc index)\n               (conj out\n                     (if (>= index last-good-col)\n                       nil\n                       (size (first coll) no-string-adj?))))))))\n\n(defn size-and-extend-butlast\n  \"Given a sequence of seqs, produce a new sequence of seqs where\n  each element in the seq is replaced by the size of that element.\n  If the element is already a string, the size is the number of\n  characters plus 2 for the surrounding double quotes, unless\n  no-string-adj? is non-nil, in which case just the character count\n  of an actual string is used.  Do this for all of the elements in\n  every seq but the last.  In addition, for every seq that is shorter\n  than the longest one, fill out the missing elements with nils.\"\n  ([seq-of-seqs max-len no-string-adj?]\n   #_(println \"size-and-extend-butlast: seq-of-seqs\" seq-of-seqs)\n   #_(println \"no-string-adj?\" no-string-adj?)\n   (let [len (dec (apply max (map count seq-of-seqs)))\n         len (if max-len (min max-len len) len)\n         seq-of-sizes (mapv (partial size-and-extend len no-string-adj?)\n                        seq-of-seqs)]\n     seq-of-sizes))\n  ([seq-of-seqs] (size-and-extend-butlast seq-of-seqs nil nil))\n  ([seq-of-seqs max-len] (size-and-extend-butlast seq-of-seqs max-len nil)))\n\n(defn create-columns\n  \"Given a seq of seqs, create a vector of vectors where every\n  internal vector contains a series of integers representing the\n  width of the element in that column across all of the seqs.  The\n  width for the elements is their string length. Note that the\n  length of actual strings is increased by two to account for the\n  double quotes unless no-string-adj? is non-nil, in which case\n  these routines assume that was already handled.  The various input\n  seqs do not have to be the same length, and there will be as many\n  columns as one less than the count of elements in the longest seq\n  (or number-of-columns if it is specified and less than the count\n  of the elements in the longest seq).  For seqs which do not extend\n  to the maximum length, their positions in the column vectors will\n  be filled with nil.\"\n  ([seq-of-seqs number-of-columns no-string-adj?]\n   (let [seq-of-sizes (size-and-extend-butlast seq-of-seqs\n                                               number-of-columns\n                                               no-string-adj?)\n         transpose (apply mapv vector seq-of-sizes)]\n     transpose))\n  ([seq-of-seqs] (create-columns seq-of-seqs nil nil))\n  ([seq-of-seqs number-of-columns]\n   (create-columns seq-of-seqs number-of-columns nil)))\n\n(defn column-alignment\n  \"Given a seq-of-seqs which contain elements to justify, return a\n  vector with the size of the maximum element in each column that\n  should be used to justify the next column.  Note that the length\n  of actual strings is increased by two to account for the double\n  quotes unless no-string-adj? is non-nil, in which case these\n  routines assume that was already handled.  If number-of-columns\n  is given, only justify that many columns, else justify all but\n  the last. Note that if the max-variance is exceeded after having\n  skipped the largest and second largest in a column, then the return\n  is nil, signifying that justification is not possible.\"\n  ([max-variance seq-of-seqs number-of-columns no-string-adj?]\n   (let [columns (create-columns seq-of-seqs number-of-columns no-string-adj?)\n         #_(println \"column count:\" (count columns))\n         max-width-vec\n           (second\n             (reduce\n               (fn [[columns max-width-vec] index]\n                 (let [[max-width new-columns]\n                         (column-width-variance max-variance columns index)]\n                   #_(println \"max-width:\" max-width)\n                   (if max-width\n                     [new-columns (conj max-width-vec max-width)]\n                     ; If we fail, then fail completely, don't return a\n                     ; short max-width-vec!  Issue #212.\n                     (reduced [columns nil]))))\n               [columns []]\n               (range (count columns))))]\n     max-width-vec))\n  ([max-variance seq-of-seqs]\n   (column-alignment max-variance seq-of-seqs nil nil))\n  ([max-variance seq-of-seqs number-of-columns]\n   (column-alignment max-variance seq-of-seqs number-of-columns nil)))\n\n(defn cumulative-alignment\n  \"Given a vector of max-widths from column-alignment, produce a vector\n  of the cumulative alignment positions for the second through nth columns.\"\n  [max-width-vec]\n  (second\n    (reduce (fn [[current-width cumulative-widths] column-max-width]\n              (let [this-alignment (+ current-width (inc column-max-width))]\n                [this-alignment (conj cumulative-widths this-alignment)]))\n      [0 []]\n      max-width-vec)))\n\n","~:reader-features",["^U",["~:cljs"]],"~:cljc",true,"~:source-map-compact",["^ ","mappings","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","names",["zprint.util/local-abs","n","var_args","G__41641","zprint.util/size","js/Error","sexpr","no-string-adj?","s","clojure.string/starts-with?","clojure.string/replace","s-count","cljs.core/not","zprint.util.size","zprint.util/median","coll","sorted-coll","cljs.core.sort","len","cljs.core/count","middle","cljs.core/odd?","cljs.core.nth","lower","lower-middle","upper-middle","zprint.util/mean","cljs.core/empty?","cljs.core.apply","cljs.core/+","zprint.util/percent-gt-n","count-gt","cljs.core.reduce","cnt","m","percentage","zprint.util/variance","cljs.core.remove","cljs.core/nil?","mean","dev-from-mean","cljs.core.mapv","cljs.core.partial","cljs.core/-","sq-dev-from-mean","p1__41677#","variance","zprint.util/find-max","indicies","p__41679","vec__41680","max-so-far","index","cljs.core._EQ_","cljs.core.conj","zprint.util/remove-indicies","cljs.core/assoc","cljs.core.interleave","cljs.core.repeat","zprint.util/remove-max-not-half","coll-vec","vec__41702","max-number","length","zprint.util/remove-indicies-from-columns","columns","vec__41708","beginning","end","cljs.core/split-at","cljs.core.into","new-end","zprint.util/count-non-nil","x","zprint.util/column-width-variance","max-variance","column","beginning-variance","row-count","cljs.core/first","vec__41719","first-indicies","first-column-wo-max","first-variance","vec__41728","second-indicies","second-column-wo-max","second-variance","zprint.util/size-and-extend","last-good-col","out","cljs.core/next","G__41740","zprint.util/size-and-extend-butlast","seq-of-seqs","max-len","cljs.core/max","cljs.core.map","x__5133__auto__","y__5134__auto__","seq-of-sizes","zprint.util.size_and_extend_butlast","G__41753","zprint.util/create-columns","number-of-columns","transpose","cljs.core/mapv","cljs.core/vector","zprint.util.create_columns","G__41759","zprint.util/column-alignment","max-width-vec","cljs.core/second","p__41760","vec__41761","vec__41765","max-width","new-columns","cljs.core/reduced","cljs.core.range","zprint.util.column_alignment","zprint.util/cumulative-alignment","p__41772","vec__41774","current-width","cumulative-widths","column-max-width","this-alignment"]],"~:used-vars",["^U",["~$zprint.util/percent-gt-n","~$cljs.core/odd?","~$clojure.string/starts-with?","~$zprint.util/find-max","~$cljs.core/=","~$zprint.util/remove-indicies-from-columns","~$cljs.core/partial","~$cljs.core/count","~$cljs.core/reduce","~$cljs.core/apply","~$zprint.util/column-alignment","~$cljs.core/mapv","~$zprint.util/size-and-extend-butlast","~$zprint.util/create-columns","~$cljs.core/empty?","~$cljs.core/-","~$cljs.core/into","~$zprint.util/count-non-nil","~$cljs.core/conj","~$zprint.util/cumulative-alignment","~$cljs.core/sort","~$cljs.core/map","~$zprint.util/size","~$zprint.util/mean","~$cljs.core/remove","~$zprint.util/size-and-extend","~$zprint.util/median","~$cljs.core/reduced","~$cljs.core/nil?","~$cljs.core/nth","~$cljs.core/split-at","~$cljs.core/max","~$cljs.core/second","~$clojure.string/replace","~$cljs.core/interleave","~$zprint.util/variance","~$zprint.util/column-width-variance","~$cljs.core/next","~$zprint.util/remove-indicies","~$cljs.core/not","~$cljs.core/assoc","~$cljs.core/range","~$cljs.core/repeat","~$zprint.util/local-abs","~$cljs.core/first","~$cljs.core/+","~$js/Error","~$zprint.util/remove-max-not-half","~$cljs.core/vector"]]],"~:cache-keys",["~#cmap",[["^1@","goog/dom/tagname.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","~:shadow.build.compiler/resolve",["^ ","~:require-id",null,"~:deps-ids",["^U",[]],"~:deps-syms",["^13","~$goog.dom.HtmlElement"]]],["^1@","goog/html/trustedtypes.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2S",["^ ","^2T",null,"^2U",["^U",[]],"^2V",["^13"]]],["^1@","goog/labs/useragent/browser.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2S",["^ ","^2T",null,"^2U",["^U",[]],"^2V",["^13","~$goog.array","~$goog.object","~$goog.labs.userAgent.util","~$goog.string.internal"]]],["^1@","goog/html/safeurl.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2S",["^ ","^2T",null,"^2U",["^U",[]],"^2V",["^13","~$goog.asserts","~$goog.fs.url","~$goog.html.TrustedResourceUrl","~$goog.i18n.bidi.Dir","~$goog.i18n.bidi.DirectionalString","~$goog.string.Const","~$goog.string.TypedString","^2["]]],["^1@","goog/array/array.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2S",["^ ","^2T",null,"^2U",["^U",[]],"^2V",["^13","^30"]]],["^1@","goog/debug/error.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2S",["^ ","^2T",null,"^2U",["^U",[]],"^2V",["^13"]]],["^1@","goog/dom/nodetype.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2S",["^ ","^2T",null,"^2U",["^U",[]],"^2V",["^13"]]],["^1@","goog/string/typedstring.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2S",["^ ","^2T",null,"^2U",["^U",[]],"^2V",["^13"]]],["^1@","goog/object/object.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2S",["^ ","^2T",null,"^2U",["^U",[]],"^2V",["^13"]]],["^1@","goog/dom/asserts.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2S",["^ ","^2T",null,"^2U",["^U",[]],"^2V",["^13","^30"]]],"~:SHADOW-TIMESTAMP",[1666857604000,1666857604000,1666857293000],["^1@","goog/math/long.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2S",["^ ","^2T",null,"^2U",["^U",[]],"^2V",["^13","^30","~$goog.reflect"]]],["^1@","goog/html/trustedresourceurl.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2S",["^ ","^2T",null,"^2U",["^U",[]],"^2V",["^13","^30","~$goog.fs.blob","^31","~$goog.html.SafeScript","~$goog.html.trustedtypes","^33","^34","^35","^36"]]],["^1@","goog/string/internal.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2S",["^ ","^2T",null,"^2U",["^U",[]],"^2V",["^13"]]],["^1@","goog/functions/functions.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2S",["^ ","^2T",null,"^2U",["^U",[]],"^2V",["^13"]]],["^1@","goog/html/safestyle.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2S",["^ ","^2T",null,"^2U",["^U",[]],"^2V",["^13","^35","~$goog.html.SafeUrl","^36","^30","^2["]]],["^1@","goog/dom/safe.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2S",["^ ","^2T",null,"^2U",["^U",[]],"^2V",["^13","^30","~$goog.dom.asserts","~$goog.functions","~$goog.html.SafeHtml","^3:","~$goog.html.SafeStyle","^3<","^32","~$goog.html.uncheckedconversions","^35","^2["]]],["^1@","goog/html/safehtml.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2S",["^ ","^2T",null,"^2U",["^U",[]],"^2V",["^13","^35","^33","^34","^3:","^3@","~$goog.html.SafeStyleSheet","^3<","~$goog.dom.TagName","^32","^36","^30","~$goog.labs.userAgent.browser","^2X","^2Y","^2[","~$goog.dom.tags","^3;"]]],["^1@","goog/dom/tags.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2S",["^ ","^2T",null,"^2U",["^U",[]],"^2V",["^13","^2Y"]]],["^1@","goog/fs/blob.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2S",["^ ","^2T",null,"^2U",["^U",[]],"^2V",["^13"]]],["^1@","goog/asserts/asserts.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2S",["^ ","^2T",null,"^2U",["^U",[]],"^2V",["^13","~$goog.debug.Error","~$goog.dom.NodeType"]]],["^1@","goog/uri/uri.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2S",["^ ","^2T",null,"^2U",["^U",[]],"^2V",["^13","^2X","^30","~$goog.collections.maps","~$goog.string","~$goog.structs","~$goog.uri.utils","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"]]],["^1@","goog/collections/maps.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2S",["^ ","^2T",null,"^2U",["^U",[]],"^2V",["^13"]]],["^1@","goog/i18n/bidi.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2S",["^ ","^2T",null,"^2U",["^U",[]],"^2V",["^13"]]],["^1@","goog/fs/url.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2S",["^ ","^2T",null,"^2U",["^U",[]],"^2V",["^13"]]],["^1@","goog/base.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2S",["^ ","^2T",null,"^2U",["^U",[]],"^2V",[]]],["^1@","goog/structs/structs.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2S",["^ ","^2T",null,"^2U",["^U",[]],"^2V",["^13","^2X","^2Y"]]],["^1@","zprint/util.cljc"],["6c7de285c399d67aaa77693a88b73d129953fa1f","^2S",["^ ","^2T",null,"^2U",["^U",[]],"^2V",["^13","^12","^11"]]],["^1@","clojure/string.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^2S",["^ ","^2T",null,"^2U",["^U",[]],"^2V",["^13","^12","^3I","~$goog.string.StringBuffer"]]],["^1@","goog/string/string.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2S",["^ ","^2T",null,"^2U",["^U",[]],"^2V",["^13","~$goog.dom.safe","^3A","^35","^2["]]],["^1@","goog/reflect/reflect.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2S",["^ ","^2T",null,"^2U",["^U",[]],"^2V",["^13"]]],["^1@","goog/labs/useragent/util.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2S",["^ ","^2T",null,"^2U",["^U",[]],"^2V",["^13","~$goog.labs.userAgent","^2["]]],["^1@","goog/string/stringbuffer.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2S",["^ ","^2T",null,"^2U",["^U",[]],"^2V",["^13"]]],["^1@","goog/labs/useragent/useragent.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2S",["^ ","^2T",null,"^2U",["^U",[]],"^2V",["^13"]]],["^1@","goog/html/uncheckedconversions.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2S",["^ ","^2T",null,"^2U",["^U",[]],"^2V",["^13","^30","^3?","^3:","^3@","^3B","^3<","^32","^35","^2[","^33"]]],["^1@","goog/dom/htmlelement.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2S",["^ ","^2T",null,"^2U",["^U",[]],"^2V",["^13"]]],["^1@","cljs/core.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^2S",["^ ","^2T",null,"^2U",["^U",[]],"^2V",["^13","~$goog.math.Long","~$goog.math.Integer","^3I","^2Y","^2X","~$goog.Uri","^3N"]]],["^1@","goog/html/safescript.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2S",["^ ","^2T",null,"^2U",["^U",[]],"^2V",["^13","^35","^36","^3;","^30"]]],["^1@","goog/html/safestylesheet.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2S",["^ ","^2T",null,"^2U",["^U",[]],"^2V",["^13","^35","^3@","^36","^2Y","^30","^2["]]],["^1@","goog/math/integer.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2S",["^ ","^2T",null,"^2U",["^U",[]],"^2V",["^13","^38"]]],["^1@","goog/uri/utils.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2S",["^ ","^2T",null,"^2U",["^U",[]],"^2V",["^13","^30","^3I"]]],["^1@","goog/string/const.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^2S",["^ ","^2T",null,"^2U",["^U",[]],"^2V",["^13","^30","^36"]]]]],"~:clj-info",["^ ","jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/string.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/impl/errors.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/env.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/default_data_readers.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/core.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/edn.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/reader_types.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/util.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/compiler.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/impl/inspect.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/passes/and_or.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/pprint.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map/base64_vlq.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/set.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/instant.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map/base64.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/externs.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/js_deps.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/binaryage/devtools/1.0.6/devtools-1.0.6.jar!/devtools/defaults.clj",1666857314000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/java/io.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/impl.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/tagged_literals.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/core.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/passes.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/data/json.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/instant.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/impl/namespaces.cljc",1666857293000],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","zprint/util.cljc","^7",1,"^8",14,"^9",1,"^:",25,"^;",true],"^<",["^ ","^=","^>","^?","^@","^A","^B","^C","^D","^E","^F","^G","^H","^I","^J","^K","^L","^M","^N","^O","^P","^Q","^R"],"^S",null,"^T",["^U",[]],"^V","^W","^X",["^ "],"^[",null,"^10",["^ ","^11","^11","~$s","^11","^12","^12","^13","^13"],"^14",["^U",["^15"]],"~:shadow/js-access-global",["^U",["Error"]],"^16",null,"~:defs",["^ ","~$remove-indicies-from-columns",["^ ","~:protocol-inline",null,"^5",["^ ","^6","zprint/util.cljc","^7",102,"^8",7,"^9",102,"^:",35,"~:arglists",["^19",["~$quote",["^19",[["~$index","~$indicies","~$columns"]]]]],"~:doc","Given a vector of indicies and a vector of vectors (columns), remove \n  the specified indicies from the columns by replacing them with nil, starting\n  at the vector specified by the index."],"^V","^1Q","^6","zprint/util.cljc","^:",35,"~:method-params",["^19",[["^4N","^4O","^4P"]]],"~:protocol-impl",null,"~:arglists-meta",["^19",[null,null]],"^8",1,"~:variadic?",false,"^7",102,"~:ret-tag",["^U",[null,"~$clj","~$any"]],"^9",102,"~:max-fixed-arity",3,"~:fn-var",true,"^4L",["^19",["^4M",["^19",[["^4N","^4O","^4P"]]]]],"^4Q","Given a vector of indicies and a vector of vectors (columns), remove \n  the specified indicies from the columns by replacing them with nil, starting\n  at the vector specified by the index."],"~$find-max",["^ ","^4K",null,"^5",["^ ","^6","zprint/util.cljc","^7",70,"^8",7,"^9",70,"^:",15,"^4L",["^19",["^4M",["^19",[["~$coll"]]]]],"^4Q","Given a sequence of numbers, return the indices of all of the\n  numbers that are equal to the maximum number.  Returns: \n  [max-number [indicies-of-max-number] length-of-sequence]"],"^V","^1O","^6","zprint/util.cljc","^:",15,"^4R",["^19",[["^50"]]],"^4S",null,"^4T",["^19",[null,null]],"^8",1,"^4U",false,"^7",70,"^4V",["^U",[null,"^4X"]],"^9",70,"^4Y",1,"^4Z",true,"^4L",["^19",["^4M",["^19",[["^50"]]]]],"^4Q","Given a sequence of numbers, return the indices of all of the\n  numbers that are equal to the maximum number.  Returns: \n  [max-number [indicies-of-max-number] length-of-sequence]"],"~$local-abs",["^ ","^4K",null,"^5",["^ ","^6","zprint/util.cljc","^7",4,"^8",7,"^9",4,"^:",16,"^4L",["^19",["^4M",["^19",[["~$n"]]]]],"^4Q","Return the absolute value of a number."],"^V","^2K","^6","zprint/util.cljc","^:",16,"^4R",["^19",[["~$n"]]],"^4S",null,"^4T",["^19",[null,null]],"^8",1,"^4U",false,"^7",4,"^4V",["^U",[null,"~$number"]],"^9",4,"^4Y",1,"^4Z",true,"^4L",["^19",["^4M",["^19",[["~$n"]]]]],"^4Q","Return the absolute value of a number."],"~$cumulative-alignment",["^ ","^4K",null,"^5",["^ ","^6","zprint/util.cljc","^7",278,"^8",7,"^9",278,"^:",27,"^4L",["^19",["^4M",["^19",[["~$max-width-vec"]]]]],"^4Q","Given a vector of max-widths from column-alignment, produce a vector\n  of the cumulative alignment positions for the second through nth columns."],"^V","^23","^6","zprint/util.cljc","^:",27,"^4R",["^19",[["^54"]]],"^4S",null,"^4T",["^19",[null,null]],"^8",1,"^4U",false,"^7",278,"^4V",["^U",["^4X","~$clj-nil"]],"^9",278,"^4Y",1,"^4Z",true,"^4L",["^19",["^4M",["^19",[["^54"]]]]],"^4Q","Given a vector of max-widths from column-alignment, produce a vector\n  of the cumulative alignment positions for the second through nth columns."],"~$mean",["^ ","^4K",null,"^5",["^ ","^6","zprint/util.cljc","^7",42,"^8",7,"^9",42,"^:",11,"^4L",["^19",["^4M",["^19",[["^50"]]]]],"^4Q","Find the mean of a series of numbers."],"^V","^27","^6","zprint/util.cljc","^:",11,"^4R",["^19",[["^50"]]],"^4S",null,"^4T",["^19",[null,null]],"^8",1,"^4U",false,"^7",42,"^4V",["^U",["^52","^55"]],"^9",42,"^4Y",1,"^4Z",true,"^4L",["^19",["^4M",["^19",[["^50"]]]]],"^4Q","Find the mean of a series of numbers."],"~$size-and-extend-butlast",["^ ","^4K",null,"^5",["^ ","^6","zprint/util.cljc","^7",200,"^8",7,"^9",200,"^:",30,"^4L",["^19",["^4M",["^19",[["~$seq-of-seqs","~$max-len","~$no-string-adj?"],["^58"],["^58","^59"]]]]],"^4Q","Given a sequence of seqs, produce a new sequence of seqs where\n  each element in the seq is replaced by the size of that element.\n  If the element is already a string, the size is the number of\n  characters plus 2 for the surrounding double quotes, unless\n  no-string-adj? is non-nil, in which case just the character count\n  of an actual string is used.  Do this for all of the elements in\n  every seq but the last.  In addition, for every seq that is shorter\n  than the longest one, fill out the missing elements with nils.","~:top-fn",["^ ","^4U",false,"~:fixed-arity",3,"^4Y",3,"^4R",[["^58","^59","^5:"],["^58"],["^58","^59"]],"^4L",["^19",[["^58","^59","^5:"],["^58"],["^58","^59"]]],"^4T",["^19",[null,null,null]]]],"^V","^1X","^6","zprint/util.cljc","^:",30,"^5;",["^ ","^4U",false,"^5<",3,"^4Y",3,"^4R",[["^58","^59","^5:"],["^58"],["^58","^59"]],"^4L",["^19",[["^58","^59","^5:"],["^58"],["^58","^59"]]],"^4T",["^19",[null,null,null]]],"^4R",[["^58","^59","^5:"],["^58"],["^58","^59"]],"^4S",null,"^5<",3,"^4T",["^19",[null,null,null]],"^8",1,"^4U",false,"~:methods",[["^ ","^5<",3,"^4U",false,"~:tag","^4W"],["^ ","^5<",1,"^4U",false,"^5>","^4W"],["^ ","^5<",2,"^4U",false,"^5>","^4W"]],"^7",200,"^9",200,"^4Y",3,"^4Z",true,"^4L",["^19",[["^58","^59","^5:"],["^58"],["^58","^59"]]],"^4Q","Given a sequence of seqs, produce a new sequence of seqs where\n  each element in the seq is replaced by the size of that element.\n  If the element is already a string, the size is the number of\n  characters plus 2 for the surrounding double quotes, unless\n  no-string-adj? is non-nil, in which case just the character count\n  of an actual string is used.  Do this for all of the elements in\n  every seq but the last.  In addition, for every seq that is shorter\n  than the longest one, fill out the missing elements with nils."],"~$percent-gt-n",["^ ","^4K",null,"^5",["^ ","^6","zprint/util.cljc","^7",47,"^8",7,"^9",47,"^:",19,"^4L",["^19",["^4M",["^19",[["~$n","^50"]]]]],"^4Q","Return the percentage of numbers greater than n."],"^V","^1L","^6","zprint/util.cljc","^:",19,"^4R",["^19",[["~$n","^50"]]],"^4S",null,"^4T",["^19",[null,null]],"^8",1,"^4U",false,"^7",47,"^4V",["^U",["^52","^55"]],"^9",47,"^4Y",2,"^4Z",true,"^4L",["^19",["^4M",["^19",[["~$n","^50"]]]]],"^4Q","Return the percentage of numbers greater than n."],"~$count-non-nil",["^ ","^4K",null,"^5",["^ ","^6","zprint/util.cljc","^7",115,"^8",7,"^9",115,"^:",20,"^4L",["^19",["^4M",["^19",[["^50"]]]]],"^4Q","Count the non-nil items in a sequence."],"^V","^21","^6","zprint/util.cljc","^:",20,"^4R",["^19",[["^50"]]],"^4S",null,"^4T",["^19",[null,null]],"^8",1,"^4U",false,"^7",115,"^4V",["^U",[null,"^4X"]],"^9",115,"^4Y",1,"^4Z",true,"^4L",["^19",["^4M",["^19",[["^50"]]]]],"^4Q","Count the non-nil items in a sequence."],"~$size-and-extend",["^ ","^4K",null,"^5",["^ ","^6","zprint/util.cljc","^7",174,"^8",7,"^9",174,"^:",22,"^4L",["^19",["^4M",["^19",[["~$length","^5:","^50"]]]]],"^4Q","Given a seq and a length, return a vector which contains the\n  size of every element in the seq and is the length specified.  If\n  the element is already a string, the size is the number of\n  characters plus 2 for the surrounding double quotes, unless\n  no-string-adj? is non-nil, in which case just the character count\n  of an actual string is used.  If the length is less than the\n  length of the input seq, then skip the remaining elements.  If\n  the length is greater than the length of the input seq, fill out\n  the missing elements with nils, and ensure that the last element\n  is replaced by a nil (to avoid influencing the spacing of a column\n  that it doesn't have)."],"^V","^29","^6","zprint/util.cljc","^:",22,"^4R",["^19",[["^5B","^5:","^50"]]],"^4S",null,"^4T",["^19",[null,null]],"^8",1,"^4U",false,"^7",174,"^4V",["^U",["^4W","~$cljs.core/IVector"]],"^9",174,"^4Y",3,"^4Z",true,"^4L",["^19",["^4M",["^19",[["^5B","^5:","^50"]]]]],"^4Q","Given a seq and a length, return a vector which contains the\n  size of every element in the seq and is the length specified.  If\n  the element is already a string, the size is the number of\n  characters plus 2 for the surrounding double quotes, unless\n  no-string-adj? is non-nil, in which case just the character count\n  of an actual string is used.  If the length is less than the\n  length of the input seq, then skip the remaining elements.  If\n  the length is greater than the length of the input seq, fill out\n  the missing elements with nils, and ensure that the last element\n  is replaced by a nil (to avoid influencing the spacing of a column\n  that it doesn't have)."],"~$column-width-variance",["^ ","^4K",null,"^5",["^ ","^6","zprint/util.cljc","^7",120,"^8",7,"^9",120,"^:",28,"^4L",["^19",["^4M",["^19",[["~$max-variance","^4P","^4N"]]]]],"^4Q","Given a vector of vectors, where each vector represents the sizes\n  in a column, find the variance of the column, and if it is too high\n  remove the largest and then second largest values to see if we can\n  get it low enough for alignment.  If yes, return the alignment and the\n  new vector of vectors (where the rows that were not considered for the\n  successful variance calculation have been removed from all (inc index)\n  columns).  If no, return nil and the unchanged vector of vectors. \n  Returns: [max-width-or-nil columns]"],"^V","^2D","^6","zprint/util.cljc","^:",28,"^4R",["^19",[["^5E","^4P","^4N"]]],"^4S",null,"^4T",["^19",[null,null]],"^8",1,"^4U",false,"^7",120,"^4V","^5C","^9",120,"^4Y",3,"^4Z",true,"^4L",["^19",["^4M",["^19",[["^5E","^4P","^4N"]]]]],"^4Q","Given a vector of vectors, where each vector represents the sizes\n  in a column, find the variance of the column, and if it is too high\n  remove the largest and then second largest values to see if we can\n  get it low enough for alignment.  If yes, return the alignment and the\n  new vector of vectors (where the rows that were not considered for the\n  successful variance calculation have been removed from all (inc index)\n  columns).  If no, return nil and the unchanged vector of vectors. \n  Returns: [max-width-or-nil columns]"],"~$variance",["^ ","^4K",null,"^5",["^ ","^6","zprint/util.cljc","^7",55,"^8",7,"^9",55,"^:",15,"^4L",["^19",["^4M",["^19",[["^50"]]]]],"^4Q","Return the variance of a sequence of numbers. Ignore nil values.\n  Return the variance or nil if there are no numbers."],"^V","^2C","^6","zprint/util.cljc","^:",15,"^4R",["^19",[["^50"]]],"^4S",null,"^4T",["^19",[null,null]],"^8",1,"^4U",false,"^7",55,"^4V",["^U",["^52","^55"]],"^9",55,"^4Y",1,"^4Z",true,"^4L",["^19",["^4M",["^19",[["^50"]]]]],"^4Q","Return the variance of a sequence of numbers. Ignore nil values.\n  Return the variance or nil if there are no numbers."],"~$column-alignment",["^ ","^4K",null,"^5",["^ ","^6","zprint/util.cljc","^7",244,"^8",7,"^9",244,"^:",23,"^4L",["^19",["^4M",["^19",[["^5E","^58","~$number-of-columns","^5:"],["^5E","^58"],["^5E","^58","^5H"]]]]],"^4Q","Given a seq-of-seqs which contain elements to justify, return a\n  vector with the size of the maximum element in each column that\n  should be used to justify the next column.  Note that the length\n  of actual strings is increased by two to account for the double\n  quotes unless no-string-adj? is non-nil, in which case these\n  routines assume that was already handled.  If number-of-columns\n  is given, only justify that many columns, else justify all but\n  the last. Note that if the max-variance is exceeded after having\n  skipped the largest and second largest in a column, then the return\n  is nil, signifying that justification is not possible.","^5;",["^ ","^4U",false,"^5<",4,"^4Y",4,"^4R",[["^5E","^58","^5H","^5:"],["^5E","^58"],["^5E","^58","^5H"]],"^4L",["^19",[["^5E","^58","^5H","^5:"],["^5E","^58"],["^5E","^58","^5H"]]],"^4T",["^19",[null,null,null]]]],"^V","^1V","^6","zprint/util.cljc","^:",23,"^5;",["^ ","^4U",false,"^5<",4,"^4Y",4,"^4R",[["^5E","^58","^5H","^5:"],["^5E","^58"],["^5E","^58","^5H"]],"^4L",["^19",[["^5E","^58","^5H","^5:"],["^5E","^58"],["^5E","^58","^5H"]]],"^4T",["^19",[null,null,null]]],"^4R",[["^5E","^58","^5H","^5:"],["^5E","^58"],["^5E","^58","^5H"]],"^4S",null,"^5<",4,"^4T",["^19",[null,null,null]],"^8",1,"^4U",false,"^5=",[["^ ","^5<",4,"^4U",false,"^5>",["^U",["^4X","^55"]]],["^ ","^5<",2,"^4U",false,"^5>",["^U",["^4X","^55"]]],["^ ","^5<",3,"^4U",false,"^5>",["^U",["^4X","^55"]]]],"^7",244,"^9",244,"^4Y",4,"^4Z",true,"^4L",["^19",[["^5E","^58","^5H","^5:"],["^5E","^58"],["^5E","^58","^5H"]]],"^4Q","Given a seq-of-seqs which contain elements to justify, return a\n  vector with the size of the maximum element in each column that\n  should be used to justify the next column.  Note that the length\n  of actual strings is increased by two to account for the double\n  quotes unless no-string-adj? is non-nil, in which case these\n  routines assume that was already handled.  If number-of-columns\n  is given, only justify that many columns, else justify all but\n  the last. Note that if the max-variance is exceeded after having\n  skipped the largest and second largest in a column, then the return\n  is nil, signifying that justification is not possible."],"~$create-columns",["^ ","^4K",null,"^5",["^ ","^6","zprint/util.cljc","^7",220,"^8",7,"^9",220,"^:",21,"^4L",["^19",["^4M",["^19",[["^58","^5H","^5:"],["^58"],["^58","^5H"]]]]],"^4Q","Given a seq of seqs, create a vector of vectors where every\n  internal vector contains a series of integers representing the\n  width of the element in that column across all of the seqs.  The\n  width for the elements is their string length. Note that the\n  length of actual strings is increased by two to account for the\n  double quotes unless no-string-adj? is non-nil, in which case\n  these routines assume that was already handled.  The various input\n  seqs do not have to be the same length, and there will be as many\n  columns as one less than the count of elements in the longest seq\n  (or number-of-columns if it is specified and less than the count\n  of the elements in the longest seq).  For seqs which do not extend\n  to the maximum length, their positions in the column vectors will\n  be filled with nil.","^5;",["^ ","^4U",false,"^5<",3,"^4Y",3,"^4R",[["^58","^5H","^5:"],["^58"],["^58","^5H"]],"^4L",["^19",[["^58","^5H","^5:"],["^58"],["^58","^5H"]]],"^4T",["^19",[null,null,null]]]],"^V","^1Y","^6","zprint/util.cljc","^:",21,"^5;",["^ ","^4U",false,"^5<",3,"^4Y",3,"^4R",[["^58","^5H","^5:"],["^58"],["^58","^5H"]],"^4L",["^19",[["^58","^5H","^5:"],["^58"],["^58","^5H"]]],"^4T",["^19",[null,null,null]]],"^4R",[["^58","^5H","^5:"],["^58"],["^58","^5H"]],"^4S",null,"^5<",3,"^4T",["^19",[null,null,null]],"^8",1,"^4U",false,"^5=",[["^ ","^5<",3,"^4U",false,"^5>","^4X"],["^ ","^5<",1,"^4U",false,"^5>","^4X"],["^ ","^5<",2,"^4U",false,"^5>","^4X"]],"^7",220,"^9",220,"^4Y",3,"^4Z",true,"^4L",["^19",[["^58","^5H","^5:"],["^58"],["^58","^5H"]]],"^4Q","Given a seq of seqs, create a vector of vectors where every\n  internal vector contains a series of integers representing the\n  width of the element in that column across all of the seqs.  The\n  width for the elements is their string length. Note that the\n  length of actual strings is increased by two to account for the\n  double quotes unless no-string-adj? is non-nil, in which case\n  these routines assume that was already handled.  The various input\n  seqs do not have to be the same length, and there will be as many\n  columns as one less than the count of elements in the longest seq\n  (or number-of-columns if it is specified and less than the count\n  of the elements in the longest seq).  For seqs which do not extend\n  to the maximum length, their positions in the column vectors will\n  be filled with nil."],"~$size",["^ ","^4K",null,"^5",["^ ","^6","zprint/util.cljc","^7",9,"^8",7,"^9",9,"^:",11,"^4L",["^19",["^4M",["^19",[["~$sexpr","^5:"],["^5K"]]]]],"^4Q","Return the size of an sexpr, essentially the number of characters\n  in its string representation.  If the sexpr is already a string,\n  return the number of characters in the string plus 2 to account\n  for the double quotes, unless no-string-adj? is non-nil.  In that\n  case, simply return the character count of the string.  If sexpr\n  is nil, return nil.","^5;",["^ ","^4U",false,"^5<",2,"^4Y",2,"^4R",[["^5K","^5:"],["^5K"]],"^4L",["^19",[["^5K","^5:"],["^5K"]]],"^4T",["^19",[null,null]]]],"^V","^26","^6","zprint/util.cljc","^:",11,"^5;",["^ ","^4U",false,"^5<",2,"^4Y",2,"^4R",[["^5K","^5:"],["^5K"]],"^4L",["^19",[["^5K","^5:"],["^5K"]]],"^4T",["^19",[null,null]]],"^4R",[["^5K","^5:"],["^5K"]],"^4S",null,"^5<",2,"^4T",["^19",[null,null]],"^8",1,"^4U",false,"^5=",[["^ ","^5<",2,"^4U",false,"^5>",["^U",["^52","^55"]]],["^ ","^5<",1,"^4U",false,"^5>",["^U",["^52","^55"]]]],"^7",9,"^9",9,"^4Y",2,"^4Z",true,"^4L",["^19",[["^5K","^5:"],["^5K"]]],"^4Q","Return the size of an sexpr, essentially the number of characters\n  in its string representation.  If the sexpr is already a string,\n  return the number of characters in the string plus 2 to account\n  for the double quotes, unless no-string-adj? is non-nil.  In that\n  case, simply return the character count of the string.  If sexpr\n  is nil, return nil."],"~$remove-indicies",["^ ","^4K",null,"^5",["^ ","^6","zprint/util.cljc","^7",86,"^8",7,"^9",86,"^:",22,"^4L",["^19",["^4M",["^19",[["^4O","^50"]]]]],"^4Q","Given a vector, set specific indicies to nil."],"^V","^2F","^6","zprint/util.cljc","^:",22,"^4R",["^19",[["^4O","^50"]]],"^4S",null,"^4T",["^19",[null,null]],"^8",1,"^4U",false,"^7",86,"^4V",["^U",[null,"^4X"]],"^9",86,"^4Y",2,"^4Z",true,"^4L",["^19",["^4M",["^19",[["^4O","^50"]]]]],"^4Q","Given a vector, set specific indicies to nil."],"~$median",["^ ","^4K",null,"^5",["^ ","^6","zprint/util.cljc","^7",29,"^8",7,"^9",29,"^:",13,"^4L",["^19",["^4M",["^19",[["^50"]]]]],"^4Q","Find the median of a series of numbers."],"^V","^2:","^6","zprint/util.cljc","^:",13,"^4R",["^19",[["^50"]]],"^4S",null,"^4T",["^19",[null,null]],"^8",1,"^4U",false,"^7",29,"^4V",["^U",["^4X","^52","^55"]],"^9",29,"^4Y",1,"^4Z",true,"^4L",["^19",["^4M",["^19",[["^50"]]]]],"^4Q","Find the median of a series of numbers."],"~$remove-max-not-half",["^ ","^4K",null,"^5",["^ ","^6","zprint/util.cljc","^7",91,"^8",7,"^9",91,"^:",26,"^4L",["^19",["^4M",["^19",[["~$coll-vec"]]]]],"^4Q","Given a vector of numbers, remove every instance of the maximum number \n  from the vector and replace it with nil, unless it would remove more \n  than half of the numbers in the vector, in which case return the vector\n  unchanged. Returns: [indicies-removed vector-with-max-removed]"],"^V","^2O","^6","zprint/util.cljc","^:",26,"^4R",["^19",[["^5O"]]],"^4S",null,"^4T",["^19",[null,null]],"^8",1,"^4U",false,"^7",91,"^4V","^5C","^9",91,"^4Y",1,"^4Z",true,"^4L",["^19",["^4M",["^19",[["^5O"]]]]],"^4Q","Given a vector of numbers, remove every instance of the maximum number \n  from the vector and replace it with nil, unless it would remove more \n  than half of the numbers in the vector, in which case return the vector\n  unchanged. Returns: [indicies-removed vector-with-max-removed]"]],"^17",["^ ","^12","^12"],"~:cljs.analyzer/constants",["^ ","^14",["^U",["~:else"]],"~:order",["^5Q"]],"^1<",["^ ","^15",["^U",[]]],"^1=",["^ "],"^1>",["^13","^12","^11"]],"^Z","^W","~:ns-specs",["^ "],"~:ns-spec-vars",["^U",[]],"~:compiler-options",["^2R",[["^5U","~:static-fns"],true,["^5U","~:shadow-tweaks"],null,["^5U","~:source-map-inline"],null,["^5U","~:elide-asserts"],false,["^5U","~:optimize-constants"],null,["^5U","^1C"],null,["^5U","~:external-config"],null,["^5U","~:tooling-config"],null,["^5U","~:emit-constants"],null,["^5U","~:load-tests"],null,["^5U","~:form-size-threshold"],null,["^5U","~:global-goog-object&array"],null,["^5U","~:data-readers"],null,["^5U","~:infer-externs"],"~:auto",["^5U","^1E"],null,["~:js-options","~:js-provider"],"~:shadow",["~:mode"],"~:dev",["^5U","~:fn-invoke-direct"],null,["^5U","~:source-map"],"/dev/null"]]]