["^ ","~:output",["^ ","~:js","goog.provide('zprint.zutil');\nzprint.zutil.whitespace_QMARK_ = (function zprint$zutil$whitespace_QMARK_(zloc){\nreturn ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(rewrite_clj.zip.tag(zloc),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483))) || (((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(rewrite_clj.zip.tag(zloc),new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(rewrite_clj.zip.tag(zloc),new cljs.core.Keyword(null,\"comma\",\"comma\",1699024745))))));\n});\nzprint.zutil.skip_whitespace = (function zprint$zutil$skip_whitespace(var_args){\nvar G__41642 = arguments.length;\nswitch (G__41642) {\ncase 1:\nreturn zprint.zutil.skip_whitespace.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn zprint.zutil.skip_whitespace.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(zprint.zutil.skip_whitespace.cljs$core$IFn$_invoke$arity$1 = (function (zloc){\nreturn zprint.zutil.skip_whitespace.cljs$core$IFn$_invoke$arity$2(rewrite_clj.zip.right,zloc);\n}));\n\n(zprint.zutil.skip_whitespace.cljs$core$IFn$_invoke$arity$2 = (function (f,zloc){\nreturn rewrite_clj.zip.skip(f,zprint.zutil.whitespace_QMARK_,zloc);\n}));\n\n(zprint.zutil.skip_whitespace.cljs$lang$maxFixedArity = 2);\n\nzprint.zutil.whitespace_not_newline_QMARK_ = (function zprint$zutil$whitespace_not_newline_QMARK_(zloc){\nreturn ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(rewrite_clj.zip.tag(zloc),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(rewrite_clj.zip.tag(zloc),new cljs.core.Keyword(null,\"comma\",\"comma\",1699024745))));\n});\nzprint.zutil.zremove = rewrite_clj.zip.remove;\nzprint.zutil.zreplace = rewrite_clj.zip.replace;\n/**\n * Is the zipper zloc equivalent to the path floc.  In this\n *   case, floc isn't a zipper, but was turned into a path early on.\n */\nzprint.zutil.zfocus = (function zprint$zutil$zfocus(zloc,floc){\nvar vec__41648 = (zprint.zutil.find_root_and_path.cljs$core$IFn$_invoke$arity$1 ? zprint.zutil.find_root_and_path.cljs$core$IFn$_invoke$arity$1(zloc) : zprint.zutil.find_root_and_path.call(null,zloc));\nvar _ = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41648,(0),null);\nvar zpath = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__41648,(1),null);\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(zpath,floc);\n});\n/**\n * Take the various inputs and come up with a style.\n */\nzprint.zutil.zfocus_style = (function zprint$zutil$zfocus_style(style,zloc,floc){\nvar style__$1 = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(style,new cljs.core.Keyword(null,\"f\",\"f\",-1597136552)))?style:((zprint.zutil.zfocus(zloc,floc))?new cljs.core.Keyword(null,\"f\",\"f\",-1597136552):new cljs.core.Keyword(null,\"b\",\"b\",1482224470)));\nreturn style__$1;\n});\n/**\n * Is the zloc a collection?\n */\nzprint.zutil.z_coll_QMARK_ = (function zprint$zutil$z_coll_QMARK_(zloc){\nreturn rewrite_clj.zip.seq_QMARK_(zloc);\n});\n/**\n * Is this a #_(...)\n */\nzprint.zutil.zuneval_QMARK_ = (function zprint$zutil$zuneval_QMARK_(zloc){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(rewrite_clj.zip.tag(zloc),new cljs.core.Keyword(null,\"uneval\",\"uneval\",1932037707));\n});\n/**\n * Is this a ^{...}\n */\nzprint.zutil.zmeta_QMARK_ = (function zprint$zutil$zmeta_QMARK_(zloc){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(rewrite_clj.zip.tag(zloc),new cljs.core.Keyword(null,\"meta\",\"meta\",1499536964));\n});\n/**\n * Is this a '(...) or '[ ... ] or some other quote?\n */\nzprint.zutil.zquote_QMARK_ = (function zprint$zutil$zquote_QMARK_(zloc){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(rewrite_clj.zip.tag(zloc),new cljs.core.Keyword(null,\"quote\",\"quote\",-262615245));\n});\n/**\n * Is this a @...\n */\nzprint.zutil.zreader_macro_QMARK_ = (function zprint$zutil$zreader_macro_QMARK_(zloc){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(rewrite_clj.zip.tag(zloc),new cljs.core.Keyword(null,\"reader-macro\",\"reader-macro\",750056422));\n});\n/**\n * Return the tag for this zloc\n */\nzprint.zutil.ztag = (function zprint$zutil$ztag(zloc){\nreturn rewrite_clj.zip.tag(zloc);\n});\n/**\n * Is this a namespaced map?\n */\nzprint.zutil.znamespacedmap_QMARK_ = (function zprint$zutil$znamespacedmap_QMARK_(zloc){\nvar or__5045__auto__ = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(rewrite_clj.zip.tag(zloc),new cljs.core.Keyword(null,\"namespaced-map\",\"namespaced-map\",1235665380));\nif(or__5045__auto__){\nreturn or__5045__auto__;\n} else {\nreturn cljs.core.re_find(/^#:/,rewrite_clj.zip.string(zloc));\n}\n});\n/**\n * Returns true if this is a comment.\n */\nzprint.zutil.zcomment_QMARK_ = (function zprint$zutil$zcomment_QMARK_(zloc){\nif(cljs.core.truth_(zloc)){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(rewrite_clj.zip.tag(zloc),new cljs.core.Keyword(null,\"comment\",\"comment\",532206069));\n} else {\nreturn null;\n}\n});\n/**\n * Returns true if this is a newline.\n */\nzprint.zutil.znewline_QMARK_ = (function zprint$zutil$znewline_QMARK_(zloc){\nif(cljs.core.truth_(zloc)){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(rewrite_clj.zip.tag(zloc),new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323));\n} else {\nreturn null;\n}\n});\n/**\n * Does z/string, but takes an additional argument for hex conversion.\n *   Hex conversion is not implemented for zippers, though, because at present\n *   it is only used for byte-arrays, which don't really show up here.\n */\nzprint.zutil.znumstr = (function zprint$zutil$znumstr(zloc,_,___$1){\nreturn rewrite_clj.zip.string(zloc);\n});\n/**\n * Find the zloc inside of this zloc.\n */\nzprint.zutil.zstart = (function zprint$zutil$zstart(zloc){\nreturn rewrite_clj.zip.down_STAR_(zloc);\n});\n/**\n * Find the first non-whitespace zloc inside of this zloc, or\n *   the first whitespace zloc that is the focus.\n */\nzprint.zutil.zfirst = (function zprint$zutil$zfirst(zloc){\nvar nloc = rewrite_clj.zip.down_STAR_(zloc);\nif(cljs.core.truth_(nloc)){\nreturn rewrite_clj.zip.skip(rewrite_clj.zip.right_STAR_,zprint.zutil.whitespace_QMARK_,nloc);\n} else {\nreturn null;\n}\n});\n/**\n * Find the first sexpr-able? zloc inside of this zloc.\n */\nzprint.zutil.zfirst_sexpr = (function zprint$zutil$zfirst_sexpr(zloc){\nvar nloc = rewrite_clj.zip.down_STAR_(zloc);\nif(cljs.core.truth_(nloc)){\nreturn rewrite_clj.zip.skip(rewrite_clj.zip.right_STAR_,(function (p1__41692_SHARP_){\nreturn cljs.core.not((zprint.zutil.zsexpr_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zutil.zsexpr_QMARK_.cljs$core$IFn$_invoke$arity$1(p1__41692_SHARP_) : zprint.zutil.zsexpr_QMARK_.call(null,p1__41692_SHARP_)));\n}),nloc);\n} else {\nreturn null;\n}\n});\n/**\n * Find the second non-whitespace zloc inside of this zloc.\n */\nzprint.zutil.zsecond = (function zprint$zutil$zsecond(zloc){\nvar temp__5802__auto__ = zprint.zutil.zfirst(zloc);\nif(cljs.core.truth_(temp__5802__auto__)){\nvar first_loc = temp__5802__auto__;\nvar temp__5802__auto____$1 = rewrite_clj.zip.right_STAR_(first_loc);\nif(cljs.core.truth_(temp__5802__auto____$1)){\nvar nloc = temp__5802__auto____$1;\nreturn rewrite_clj.zip.skip(rewrite_clj.zip.right_STAR_,zprint.zutil.whitespace_QMARK_,nloc);\n} else {\nreturn null;\n}\n} else {\nreturn null;\n}\n});\n/**\n * Find the third non-whitespace zloc inside of this zloc.\n */\nzprint.zutil.zthird = (function zprint$zutil$zthird(zloc){\nvar G__41711 = zprint.zutil.zfirst(zloc);\nvar G__41711__$1 = (((G__41711 == null))?null:rewrite_clj.zip.right_STAR_(G__41711));\nvar G__41711__$2 = (((G__41711__$1 == null))?null:rewrite_clj.zip.skip(rewrite_clj.zip.right_STAR_,zprint.zutil.whitespace_QMARK_,G__41711__$1));\nvar G__41711__$3 = (((G__41711__$2 == null))?null:rewrite_clj.zip.right_STAR_(G__41711__$2));\nif((G__41711__$3 == null)){\nreturn null;\n} else {\nreturn rewrite_clj.zip.skip(rewrite_clj.zip.right_STAR_,zprint.zutil.whitespace_QMARK_,G__41711__$3);\n}\n});\n/**\n * Find the fourth non-whitespace zloc inside of this zloc.\n */\nzprint.zutil.zfourth = (function zprint$zutil$zfourth(zloc){\nvar G__41717 = zprint.zutil.zfirst(zloc);\nvar G__41717__$1 = (((G__41717 == null))?null:rewrite_clj.zip.right_STAR_(G__41717));\nvar G__41717__$2 = (((G__41717__$1 == null))?null:rewrite_clj.zip.skip(rewrite_clj.zip.right_STAR_,zprint.zutil.whitespace_QMARK_,G__41717__$1));\nvar G__41717__$3 = (((G__41717__$2 == null))?null:rewrite_clj.zip.right_STAR_(G__41717__$2));\nvar G__41717__$4 = (((G__41717__$3 == null))?null:rewrite_clj.zip.skip(rewrite_clj.zip.right_STAR_,zprint.zutil.whitespace_QMARK_,G__41717__$3));\nvar G__41717__$5 = (((G__41717__$4 == null))?null:rewrite_clj.zip.right_STAR_(G__41717__$4));\nif((G__41717__$5 == null)){\nreturn null;\n} else {\nreturn rewrite_clj.zip.skip(rewrite_clj.zip.right_STAR_,zprint.zutil.whitespace_QMARK_,G__41717__$5);\n}\n});\n/**\n * Find the next non-whitespace zloc inside of this zloc. Returns nil\n *   if nothing left.\n */\nzprint.zutil.zrightnws = (function zprint$zutil$zrightnws(zloc){\nif(cljs.core.truth_(zloc)){\nvar temp__5802__auto__ = rewrite_clj.zip.right_STAR_(zloc);\nif(cljs.core.truth_(temp__5802__auto__)){\nvar nloc = temp__5802__auto__;\nreturn rewrite_clj.zip.skip(rewrite_clj.zip.right_STAR_,zprint.zutil.whitespace_QMARK_,nloc);\n} else {\nreturn null;\n}\n} else {\nreturn null;\n}\n});\n/**\n * Find the next non-whitespace zloc inside of this zloc considering \n *   newlines to not be whitespace. Returns nil if nothing left. Which is\n *   why this is nextnws and not rightnws, since it is exposed in zfns.\n */\nzprint.zutil.znextnws_w_nl = (function zprint$zutil$znextnws_w_nl(zloc){\nif(cljs.core.truth_(zloc)){\nvar temp__5802__auto__ = rewrite_clj.zip.right_STAR_(zloc);\nif(cljs.core.truth_(temp__5802__auto__)){\nvar nloc = temp__5802__auto__;\nreturn rewrite_clj.zip.skip(rewrite_clj.zip.right_STAR_,zprint.zutil.whitespace_not_newline_QMARK_,nloc);\n} else {\nreturn null;\n}\n} else {\nreturn null;\n}\n});\n/**\n * Find the rightmost non-whitespace zloc at this level\n */\nzprint.zutil.zrightmost = (function zprint$zutil$zrightmost(zloc){\nvar nloc = zprint.zutil.zrightnws(zloc);\nvar ploc = zloc;\nwhile(true){\nif(cljs.core.not(nloc)){\nreturn ploc;\n} else {\nvar G__42356 = zprint.zutil.zrightnws(nloc);\nvar G__42357 = nloc;\nnloc = G__42356;\nploc = G__42357;\ncontinue;\n}\nbreak;\n}\n});\n/**\n * Find the next non-whitespace zloc inside of this zloc.\n */\nzprint.zutil.zleftnws = (function zprint$zutil$zleftnws(zloc){\nif(cljs.core.truth_(zloc)){\nvar temp__5802__auto__ = rewrite_clj.zip.left_STAR_(zloc);\nif(cljs.core.truth_(temp__5802__auto__)){\nvar nloc = temp__5802__auto__;\nreturn rewrite_clj.zip.skip(rewrite_clj.zip.left_STAR_,zprint.zutil.whitespace_QMARK_,nloc);\n} else {\nreturn null;\n}\n} else {\nreturn null;\n}\n});\n/**\n * Find the leftmost non-whitespace zloc at this level\n */\nzprint.zutil.zleftmost = (function zprint$zutil$zleftmost(zloc){\nvar nloc = zprint.zutil.zleftnws(zloc);\nvar ploc = zloc;\nwhile(true){\nif(cljs.core.not(nloc)){\nreturn ploc;\n} else {\nvar G__42362 = zprint.zutil.zleftnws(nloc);\nvar G__42363 = nloc;\nnloc = G__42362;\nploc = G__42363;\ncontinue;\n}\nbreak;\n}\n});\n/**\n * Find the next non-whitespace zloc.\n */\nzprint.zutil.zprevnws = (function zprint$zutil$zprevnws(zloc){\nvar temp__5802__auto__ = rewrite_clj.zip.prev_STAR_(zloc);\nif(cljs.core.truth_(temp__5802__auto__)){\nvar ploc = temp__5802__auto__;\nreturn rewrite_clj.zip.skip(rewrite_clj.zip.prev_STAR_,zprint.zutil.whitespace_QMARK_,ploc);\n} else {\nreturn null;\n}\n});\n/**\n * Find the nth non-whitespace zloc inside of this zloc.\n */\nzprint.zutil.znthnext = (function zprint$zutil$znthnext(zloc,n){\nvar nloc = zprint.zutil.skip_whitespace.cljs$core$IFn$_invoke$arity$1(rewrite_clj.zip.down_STAR_(zloc));\nvar i = n;\nwhile(true){\nif((((nloc == null)) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(i,(0))))){\nreturn nloc;\n} else {\nvar G__42367 = zprint.zutil.zrightnws(nloc);\nvar G__42368 = (i - (1));\nnloc = G__42367;\ni = G__42368;\ncontinue;\n}\nbreak;\n}\n});\n/**\n * Find the locations (counting from zero, and only counting non-whitespace\n *   elements) of the first zthing?.  Return its index if it is found, nil if not.\n */\nzprint.zutil.zfind = (function zprint$zutil$zfind(zthing_QMARK_,zloc){\nvar nloc = zprint.zutil.skip_whitespace.cljs$core$IFn$_invoke$arity$1(rewrite_clj.zip.down_STAR_(zloc));\nvar i = (0);\nwhile(true){\nif((!((nloc == null)))){\nif(cljs.core.truth_((zthing_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zthing_QMARK_.cljs$core$IFn$_invoke$arity$1(nloc) : zthing_QMARK_.call(null,nloc)))){\nreturn i;\n} else {\nvar G__42369 = zprint.zutil.zrightnws(nloc);\nvar G__42370 = (i + (1));\nnloc = G__42369;\ni = G__42370;\ncontinue;\n}\n} else {\nreturn null;\n}\nbreak;\n}\n});\nzprint.zutil.znl = (function zprint$zutil$znl(){\n\nreturn rewrite_clj.zip.edn_STAR_.cljs$core$IFn$_invoke$arity$1(rewrite_clj.parser.parse_string(\"\\n\"));\n});\n/**\n * Return a sequence of zloc newlines.\n */\nzprint.zutil.multi_nl = (function zprint$zutil$multi_nl(n){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.vector,cljs.core.repeat.cljs$core$IFn$_invoke$arity$2(n,zprint.zutil.znl()));\n});\n/**\n * Given a zloc which is a comment, replace it with a zloc which is the\n *   same comment with no newline, and a newline that follows it.  This is\n *   done in the zipper so that later navigation in this area remains\n *   continues to work.\n */\nzprint.zutil.split_newline_from_comment = (function zprint$zutil$split_newline_from_comment(zloc){\nvar comment_no_nl = rewrite_clj.parser.parse_string(clojure.string.replace_first(rewrite_clj.zip.string(zloc),\"\\n\",\"\"));\nvar new_comment = rewrite_clj.zip.replace_STAR_(zloc,comment_no_nl);\nvar new_comment__$1 = rewrite_clj.zip.insert_right_STAR_(new_comment,rewrite_clj.parser.parse_string(\"\\n\"));\nreturn new_comment__$1;\n});\n/**\n * Return a vector containing the return of applying a function to\n *   every non-whitespace zloc inside of zloc, including two newlines\n *   for every blank line encountered.  Note that a truly blank line\n *   will show up as one zloc with two newlines in it.  It will have\n *   (= (z/tag nloc) :newline), but it will have both newlines.  To\n *   ease handling of these multi-line newlines, this routine will\n *   split them up into multiple individual newlines.\n */\nzprint.zutil.zmap_w_bl = (function zprint$zutil$zmap_w_bl(zfn,zloc){\nvar nloc = rewrite_clj.zip.down_STAR_(zloc);\nvar blank_QMARK_ = false;\nvar previous_was_nl_QMARK_ = false;\nvar previous_comment_QMARK_ = null;\nvar out = cljs.core.PersistentVector.EMPTY;\nwhile(true){\nif(cljs.core.not(nloc)){\nreturn out;\n} else {\nvar ws_QMARK_ = zprint.zutil.whitespace_QMARK_(nloc);\nvar nl_QMARK_ = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(rewrite_clj.zip.tag(nloc),new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323));\nvar nl_len = ((nl_QMARK_)?rewrite_clj.zip.length(nloc):null);\nvar multi_nl_QMARK_ = ((nl_QMARK_)?(rewrite_clj.zip.length(nloc) > (1)):null);\nvar emit_nl_QMARK_ = (function (){var or__5045__auto__ = ((blank_QMARK_) && (nl_QMARK_));\nif(or__5045__auto__){\nreturn or__5045__auto__;\n} else {\nreturn multi_nl_QMARK_;\n}\n})();\nvar nl_to_emit = (cljs.core.truth_(emit_nl_QMARK_)?(cljs.core.truth_(multi_nl_QMARK_)?cljs.core.mapv.cljs$core$IFn$_invoke$arity$2(zfn,zprint.zutil.multi_nl((((function (){var or__5045__auto__ = previous_was_nl_QMARK_;\nif(cljs.core.truth_(or__5045__auto__)){\nreturn or__5045__auto__;\n} else {\nreturn (!(blank_QMARK_));\n}\n})())?nl_len:(nl_len + (1))))):(cljs.core.truth_(previous_was_nl_QMARK_)?new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [(zfn.cljs$core$IFn$_invoke$arity$1 ? zfn.cljs$core$IFn$_invoke$arity$1(nloc) : zfn.call(null,nloc))], null):new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [(zfn.cljs$core$IFn$_invoke$arity$1 ? zfn.cljs$core$IFn$_invoke$arity$1(nloc) : zfn.call(null,nloc)),(zfn.cljs$core$IFn$_invoke$arity$1 ? zfn.cljs$core$IFn$_invoke$arity$1(nloc) : zfn.call(null,nloc))], null)\n)):null);\nvar comment_QMARK_ = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(rewrite_clj.zip.tag(nloc),new cljs.core.Keyword(null,\"comment\",\"comment\",532206069));\nvar nloc__$1 = ((comment_QMARK_)?zprint.zutil.split_newline_from_comment(nloc):nloc);\nvar result = (cljs.core.truth_((function (){var or__5045__auto__ = (!(ws_QMARK_));\nif(or__5045__auto__){\nreturn or__5045__auto__;\n} else {\nvar and__5043__auto__ = nl_QMARK_;\nif(and__5043__auto__){\nreturn previous_comment_QMARK_;\n} else {\nreturn and__5043__auto__;\n}\n}\n})())?(zfn.cljs$core$IFn$_invoke$arity$1 ? zfn.cljs$core$IFn$_invoke$arity$1(nloc__$1) : zfn.call(null,nloc__$1)):null);\nvar G__42372 = rewrite_clj.zip.right_STAR_(nloc__$1);\nvar G__42373 = ((blank_QMARK_)?((ws_QMARK_) || (nl_QMARK_)):nl_QMARK_);\nvar G__42374 = (cljs.core.truth_((function (){var or__5045__auto__ = result;\nif(cljs.core.truth_(or__5045__auto__)){\nreturn or__5045__auto__;\n} else {\nreturn nl_to_emit;\n}\n})())?(function (){var or__5045__auto__ = (function (){var and__5043__auto__ = nl_QMARK_;\nif(and__5043__auto__){\nreturn previous_comment_QMARK_;\n} else {\nreturn and__5043__auto__;\n}\n})();\nif(cljs.core.truth_(or__5045__auto__)){\nreturn or__5045__auto__;\n} else {\nreturn emit_nl_QMARK_;\n}\n})():previous_was_nl_QMARK_);\nvar G__42375 = comment_QMARK_;\nvar G__42376 = (cljs.core.truth_(result)?cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,result):(cljs.core.truth_(nl_to_emit)?cljs.core.apply.cljs$core$IFn$_invoke$arity$3(cljs.core.conj,out,nl_to_emit):out\n));\nnloc = G__42372;\nblank_QMARK_ = G__42373;\nprevious_was_nl_QMARK_ = G__42374;\nprevious_comment_QMARK_ = G__42375;\nout = G__42376;\ncontinue;\n}\nbreak;\n}\n});\n/**\n * Return a vector containing the return of applying a function to\n *   every non-whitespace zloc inside of zloc, including newlines.\n *   This will also split newlines into separate zlocs if they were\n *   multiple, and split the newline off the end of a comment. The\n *   comment split actually changes the zipper for the rest of the\n *   sequence, where the newline splits do not.\n */\nzprint.zutil.zmap_w_nl = (function zprint$zutil$zmap_w_nl(zfn,zloc){\nvar nloc = rewrite_clj.zip.down_STAR_(zloc);\nvar out = cljs.core.PersistentVector.EMPTY;\nwhile(true){\nif(cljs.core.not(nloc)){\nreturn out;\n} else {\nvar nl_QMARK_ = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(rewrite_clj.zip.tag(nloc),new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323));\nvar comment_QMARK_ = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(rewrite_clj.zip.tag(nloc),new cljs.core.Keyword(null,\"comment\",\"comment\",532206069));\nvar nloc__$1 = ((comment_QMARK_)?zprint.zutil.split_newline_from_comment(nloc):nloc);\nvar result = (((!(zprint.zutil.whitespace_QMARK_(nloc__$1))))?(zfn.cljs$core$IFn$_invoke$arity$1 ? zfn.cljs$core$IFn$_invoke$arity$1(nloc__$1) : zfn.call(null,nloc__$1)):null);\nvar nl_len = ((nl_QMARK_)?rewrite_clj.zip.length(nloc__$1):null);\nvar multi_nl_QMARK_ = ((nl_QMARK_)?(rewrite_clj.zip.length(nloc__$1) > (1)):null);\nvar nl_to_emit = ((nl_QMARK_)?(cljs.core.truth_(multi_nl_QMARK_)?cljs.core.mapv.cljs$core$IFn$_invoke$arity$2(zfn,zprint.zutil.multi_nl(nl_len)):new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [(zfn.cljs$core$IFn$_invoke$arity$1 ? zfn.cljs$core$IFn$_invoke$arity$1(nloc__$1) : zfn.call(null,nloc__$1))], null)):null);\nvar G__42377 = rewrite_clj.zip.right_STAR_(nloc__$1);\nvar G__42378 = (cljs.core.truth_(result)?cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,result):(cljs.core.truth_(nl_to_emit)?cljs.core.apply.cljs$core$IFn$_invoke$arity$3(cljs.core.conj,out,nl_to_emit):out\n));\nnloc = G__42377;\nout = G__42378;\ncontinue;\n}\nbreak;\n}\n});\n/**\n * Return a vector containing the return of applying a function to\n *   every non-whitespace zloc inside of zloc, including newlines and commas.\n *   This will also split newlines into separate zlocs if they were\n *   multiple, and split the newline off the end of a comment.\n */\nzprint.zutil.zmap_w_nl_comma = (function zprint$zutil$zmap_w_nl_comma(zfn,zloc){\nvar nloc = rewrite_clj.zip.down_STAR_(zloc);\nvar out = cljs.core.PersistentVector.EMPTY;\nwhile(true){\nif(cljs.core.not(nloc)){\nreturn out;\n} else {\nvar nl_QMARK_ = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(rewrite_clj.zip.tag(nloc),new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323));\nvar comma_QMARK_ = ((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(rewrite_clj.zip.tag(nloc),new cljs.core.Keyword(null,\"comma\",\"comma\",1699024745))) || (((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(rewrite_clj.zip.tag(nloc),new cljs.core.Keyword(null,\"whitespace\",\"whitespace\",-1340035483))) && (clojure.string.includes_QMARK_(rewrite_clj.zip.string(nloc),\",\")))));\nvar comment_QMARK_ = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(rewrite_clj.zip.tag(nloc),new cljs.core.Keyword(null,\"comment\",\"comment\",532206069));\nvar nloc__$1 = ((comment_QMARK_)?zprint.zutil.split_newline_from_comment(nloc):nloc);\nvar result = (((((!(zprint.zutil.whitespace_QMARK_(nloc__$1)))) || (comma_QMARK_)))?(zfn.cljs$core$IFn$_invoke$arity$1 ? zfn.cljs$core$IFn$_invoke$arity$1(nloc__$1) : zfn.call(null,nloc__$1)):null);\nvar nl_len = ((nl_QMARK_)?rewrite_clj.zip.length(nloc__$1):null);\nvar multi_nl_QMARK_ = ((nl_QMARK_)?(rewrite_clj.zip.length(nloc__$1) > (1)):null);\nvar nl_to_emit = ((nl_QMARK_)?(cljs.core.truth_(multi_nl_QMARK_)?cljs.core.mapv.cljs$core$IFn$_invoke$arity$2(zfn,zprint.zutil.multi_nl(nl_len)):new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [(zfn.cljs$core$IFn$_invoke$arity$1 ? zfn.cljs$core$IFn$_invoke$arity$1(nloc__$1) : zfn.call(null,nloc__$1))], null)):null);\nvar G__42379 = rewrite_clj.zip.right_STAR_(nloc__$1);\nvar G__42380 = (cljs.core.truth_(result)?cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,result):(cljs.core.truth_(nl_to_emit)?cljs.core.apply.cljs$core$IFn$_invoke$arity$3(cljs.core.conj,out,nl_to_emit):out\n));\nnloc = G__42379;\nout = G__42380;\ncontinue;\n}\nbreak;\n}\n});\n/**\n * Return a vector containing the return of applying a function to \n *   every non-whitespace zloc inside of zloc. The newline that shows\n *   up in every comment is also split out into a separate zloc.\n */\nzprint.zutil.zmap = (function zprint$zutil$zmap(zfn,zloc){\nvar nloc = rewrite_clj.zip.down_STAR_(zloc);\nvar previous_comment_QMARK_ = null;\nvar out = cljs.core.PersistentVector.EMPTY;\nwhile(true){\nif(cljs.core.not(nloc)){\nreturn out;\n} else {\nvar comment_QMARK_ = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(rewrite_clj.zip.tag(nloc),new cljs.core.Keyword(null,\"comment\",\"comment\",532206069));\nvar nl_QMARK_ = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(rewrite_clj.zip.tag(nloc),new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323));\nvar nloc__$1 = ((comment_QMARK_)?zprint.zutil.split_newline_from_comment(nloc):nloc);\nvar result = (cljs.core.truth_((function (){var or__5045__auto__ = (!(zprint.zutil.whitespace_QMARK_(nloc__$1)));\nif(or__5045__auto__){\nreturn or__5045__auto__;\n} else {\nvar and__5043__auto__ = nl_QMARK_;\nif(and__5043__auto__){\nreturn previous_comment_QMARK_;\n} else {\nreturn and__5043__auto__;\n}\n}\n})())?(zfn.cljs$core$IFn$_invoke$arity$1 ? zfn.cljs$core$IFn$_invoke$arity$1(nloc__$1) : zfn.call(null,nloc__$1)):null);\nvar G__42382 = rewrite_clj.zip.right_STAR_(nloc__$1);\nvar G__42383 = comment_QMARK_;\nvar G__42384 = (cljs.core.truth_(result)?cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,result):out);\nnloc = G__42382;\nprevious_comment_QMARK_ = G__42383;\nout = G__42384;\ncontinue;\n}\nbreak;\n}\n});\n/**\n * Return a vector containing the return of applying a function to \n *   every non-whitespace zloc inside of zloc. Comments are considered\n *   whitespace for this routine, and left out.\n */\nzprint.zutil.zmap_no_comment = (function zprint$zutil$zmap_no_comment(zfn,zloc){\nvar nloc = rewrite_clj.zip.down_STAR_(zloc);\nvar previous_comment_QMARK_ = null;\nvar out = cljs.core.PersistentVector.EMPTY;\nwhile(true){\nif(cljs.core.not(nloc)){\nreturn out;\n} else {\nvar comment_QMARK_ = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(rewrite_clj.zip.tag(nloc),new cljs.core.Keyword(null,\"comment\",\"comment\",532206069));\nvar nl_QMARK_ = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(rewrite_clj.zip.tag(nloc),new cljs.core.Keyword(null,\"newline\",\"newline\",1790071323));\nvar result = (((!(((zprint.zutil.whitespace_QMARK_(nloc)) || (((comment_QMARK_) || (nl_QMARK_)))))))?(zfn.cljs$core$IFn$_invoke$arity$1 ? zfn.cljs$core$IFn$_invoke$arity$1(nloc) : zfn.call(null,nloc)):null);\nvar G__42387 = rewrite_clj.zip.right_STAR_(nloc);\nvar G__42388 = comment_QMARK_;\nvar G__42389 = (cljs.core.truth_(result)?cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,result):out);\nnloc = G__42387;\nprevious_comment_QMARK_ = G__42388;\nout = G__42389;\ncontinue;\n}\nbreak;\n}\n});\n/**\n * Return the count of non-whitespace elements in zloc.  Comments are\n *   counted as one thing, commas are ignored as whitespace.\n */\nzprint.zutil.zcount = (function zprint$zutil$zcount(zloc){\nvar nloc = rewrite_clj.zip.down_STAR_(zloc);\nvar i = (0);\nwhile(true){\nif(cljs.core.not(nloc)){\nreturn i;\n} else {\nvar G__42393 = rewrite_clj.zip.right_STAR_(nloc);\nvar G__42394 = (((!(zprint.zutil.whitespace_QMARK_(nloc))))?(i + (1)):i);\nnloc = G__42393;\ni = G__42394;\ncontinue;\n}\nbreak;\n}\n});\n/**\n * Return a vector containing the return of applying a function to \n *   every zloc inside of zloc.\n */\nzprint.zutil.zmap_all = (function zprint$zutil$zmap_all(zfn,zloc){\nvar nloc = rewrite_clj.zip.down_STAR_(zloc);\nvar out = cljs.core.PersistentVector.EMPTY;\nwhile(true){\nif(cljs.core.not(nloc)){\nreturn out;\n} else {\nvar G__42395 = rewrite_clj.zip.right_STAR_(nloc);\nvar G__42396 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,(zfn.cljs$core$IFn$_invoke$arity$1 ? zfn.cljs$core$IFn$_invoke$arity$1(nloc) : zfn.call(null,nloc)));\nnloc = G__42395;\nout = G__42396;\ncontinue;\n}\nbreak;\n}\n});\n/**\n * Return a seq of all of the non-whitespace children of zloc.\n */\nzprint.zutil.zseqnws = (function zprint$zutil$zseqnws(zloc){\nreturn zprint.zutil.zmap(cljs.core.identity,zloc);\n});\n/**\n * Return a seq of all of the non-whitespace children of zloc, including\n *   newlines.\n */\nzprint.zutil.zseqnws_w_nl = (function zprint$zutil$zseqnws_w_nl(zloc){\nreturn zprint.zutil.zmap_w_nl(cljs.core.identity,zloc);\n});\n/**\n * Return a seq of all of the non-whitespace children of zloc, including\n *   only newlines that start and end blank lines.\n */\nzprint.zutil.zseqnws_w_bl = (function zprint$zutil$zseqnws_w_bl(zloc){\nreturn zprint.zutil.zmap_w_bl(cljs.core.identity,zloc);\n});\n/**\n * Remove everything to the right of the current zloc. In other words,\n *   make the current zloc the rightmost.\n */\nzprint.zutil.zremove_right = (function zprint$zutil$zremove_right(zloc){\nvar nloc = zloc;\nwhile(true){\nif(rewrite_clj.zip.rightmost_QMARK_(nloc)){\nreturn nloc;\n} else {\nvar G__42399 = (function (){var G__41917 = rewrite_clj.zip.right_STAR_(nloc);\nreturn (zprint.zutil.zremove.cljs$core$IFn$_invoke$arity$1 ? zprint.zutil.zremove.cljs$core$IFn$_invoke$arity$1(G__41917) : zprint.zutil.zremove.call(null,G__41917));\n})();\nnloc = G__42399;\ncontinue;\n}\nbreak;\n}\n});\n/**\n * Considering the current zloc a collection, move down into it and\n *   take n non-whitespace elements, dropping the rest.  Then append the\n *   given element to the end, coercing it into a node/zloc.  Note, this \n *   is not quite implemented that way, as it uses replace.\n */\nzprint.zutil.ztake_append = (function zprint$zutil$ztake_append(n,zloc,end_struct){\nvar nloc = rewrite_clj.zip.down_STAR_(zloc);\nvar index = (0);\nwhile(true){\nif((index >= n)){\nreturn rewrite_clj.zip.up_STAR_(zprint.zutil.zremove_right((zprint.zutil.zreplace.cljs$core$IFn$_invoke$arity$2 ? zprint.zutil.zreplace.cljs$core$IFn$_invoke$arity$2(nloc,end_struct) : zprint.zutil.zreplace.call(null,nloc,end_struct))));\n} else {\nvar xloc = rewrite_clj.zip.right_STAR_(nloc);\nvar G__42400 = xloc;\nvar G__42401 = ((zprint.zutil.whitespace_QMARK_(xloc))?index:(index + (1)));\nnloc = G__42400;\nindex = G__42401;\ncontinue;\n}\nbreak;\n}\n});\n/**\n * How many non-whitespace non-comment children are in zloc-seq? Note\n *   that this is fundamentally different from zcount, in that it doesn't\n *   take a zloc, but rather a zloc-seq (i.e., a seq of elements, each of\n *   which is a zloc).\n */\nzprint.zutil.zcount_zloc_seq_nc_nws = (function zprint$zutil$zcount_zloc_seq_nc_nws(zloc_seq){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (p1__41936_SHARP_,p2__41930_SHARP_){\nif(cljs.core.truth_(rewrite_clj.zip.whitespace_or_comment_QMARK_(p2__41930_SHARP_))){\nreturn p1__41936_SHARP_;\n} else {\nreturn (p1__41936_SHARP_ + (1));\n}\n}),(0),zloc_seq);\n});\n/**\n * Create a vector with the root as well as another vector\n *   which contains the number of right moves after each down\n *   down to find a particular zloc.  The right moves include\n *   both whitespace and comments.\n */\nzprint.zutil.find_root_and_path = (function zprint$zutil$find_root_and_path(zloc){\nif(cljs.core.truth_(zloc)){\nvar nloc = zloc;\nvar left = (0);\nvar out = cljs.core.List.EMPTY;\nwhile(true){\nif(cljs.core.not(rewrite_clj.zip.left_STAR_(nloc))){\nif(cljs.core.not(rewrite_clj.zip.up_STAR_(nloc))){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [nloc,out], null);\n} else {\nvar G__42405 = rewrite_clj.zip.up_STAR_(nloc);\nvar G__42406 = (0);\nvar G__42407 = cljs.core.cons(left,out);\nnloc = G__42405;\nleft = G__42406;\nout = G__42407;\ncontinue;\n}\n} else {\nvar G__42415 = rewrite_clj.zip.left_STAR_(nloc);\nvar G__42416 = (left + (1));\nvar G__42417 = out;\nnloc = G__42415;\nleft = G__42416;\nout = G__42417;\ncontinue;\n}\nbreak;\n}\n} else {\nreturn null;\n}\n});\n/**\n * Create a vector with the root as well as another vector\n *   which contains the number of right moves after each down\n *   down to find a particular zloc.  The right moves are\n *   non-whitespace, but include comments.\n */\nzprint.zutil.find_root_and_path_nw = (function zprint$zutil$find_root_and_path_nw(zloc){\nif(cljs.core.truth_(zloc)){\nvar nloc = zloc;\nvar left = (0);\nvar out = cljs.core.List.EMPTY;\nwhile(true){\nif(cljs.core.not(rewrite_clj.zip.left_STAR_(nloc))){\nif(cljs.core.not(rewrite_clj.zip.up_STAR_(nloc))){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [nloc,out], null);\n} else {\nvar G__42418 = rewrite_clj.zip.up_STAR_(nloc);\nvar G__42419 = (0);\nvar G__42420 = cljs.core.cons(left,out);\nnloc = G__42418;\nleft = G__42419;\nout = G__42420;\ncontinue;\n}\n} else {\nvar G__42421 = rewrite_clj.zip.left_STAR_(nloc);\nvar G__42422 = ((zprint.zutil.whitespace_QMARK_(nloc))?left:(left + (1)));\nvar G__42423 = out;\nnloc = G__42421;\nleft = G__42422;\nout = G__42423;\ncontinue;\n}\nbreak;\n}\n} else {\nreturn null;\n}\n});\n/**\n * Find the root from a zloc by doing lots of ups.\n */\nzprint.zutil.find_root = (function zprint$zutil$find_root(zloc){\nvar nloc = zloc;\nwhile(true){\nif(cljs.core.not(rewrite_clj.zip.up(nloc))){\nreturn nloc;\n} else {\nvar G__42424 = rewrite_clj.zip.up(nloc);\nnloc = G__42424;\ncontinue;\n}\nbreak;\n}\n});\n/**\n * Move one down and then right a certain number of steps.\n */\nzprint.zutil.move_down_and_right = (function zprint$zutil$move_down_and_right(zloc,right_count){\nvar nloc = rewrite_clj.zip.down_STAR_(zloc);\nvar remaining_right = right_count;\nwhile(true){\nif((remaining_right === (0))){\nreturn nloc;\n} else {\nvar G__42432 = rewrite_clj.zip.right_STAR_(nloc);\nvar G__42433 = (remaining_right - (1));\nnloc = G__42432;\nremaining_right = G__42433;\ncontinue;\n}\nbreak;\n}\n});\n/**\n * Follow the path vector from the root and return the zloc\n *   at this location.\n */\nzprint.zutil.follow_path = (function zprint$zutil$follow_path(path_vec,zloc){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(zprint.zutil.move_down_and_right,zloc,path_vec);\n});\n/**\n * Is this an anonymous fn?\n */\nzprint.zutil.zanonfn_QMARK_ = (function zprint$zutil$zanonfn_QMARK_(zloc){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(rewrite_clj.zip.tag(zloc),new cljs.core.Keyword(null,\"fn\",\"fn\",-1175266204));\n});\n/**\n * Return the last non-whitespace (but possibly comment) element inside\n *   of this zloc.\n */\nzprint.zutil.zlast = (function zprint$zutil$zlast(zloc){\nvar nloc = rewrite_clj.zip.down_STAR_(zloc);\nif(cljs.core.truth_(nloc)){\nreturn zprint.zutil.zrightmost(nloc);\n} else {\nreturn null;\n}\n});\n/**\n * Returns true if this can be converted to an sexpr. Works around a bug\n *   where n/printable-only? returns false for n/tag :fn, but z/sexpr fails\n *   on something with n/tag :fn\n */\nzprint.zutil.zsexpr_QMARK_ = (function zprint$zutil$zsexpr_QMARK_(zloc){\nvar and__5043__auto__ = zloc;\nif(cljs.core.truth_(and__5043__auto__)){\nreturn ((cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2(new cljs.core.Keyword(null,\"fn\",\"fn\",-1175266204),rewrite_clj.zip.tag(zloc))) && (cljs.core.not(rewrite_clj.node.printable_only_QMARK_(rewrite_clj.zip.node(zloc)))));\n} else {\nreturn and__5043__auto__;\n}\n});\n/**\n * Returns true if this is a keyword.\n */\nzprint.zutil.zkeyword_QMARK_ = (function zprint$zutil$zkeyword_QMARK_(zloc){\nvar and__5043__auto__ = zloc;\nif(cljs.core.truth_(and__5043__auto__)){\nreturn clojure.string.starts_with_QMARK_(rewrite_clj.zip.string(zloc),\":\");\n} else {\nreturn and__5043__auto__;\n}\n});\n/**\n * Returns true if this is a symbol.\n */\nzprint.zutil.zsymbol_QMARK_ = (function zprint$zutil$zsymbol_QMARK_(zloc){\nvar and__5043__auto__ = zloc;\nif(cljs.core.truth_(and__5043__auto__)){\nvar and__5043__auto____$1 = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(rewrite_clj.zip.tag(zloc),new cljs.core.Keyword(null,\"token\",\"token\",-1211463215));\nif(and__5043__auto____$1){\nvar and__5043__auto____$2 = zprint.zutil.zsexpr_QMARK_(zloc);\nif(cljs.core.truth_(and__5043__auto____$2)){\nreturn (rewrite_clj.zip.sexpr(zloc) instanceof cljs.core.Symbol);\n} else {\nreturn and__5043__auto____$2;\n}\n} else {\nreturn and__5043__auto____$1;\n}\n} else {\nreturn and__5043__auto__;\n}\n});\n/**\n * Returns true if this is nil.\n */\nzprint.zutil.znil_QMARK_ = (function zprint$zutil$znil_QMARK_(zloc){\nvar and__5043__auto__ = zloc;\nif(cljs.core.truth_(and__5043__auto__)){\nvar and__5043__auto____$1 = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(rewrite_clj.zip.tag(zloc),new cljs.core.Keyword(null,\"token\",\"token\",-1211463215));\nif(and__5043__auto____$1){\nvar and__5043__auto____$2 = zprint.zutil.zsexpr_QMARK_(zloc);\nif(cljs.core.truth_(and__5043__auto____$2)){\nreturn (rewrite_clj.zip.sexpr(zloc) == null);\n} else {\nreturn and__5043__auto____$2;\n}\n} else {\nreturn and__5043__auto____$1;\n}\n} else {\nreturn and__5043__auto__;\n}\n});\n/**\n * Returns true if this is a reader-conditional with a symbol in \n *   the first position (could be :clj or :cljs, whatever).\n */\nzprint.zutil.zreader_cond_w_symbol_QMARK_ = (function zprint$zutil$zreader_cond_w_symbol_QMARK_(zloc){\nvar result = ((zprint.zutil.zreader_macro_QMARK_(zloc))?(function (){var element = rewrite_clj.zip.down(zloc);\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(rewrite_clj.zip.string(element),\"?\")){\nvar element__$1 = rewrite_clj.zip.down(rewrite_clj.zip.right(element));\nif(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(rewrite_clj.zip.string(element__$1),\":clj\")) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(rewrite_clj.zip.string(element__$1),\":cljs\")))){\nreturn zprint.zutil.zsymbol_QMARK_(rewrite_clj.zip.right(element__$1));\n} else {\nreturn null;\n}\n} else {\nreturn null;\n}\n})():null);\nreturn result;\n});\n/**\n * Returns true if this is a reader-conditional with a collection in \n *   the first position (could be :clj or :cljs, whatever).\n */\nzprint.zutil.zreader_cond_w_coll_QMARK_ = (function zprint$zutil$zreader_cond_w_coll_QMARK_(zloc){\nvar result = ((zprint.zutil.zreader_macro_QMARK_(zloc))?(function (){var element = rewrite_clj.zip.down(zloc);\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(rewrite_clj.zip.string(element),\"?\")){\nvar element__$1 = rewrite_clj.zip.down(rewrite_clj.zip.right(element));\nif(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(rewrite_clj.zip.string(element__$1),\":clj\")) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(rewrite_clj.zip.string(element__$1),\":cljs\")))){\nreturn zprint.zutil.z_coll_QMARK_(rewrite_clj.zip.right(element__$1));\n} else {\nreturn null;\n}\n} else {\nreturn null;\n}\n})():null);\nreturn result;\n});\n/**\n * Return a zloc that will turn into a string of three dots.\n */\nzprint.zutil.zdotdotdot = (function zprint$zutil$zdotdotdot(){\nreturn rewrite_clj.zip.edn_STAR_.cljs$core$IFn$_invoke$arity$1(rewrite_clj.parser.parse_string(\"...\"));\n});\n/**\n * Returns true if this is a keyword, string, or number, in other words,\n *   a constant.\n */\nzprint.zutil.zconstant_QMARK_ = (function zprint$zutil$zconstant_QMARK_(zloc){\nvar ztag = rewrite_clj.zip.tag(zloc);\nif(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(ztag,new cljs.core.Keyword(null,\"unquote\",\"unquote\",1649741032))) || (((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(ztag,new cljs.core.Keyword(null,\"quote\",\"quote\",-262615245))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(ztag,new cljs.core.Keyword(null,\"syntax-quote\",\"syntax-quote\",-1233164847))))))){\nvar G__42007 = zprint.zutil.zfirst(zloc);\nreturn (zprint.zutil.zconstant_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zprint.zutil.zconstant_QMARK_.cljs$core$IFn$_invoke$arity$1(G__42007) : zprint.zutil.zconstant_QMARK_.call(null,G__42007));\n} else {\nvar and__5043__auto__ = (!(zprint.zutil.z_coll_QMARK_(zloc)));\nif(and__5043__auto__){\nvar or__5045__auto__ = zprint.zutil.zkeyword_QMARK_(zloc);\nif(cljs.core.truth_(or__5045__auto__)){\nreturn or__5045__auto__;\n} else {\nif(cljs.core.truth_((function (){var and__5043__auto____$1 = cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(rewrite_clj.zip.tag(zloc),new cljs.core.Keyword(null,\"token\",\"token\",-1211463215));\nif(and__5043__auto____$1){\nreturn zprint.zutil.zsexpr_QMARK_(zloc);\n} else {\nreturn and__5043__auto____$1;\n}\n})())){\nvar sexpr = rewrite_clj.zip.sexpr(zloc);\nreturn ((typeof sexpr === 'string') || (((typeof sexpr === 'number') || (((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(\"true\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(sexpr))) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(\"false\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(sexpr))))))));\n} else {\nreturn null;\n}\n}\n} else {\nreturn and__5043__auto__;\n}\n}\n});\n/**\n * Given a zloc zipper of a map, find the :doc element.\n */\nzprint.zutil.find_doc_in_map = (function zprint$zutil$find_doc_in_map(zloc){\nvar nloc = rewrite_clj.zip.down(zloc);\nwhile(true){\nif(cljs.core.truth_(nloc)){\nif(cljs.core.truth_((function (){var and__5043__auto__ = zprint.zutil.zkeyword_QMARK_(nloc);\nif(cljs.core.truth_(and__5043__auto__)){\nreturn cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(rewrite_clj.zip.string(nloc),\":doc\");\n} else {\nreturn and__5043__auto__;\n}\n})())){\nif(typeof rewrite_clj.zip.sexpr(rewrite_clj.zip.right(nloc)) === 'string'){\nreturn rewrite_clj.zip.right(nloc);\n} else {\nreturn null;\n}\n} else {\nvar G__42473 = rewrite_clj.zip.right(rewrite_clj.zip.right(nloc));\nnloc = G__42473;\ncontinue;\n}\n} else {\nreturn null;\n}\nbreak;\n}\n});\n/**\n * Find a docstring in a zipper of a function.\n */\nzprint.zutil.find_docstring = (function zprint$zutil$find_docstring(zloc){\nvar fn_name = rewrite_clj.zip.string(rewrite_clj.zip.down(zloc));\nif(((cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_name,\"defn\")) || (cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_name,\"defmacro\")))){\nvar docloc = rewrite_clj.zip.right(rewrite_clj.zip.right(rewrite_clj.zip.down(zloc)));\nif(typeof rewrite_clj.zip.sexpr(docloc) === 'string'){\nreturn docloc;\n} else {\nreturn null;\n}\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(fn_name,\"def\")){\nvar maploc = rewrite_clj.zip.down(rewrite_clj.zip.right(rewrite_clj.zip.down(zloc)));\nif(rewrite_clj.zip.map_QMARK_(maploc)){\nreturn zprint.zutil.find_doc_in_map(maploc);\n} else {\nreturn null;\n}\n} else {\nreturn null;\n\n}\n}\n});\n/**\n * Given a zipper of a function definition, add the spec info to\n *   the docstring. Works for docstring with (def ...) functions, but\n *   the left-indent isn't optimal.  But to fix that, we'd have to do\n *   the zprinting here, where we know the indent of the existing\n *   docstring.\n */\nzprint.zutil.add_spec_to_docstring = (function zprint$zutil$add_spec_to_docstring(zloc,spec_str){\nvar temp__5802__auto__ = zprint.zutil.find_docstring(zloc);\nif(cljs.core.truth_(temp__5802__auto__)){\nvar doc_zloc = temp__5802__auto__;\nvar new_doc_zloc = rewrite_clj.zip.replace_STAR_(doc_zloc,rewrite_clj.zip.node(rewrite_clj.zip.edn_STAR_.cljs$core$IFn$_invoke$arity$1(rewrite_clj.parser.parse_string([\"\\\"\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(rewrite_clj.zip.sexpr(doc_zloc)),cljs.core.str.cljs$core$IFn$_invoke$arity$1(spec_str),\"\\\"\"].join('')))));\nreturn rewrite_clj.zip.edn_STAR_.cljs$core$IFn$_invoke$arity$1(rewrite_clj.zip.root(new_doc_zloc));\n} else {\nreturn zloc;\n}\n});\n/**\n * Given a zloc, turn it into a keyword if it starts with a :, but remove\n *   the : first.\n */\nzprint.zutil.zloc_to_keyword = (function zprint$zutil$zloc_to_keyword(zloc){\nvar s = rewrite_clj.zip.string(zloc);\nif(clojure.string.starts_with_QMARK_(s,\":\")){\nreturn cljs.core.keyword.cljs$core$IFn$_invoke$arity$1(cljs.core.subs.cljs$core$IFn$_invoke$arity$2(s,(1)));\n} else {\nreturn cljs.core.symbol.cljs$core$IFn$_invoke$arity$1(s);\n}\n});\n/**\n * Perform a lift-ns on a pair-seq that is returned from\n *   partition-2-all-nc, which is a seq of pairs of zlocs that may or\n *   may not have been sorted and which may or may not have had things\n *   removed from it and may or may not actually be pairs.  Could be\n *   single things, could be multiple things.  If contains multiple\n *   things, the first thing is the key, but if it is just a single\n *   thing, the first thing is *not* a key. So we only need to work\n *   on the first of each seq which has more than one element in it,\n *   and possibly replace it. This will only lift out a ns if all keys\n *   in seqs with more than one element have the same namespace. Returns\n *   the [namespace pair-seq] or nil.\n */\nzprint.zutil.zlift_ns = (function zprint$zutil$zlift_ns(p__42049,pair_seq,ns){\nvar map__42050 = p__42049;\nvar map__42050__$1 = cljs.core.__destructure_map(map__42050);\nvar map_options = map__42050__$1;\nvar in_code_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__42050__$1,new cljs.core.Keyword(null,\"in-code?\",\"in-code?\",194866464));\nvar lift_ns_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__42050__$1,new cljs.core.Keyword(null,\"lift-ns?\",\"lift-ns?\",2021372853));\nvar lift_ns_in_code_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__42050__$1,new cljs.core.Keyword(null,\"lift-ns-in-code?\",\"lift-ns-in-code?\",1444279377));\nvar unlift_ns_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__42050__$1,new cljs.core.Keyword(null,\"unlift-ns?\",\"unlift-ns?\",1065087867));\nif(cljs.core.truth_((function (){var and__5043__auto__ = lift_ns_QMARK_;\nif(cljs.core.truth_(and__5043__auto__)){\nif(cljs.core.truth_(in_code_QMARK_)){\nreturn lift_ns_in_code_QMARK_;\n} else {\nreturn true;\n}\n} else {\nreturn and__5043__auto__;\n}\n})())){\nif(cljs.core.truth_(ns)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [ns,pair_seq], null);\n} else {\nvar strip_ns = (function (named){\nif((named instanceof cljs.core.Symbol)){\nreturn cljs.core.symbol.cljs$core$IFn$_invoke$arity$2(null,cljs.core.name(named));\n} else {\nreturn cljs.core.keyword.cljs$core$IFn$_invoke$arity$2(null,cljs.core.name(named));\n}\n});\nvar ns__$1 = null;\nvar pair_seq__$1 = pair_seq;\nvar out = cljs.core.PersistentVector.EMPTY;\nwhile(true){\nvar vec__42076 = cljs.core.first(pair_seq__$1);\nvar seq__42077 = cljs.core.seq(vec__42076);\nvar first__42078 = cljs.core.first(seq__42077);\nvar seq__42077__$1 = cljs.core.next(seq__42077);\nvar k = first__42078;\nvar rest_of_pair = seq__42077__$1;\nvar pair = vec__42076;\nvar current_ns = (cljs.core.truth_((function (){var and__5043__auto__ = rest_of_pair;\nif(and__5043__auto__){\nvar and__5043__auto____$1 = (!(clojure.string.starts_with_QMARK_(rewrite_clj.zip.string(k),\"::\")));\nif(and__5043__auto____$1){\nvar or__5045__auto__ = zprint.zutil.zkeyword_QMARK_(k);\nif(cljs.core.truth_(or__5045__auto__)){\nreturn or__5045__auto__;\n} else {\nreturn zprint.zutil.zsymbol_QMARK_(k);\n}\n} else {\nreturn and__5043__auto____$1;\n}\n} else {\nreturn and__5043__auto__;\n}\n})())?cljs.core.namespace(zprint.zutil.zloc_to_keyword(k)):null);\nif(cljs.core.not(k)){\nif(cljs.core.truth_(ns__$1)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [[\":\",cljs.core.str.cljs$core$IFn$_invoke$arity$1(ns__$1)].join(''),out], null);\n} else {\nreturn null;\n}\n} else {\nif(cljs.core.truth_(current_ns)){\nif(cljs.core.truth_(ns__$1)){\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(ns__$1,current_ns)){\nvar G__42476 = ns__$1;\nvar G__42477 = cljs.core.next(pair_seq__$1);\nvar G__42478 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,cljs.core.cons(rewrite_clj.zip.edn_STAR_.cljs$core$IFn$_invoke$arity$1(rewrite_clj.node.token_node.cljs$core$IFn$_invoke$arity$1(strip_ns(rewrite_clj.zip.sexpr(k)))),rest_of_pair));\nns__$1 = G__42476;\npair_seq__$1 = G__42477;\nout = G__42478;\ncontinue;\n} else {\nreturn null;\n}\n} else {\nvar G__42479 = current_ns;\nvar G__42480 = cljs.core.next(pair_seq__$1);\nvar G__42481 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,cljs.core.cons(rewrite_clj.zip.edn_STAR_.cljs$core$IFn$_invoke$arity$1(rewrite_clj.node.token_node.cljs$core$IFn$_invoke$arity$1(strip_ns(rewrite_clj.zip.sexpr(k)))),rest_of_pair));\nns__$1 = G__42479;\npair_seq__$1 = G__42480;\nout = G__42481;\ncontinue;\n}\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.count(pair),(1))){\nvar G__42482 = ns__$1;\nvar G__42483 = cljs.core.next(pair_seq__$1);\nvar G__42484 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,pair);\nns__$1 = G__42482;\npair_seq__$1 = G__42483;\nout = G__42484;\ncontinue;\n} else {\nreturn null;\n}\n}\n}\nbreak;\n}\n}\n} else {\nif(cljs.core.truth_((function (){var and__5043__auto__ = ns;\nif(cljs.core.truth_(and__5043__auto__)){\nvar and__5043__auto____$1 = unlift_ns_QMARK_;\nif(cljs.core.truth_(and__5043__auto____$1)){\nreturn cljs.core.not(lift_ns_QMARK_);\n} else {\nreturn and__5043__auto____$1;\n}\n} else {\nreturn and__5043__auto__;\n}\n})())){\nvar pair_seq__$1 = pair_seq;\nvar out = cljs.core.PersistentVector.EMPTY;\nwhile(true){\nvar vec__42122 = cljs.core.first(pair_seq__$1);\nvar seq__42123 = cljs.core.seq(vec__42122);\nvar first__42124 = cljs.core.first(seq__42123);\nvar seq__42123__$1 = cljs.core.next(seq__42123);\nvar k = first__42124;\nvar rest_of_pair = seq__42123__$1;\nvar pair = vec__42122;\nvar current_ns = (cljs.core.truth_((function (){var and__5043__auto__ = rest_of_pair;\nif(and__5043__auto__){\nvar and__5043__auto____$1 = (!(clojure.string.starts_with_QMARK_(rewrite_clj.zip.string(k),\"::\")));\nif(and__5043__auto____$1){\nvar or__5045__auto__ = zprint.zutil.zkeyword_QMARK_(k);\nif(cljs.core.truth_(or__5045__auto__)){\nreturn or__5045__auto__;\n} else {\nreturn zprint.zutil.zsymbol_QMARK_(k);\n}\n} else {\nreturn and__5043__auto____$1;\n}\n} else {\nreturn and__5043__auto__;\n}\n})())?cljs.core.namespace(zprint.zutil.zloc_to_keyword(k)):null);\nif(cljs.core.not(k)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [null,out], null);\n} else {\nif(cljs.core.truth_(current_ns)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [ns,pair_seq__$1], null);\n} else {\nif(cljs.core.not(zprint.zutil.zkeyword_QMARK_(k))){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [ns,pair_seq__$1], null);\n} else {\nif(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(cljs.core.count(pair),(1))){\nvar G__42485 = cljs.core.next(pair_seq__$1);\nvar G__42486 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,pair);\npair_seq__$1 = G__42485;\nout = G__42486;\ncontinue;\n} else {\nvar G__42487 = cljs.core.next(pair_seq__$1);\nvar G__42488 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(out,cljs.core.cons(rewrite_clj.zip.edn_STAR_.cljs$core$IFn$_invoke$arity$1(rewrite_clj.node.token_node.cljs$core$IFn$_invoke$arity$1(cljs.core.symbol.cljs$core$IFn$_invoke$arity$1([cljs.core.str.cljs$core$IFn$_invoke$arity$1(ns),\"/\",cljs.core.name(rewrite_clj.zip.sexpr(k))].join('')))),rest_of_pair));\npair_seq__$1 = G__42487;\nout = G__42488;\ncontinue;\n\n}\n}\n}\n}\nbreak;\n}\n} else {\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [ns,pair_seq], null);\n\n}\n}\n});\n/**\n * Redefine all of the traversal functions for zippers, then\n *   call the function of no arguments passed in.\n */\nzprint.zutil.zredef_call = (function zprint$zutil$zredef_call(body_fn){\nvar zstring_orig_val__42128 = zprint.zfns.zstring;\nvar znumstr_orig_val__42129 = zprint.zfns.znumstr;\nvar zbyte_array_QMARK__orig_val__42130 = zprint.zfns.zbyte_array_QMARK_;\nvar zcomment_QMARK__orig_val__42131 = zprint.zfns.zcomment_QMARK_;\nvar zsexpr_orig_val__42132 = zprint.zfns.zsexpr;\nvar zsexpr_QMARK__orig_val__42133 = zprint.zfns.zsexpr_QMARK_;\nvar zseqnws_orig_val__42134 = zprint.zfns.zseqnws;\nvar zseqnws_w_nl_orig_val__42135 = zprint.zfns.zseqnws_w_nl;\nvar zseqnws_w_bl_orig_val__42136 = zprint.zfns.zseqnws_w_bl;\nvar zfocus_style_orig_val__42137 = zprint.zfns.zfocus_style;\nvar zstart_orig_val__42138 = zprint.zfns.zstart;\nvar zfirst_orig_val__42139 = zprint.zfns.zfirst;\nvar zfirst_sexpr_orig_val__42140 = zprint.zfns.zfirst_sexpr;\nvar zsecond_orig_val__42141 = zprint.zfns.zsecond;\nvar zthird_orig_val__42142 = zprint.zfns.zthird;\nvar zfourth_orig_val__42143 = zprint.zfns.zfourth;\nvar znextnws_orig_val__42144 = zprint.zfns.znextnws;\nvar znextnws_w_nl_orig_val__42145 = zprint.zfns.znextnws_w_nl;\nvar znthnext_orig_val__42146 = zprint.zfns.znthnext;\nvar zcount_orig_val__42147 = zprint.zfns.zcount;\nvar zcount_zloc_seq_nc_nws_orig_val__42148 = zprint.zfns.zcount_zloc_seq_nc_nws;\nvar zmap_orig_val__42149 = zprint.zfns.zmap;\nvar zmap_w_nl_orig_val__42150 = zprint.zfns.zmap_w_nl;\nvar zmap_w_bl_orig_val__42151 = zprint.zfns.zmap_w_bl;\nvar zmap_w_nl_comma_orig_val__42152 = zprint.zfns.zmap_w_nl_comma;\nvar zmap_no_comment_orig_val__42153 = zprint.zfns.zmap_no_comment;\nvar zanonfn_QMARK__orig_val__42154 = zprint.zfns.zanonfn_QMARK_;\nvar zfn_obj_QMARK__orig_val__42155 = zprint.zfns.zfn_obj_QMARK_;\nvar zfocus_orig_val__42156 = zprint.zfns.zfocus;\nvar zfind_path_orig_val__42157 = zprint.zfns.zfind_path;\nvar zwhitespace_QMARK__orig_val__42158 = zprint.zfns.zwhitespace_QMARK_;\nvar zlist_QMARK__orig_val__42159 = zprint.zfns.zlist_QMARK_;\nvar zvector_QMARK__orig_val__42160 = zprint.zfns.zvector_QMARK_;\nvar zmap_QMARK__orig_val__42162 = zprint.zfns.zmap_QMARK_;\nvar znamespacedmap_QMARK__orig_val__42164 = zprint.zfns.znamespacedmap_QMARK_;\nvar zset_QMARK__orig_val__42166 = zprint.zfns.zset_QMARK_;\nvar zcoll_QMARK__orig_val__42167 = zprint.zfns.zcoll_QMARK_;\nvar zuneval_QMARK__orig_val__42168 = zprint.zfns.zuneval_QMARK_;\nvar zmeta_QMARK__orig_val__42169 = zprint.zfns.zmeta_QMARK_;\nvar ztag_orig_val__42170 = zprint.zfns.ztag;\nvar zlast_orig_val__42171 = zprint.zfns.zlast;\nvar zarray_QMARK__orig_val__42172 = zprint.zfns.zarray_QMARK_;\nvar zatom_QMARK__orig_val__42173 = zprint.zfns.zatom_QMARK_;\nvar zderef_orig_val__42174 = zprint.zfns.zderef;\nvar zrecord_QMARK__orig_val__42175 = zprint.zfns.zrecord_QMARK_;\nvar zns_QMARK__orig_val__42176 = zprint.zfns.zns_QMARK_;\nvar zobj_to_vec_orig_val__42177 = zprint.zfns.zobj_to_vec;\nvar zexpandarray_orig_val__42178 = zprint.zfns.zexpandarray;\nvar znewline_QMARK__orig_val__42179 = zprint.zfns.znewline_QMARK_;\nvar zwhitespaceorcomment_QMARK__orig_val__42180 = zprint.zfns.zwhitespaceorcomment_QMARK_;\nvar zmap_all_orig_val__42181 = zprint.zfns.zmap_all;\nvar zpromise_QMARK__orig_val__42182 = zprint.zfns.zpromise_QMARK_;\nvar zfuture_QMARK__orig_val__42183 = zprint.zfns.zfuture_QMARK_;\nvar zdelay_QMARK__orig_val__42184 = zprint.zfns.zdelay_QMARK_;\nvar zkeyword_QMARK__orig_val__42185 = zprint.zfns.zkeyword_QMARK_;\nvar zconstant_QMARK__orig_val__42186 = zprint.zfns.zconstant_QMARK_;\nvar zagent_QMARK__orig_val__42187 = zprint.zfns.zagent_QMARK_;\nvar zreader_macro_QMARK__orig_val__42188 = zprint.zfns.zreader_macro_QMARK_;\nvar zarray_to_shift_seq_orig_val__42189 = zprint.zfns.zarray_to_shift_seq;\nvar zdotdotdot_orig_val__42190 = zprint.zfns.zdotdotdot;\nvar zsymbol_QMARK__orig_val__42191 = zprint.zfns.zsymbol_QMARK_;\nvar znil_QMARK__orig_val__42192 = zprint.zfns.znil_QMARK_;\nvar zreader_cond_w_symbol_QMARK__orig_val__42193 = zprint.zfns.zreader_cond_w_symbol_QMARK_;\nvar zreader_cond_w_coll_QMARK__orig_val__42194 = zprint.zfns.zreader_cond_w_coll_QMARK_;\nvar zlift_ns_orig_val__42195 = zprint.zfns.zlift_ns;\nvar zfind_orig_val__42196 = zprint.zfns.zfind;\nvar ztake_append_orig_val__42197 = zprint.zfns.ztake_append;\nvar zstring_temp_val__42208 = rewrite_clj.zip.string;\nvar znumstr_temp_val__42209 = zprint.zutil.znumstr;\nvar zbyte_array_QMARK__temp_val__42210 = cljs.core.constantly(false);\nvar zcomment_QMARK__temp_val__42211 = zprint.zutil.zcomment_QMARK_;\nvar zsexpr_temp_val__42212 = rewrite_clj.zip.sexpr;\nvar zsexpr_QMARK__temp_val__42213 = zprint.zutil.zsexpr_QMARK_;\nvar zseqnws_temp_val__42214 = zprint.zutil.zseqnws;\nvar zseqnws_w_nl_temp_val__42215 = zprint.zutil.zseqnws_w_nl;\nvar zseqnws_w_bl_temp_val__42216 = zprint.zutil.zseqnws_w_bl;\nvar zfocus_style_temp_val__42217 = zprint.zutil.zfocus_style;\nvar zstart_temp_val__42218 = zprint.zutil.zstart;\nvar zfirst_temp_val__42219 = zprint.zutil.zfirst;\nvar zfirst_sexpr_temp_val__42220 = zprint.zutil.zfirst_sexpr;\nvar zsecond_temp_val__42221 = zprint.zutil.zsecond;\nvar zthird_temp_val__42222 = zprint.zutil.zthird;\nvar zfourth_temp_val__42223 = zprint.zutil.zfourth;\nvar znextnws_temp_val__42224 = zprint.zutil.zrightnws;\nvar znextnws_w_nl_temp_val__42225 = zprint.zutil.znextnws_w_nl;\nvar znthnext_temp_val__42226 = zprint.zutil.znthnext;\nvar zcount_temp_val__42227 = zprint.zutil.zcount;\nvar zcount_zloc_seq_nc_nws_temp_val__42228 = zprint.zutil.zcount_zloc_seq_nc_nws;\nvar zmap_temp_val__42229 = zprint.zutil.zmap;\nvar zmap_w_nl_temp_val__42230 = zprint.zutil.zmap_w_nl;\nvar zmap_w_bl_temp_val__42231 = zprint.zutil.zmap_w_bl;\nvar zmap_w_nl_comma_temp_val__42232 = zprint.zutil.zmap_w_nl_comma;\nvar zmap_no_comment_temp_val__42233 = zprint.zutil.zmap_no_comment;\nvar zanonfn_QMARK__temp_val__42234 = zprint.zutil.zanonfn_QMARK_;\nvar zfn_obj_QMARK__temp_val__42235 = cljs.core.constantly(false);\nvar zfocus_temp_val__42236 = zprint.zutil.zfocus;\nvar zfind_path_temp_val__42237 = zprint.zutil.find_root_and_path_nw;\nvar zwhitespace_QMARK__temp_val__42238 = zprint.zutil.whitespace_QMARK_;\nvar zlist_QMARK__temp_val__42239 = rewrite_clj.zip.list_QMARK_;\nvar zvector_QMARK__temp_val__42240 = rewrite_clj.zip.vector_QMARK_;\nvar zmap_QMARK__temp_val__42241 = rewrite_clj.zip.map_QMARK_;\nvar znamespacedmap_QMARK__temp_val__42242 = zprint.zutil.znamespacedmap_QMARK_;\nvar zset_QMARK__temp_val__42243 = rewrite_clj.zip.set_QMARK_;\nvar zcoll_QMARK__temp_val__42244 = zprint.zutil.z_coll_QMARK_;\nvar zuneval_QMARK__temp_val__42245 = zprint.zutil.zuneval_QMARK_;\nvar zmeta_QMARK__temp_val__42246 = zprint.zutil.zmeta_QMARK_;\nvar ztag_temp_val__42247 = zprint.zutil.ztag;\nvar zlast_temp_val__42248 = zprint.zutil.zlast;\nvar zarray_QMARK__temp_val__42249 = cljs.core.constantly(false);\nvar zatom_QMARK__temp_val__42250 = cljs.core.constantly(false);\nvar zderef_temp_val__42251 = cljs.core.constantly(false);\nvar zrecord_QMARK__temp_val__42252 = cljs.core.constantly(false);\nvar zns_QMARK__temp_val__42253 = cljs.core.constantly(false);\nvar zobj_to_vec_temp_val__42254 = cljs.core.constantly(null);\nvar zexpandarray_temp_val__42255 = cljs.core.constantly(null);\nvar znewline_QMARK__temp_val__42256 = zprint.zutil.znewline_QMARK_;\nvar zwhitespaceorcomment_QMARK__temp_val__42257 = rewrite_clj.zip.whitespace_or_comment_QMARK_;\nvar zmap_all_temp_val__42258 = zprint.zutil.zmap_all;\nvar zpromise_QMARK__temp_val__42259 = cljs.core.constantly(false);\nvar zfuture_QMARK__temp_val__42260 = cljs.core.constantly(false);\nvar zdelay_QMARK__temp_val__42261 = cljs.core.constantly(false);\nvar zkeyword_QMARK__temp_val__42262 = zprint.zutil.zkeyword_QMARK_;\nvar zconstant_QMARK__temp_val__42263 = zprint.zutil.zconstant_QMARK_;\nvar zagent_QMARK__temp_val__42264 = cljs.core.constantly(false);\nvar zreader_macro_QMARK__temp_val__42265 = zprint.zutil.zreader_macro_QMARK_;\nvar zarray_to_shift_seq_temp_val__42266 = cljs.core.constantly(null);\nvar zdotdotdot_temp_val__42267 = zprint.zutil.zdotdotdot;\nvar zsymbol_QMARK__temp_val__42268 = zprint.zutil.zsymbol_QMARK_;\nvar znil_QMARK__temp_val__42269 = zprint.zutil.znil_QMARK_;\nvar zreader_cond_w_symbol_QMARK__temp_val__42270 = zprint.zutil.zreader_cond_w_symbol_QMARK_;\nvar zreader_cond_w_coll_QMARK__temp_val__42271 = zprint.zutil.zreader_cond_w_coll_QMARK_;\nvar zlift_ns_temp_val__42272 = zprint.zutil.zlift_ns;\nvar zfind_temp_val__42273 = zprint.zutil.zfind;\nvar ztake_append_temp_val__42274 = zprint.zutil.ztake_append;\n(zprint.zfns.zstring = zstring_temp_val__42208);\n\n(zprint.zfns.znumstr = znumstr_temp_val__42209);\n\n(zprint.zfns.zbyte_array_QMARK_ = zbyte_array_QMARK__temp_val__42210);\n\n(zprint.zfns.zcomment_QMARK_ = zcomment_QMARK__temp_val__42211);\n\n(zprint.zfns.zsexpr = zsexpr_temp_val__42212);\n\n(zprint.zfns.zsexpr_QMARK_ = zsexpr_QMARK__temp_val__42213);\n\n(zprint.zfns.zseqnws = zseqnws_temp_val__42214);\n\n(zprint.zfns.zseqnws_w_nl = zseqnws_w_nl_temp_val__42215);\n\n(zprint.zfns.zseqnws_w_bl = zseqnws_w_bl_temp_val__42216);\n\n(zprint.zfns.zfocus_style = zfocus_style_temp_val__42217);\n\n(zprint.zfns.zstart = zstart_temp_val__42218);\n\n(zprint.zfns.zfirst = zfirst_temp_val__42219);\n\n(zprint.zfns.zfirst_sexpr = zfirst_sexpr_temp_val__42220);\n\n(zprint.zfns.zsecond = zsecond_temp_val__42221);\n\n(zprint.zfns.zthird = zthird_temp_val__42222);\n\n(zprint.zfns.zfourth = zfourth_temp_val__42223);\n\n(zprint.zfns.znextnws = znextnws_temp_val__42224);\n\n(zprint.zfns.znextnws_w_nl = znextnws_w_nl_temp_val__42225);\n\n(zprint.zfns.znthnext = znthnext_temp_val__42226);\n\n(zprint.zfns.zcount = zcount_temp_val__42227);\n\n(zprint.zfns.zcount_zloc_seq_nc_nws = zcount_zloc_seq_nc_nws_temp_val__42228);\n\n(zprint.zfns.zmap = zmap_temp_val__42229);\n\n(zprint.zfns.zmap_w_nl = zmap_w_nl_temp_val__42230);\n\n(zprint.zfns.zmap_w_bl = zmap_w_bl_temp_val__42231);\n\n(zprint.zfns.zmap_w_nl_comma = zmap_w_nl_comma_temp_val__42232);\n\n(zprint.zfns.zmap_no_comment = zmap_no_comment_temp_val__42233);\n\n(zprint.zfns.zanonfn_QMARK_ = zanonfn_QMARK__temp_val__42234);\n\n(zprint.zfns.zfn_obj_QMARK_ = zfn_obj_QMARK__temp_val__42235);\n\n(zprint.zfns.zfocus = zfocus_temp_val__42236);\n\n(zprint.zfns.zfind_path = zfind_path_temp_val__42237);\n\n(zprint.zfns.zwhitespace_QMARK_ = zwhitespace_QMARK__temp_val__42238);\n\n(zprint.zfns.zlist_QMARK_ = zlist_QMARK__temp_val__42239);\n\n(zprint.zfns.zvector_QMARK_ = zvector_QMARK__temp_val__42240);\n\n(zprint.zfns.zmap_QMARK_ = zmap_QMARK__temp_val__42241);\n\n(zprint.zfns.znamespacedmap_QMARK_ = znamespacedmap_QMARK__temp_val__42242);\n\n(zprint.zfns.zset_QMARK_ = zset_QMARK__temp_val__42243);\n\n(zprint.zfns.zcoll_QMARK_ = zcoll_QMARK__temp_val__42244);\n\n(zprint.zfns.zuneval_QMARK_ = zuneval_QMARK__temp_val__42245);\n\n(zprint.zfns.zmeta_QMARK_ = zmeta_QMARK__temp_val__42246);\n\n(zprint.zfns.ztag = ztag_temp_val__42247);\n\n(zprint.zfns.zlast = zlast_temp_val__42248);\n\n(zprint.zfns.zarray_QMARK_ = zarray_QMARK__temp_val__42249);\n\n(zprint.zfns.zatom_QMARK_ = zatom_QMARK__temp_val__42250);\n\n(zprint.zfns.zderef = zderef_temp_val__42251);\n\n(zprint.zfns.zrecord_QMARK_ = zrecord_QMARK__temp_val__42252);\n\n(zprint.zfns.zns_QMARK_ = zns_QMARK__temp_val__42253);\n\n(zprint.zfns.zobj_to_vec = zobj_to_vec_temp_val__42254);\n\n(zprint.zfns.zexpandarray = zexpandarray_temp_val__42255);\n\n(zprint.zfns.znewline_QMARK_ = znewline_QMARK__temp_val__42256);\n\n(zprint.zfns.zwhitespaceorcomment_QMARK_ = zwhitespaceorcomment_QMARK__temp_val__42257);\n\n(zprint.zfns.zmap_all = zmap_all_temp_val__42258);\n\n(zprint.zfns.zpromise_QMARK_ = zpromise_QMARK__temp_val__42259);\n\n(zprint.zfns.zfuture_QMARK_ = zfuture_QMARK__temp_val__42260);\n\n(zprint.zfns.zdelay_QMARK_ = zdelay_QMARK__temp_val__42261);\n\n(zprint.zfns.zkeyword_QMARK_ = zkeyword_QMARK__temp_val__42262);\n\n(zprint.zfns.zconstant_QMARK_ = zconstant_QMARK__temp_val__42263);\n\n(zprint.zfns.zagent_QMARK_ = zagent_QMARK__temp_val__42264);\n\n(zprint.zfns.zreader_macro_QMARK_ = zreader_macro_QMARK__temp_val__42265);\n\n(zprint.zfns.zarray_to_shift_seq = zarray_to_shift_seq_temp_val__42266);\n\n(zprint.zfns.zdotdotdot = zdotdotdot_temp_val__42267);\n\n(zprint.zfns.zsymbol_QMARK_ = zsymbol_QMARK__temp_val__42268);\n\n(zprint.zfns.znil_QMARK_ = znil_QMARK__temp_val__42269);\n\n(zprint.zfns.zreader_cond_w_symbol_QMARK_ = zreader_cond_w_symbol_QMARK__temp_val__42270);\n\n(zprint.zfns.zreader_cond_w_coll_QMARK_ = zreader_cond_w_coll_QMARK__temp_val__42271);\n\n(zprint.zfns.zlift_ns = zlift_ns_temp_val__42272);\n\n(zprint.zfns.zfind = zfind_temp_val__42273);\n\n(zprint.zfns.ztake_append = ztake_append_temp_val__42274);\n\ntry{return (body_fn.cljs$core$IFn$_invoke$arity$0 ? body_fn.cljs$core$IFn$_invoke$arity$0() : body_fn.call(null));\n}finally {(zprint.zfns.ztake_append = ztake_append_orig_val__42197);\n\n(zprint.zfns.zfind = zfind_orig_val__42196);\n\n(zprint.zfns.zlift_ns = zlift_ns_orig_val__42195);\n\n(zprint.zfns.zreader_cond_w_coll_QMARK_ = zreader_cond_w_coll_QMARK__orig_val__42194);\n\n(zprint.zfns.zreader_cond_w_symbol_QMARK_ = zreader_cond_w_symbol_QMARK__orig_val__42193);\n\n(zprint.zfns.znil_QMARK_ = znil_QMARK__orig_val__42192);\n\n(zprint.zfns.zsymbol_QMARK_ = zsymbol_QMARK__orig_val__42191);\n\n(zprint.zfns.zdotdotdot = zdotdotdot_orig_val__42190);\n\n(zprint.zfns.zarray_to_shift_seq = zarray_to_shift_seq_orig_val__42189);\n\n(zprint.zfns.zreader_macro_QMARK_ = zreader_macro_QMARK__orig_val__42188);\n\n(zprint.zfns.zagent_QMARK_ = zagent_QMARK__orig_val__42187);\n\n(zprint.zfns.zconstant_QMARK_ = zconstant_QMARK__orig_val__42186);\n\n(zprint.zfns.zkeyword_QMARK_ = zkeyword_QMARK__orig_val__42185);\n\n(zprint.zfns.zdelay_QMARK_ = zdelay_QMARK__orig_val__42184);\n\n(zprint.zfns.zfuture_QMARK_ = zfuture_QMARK__orig_val__42183);\n\n(zprint.zfns.zpromise_QMARK_ = zpromise_QMARK__orig_val__42182);\n\n(zprint.zfns.zmap_all = zmap_all_orig_val__42181);\n\n(zprint.zfns.zwhitespaceorcomment_QMARK_ = zwhitespaceorcomment_QMARK__orig_val__42180);\n\n(zprint.zfns.znewline_QMARK_ = znewline_QMARK__orig_val__42179);\n\n(zprint.zfns.zexpandarray = zexpandarray_orig_val__42178);\n\n(zprint.zfns.zobj_to_vec = zobj_to_vec_orig_val__42177);\n\n(zprint.zfns.zns_QMARK_ = zns_QMARK__orig_val__42176);\n\n(zprint.zfns.zrecord_QMARK_ = zrecord_QMARK__orig_val__42175);\n\n(zprint.zfns.zderef = zderef_orig_val__42174);\n\n(zprint.zfns.zatom_QMARK_ = zatom_QMARK__orig_val__42173);\n\n(zprint.zfns.zarray_QMARK_ = zarray_QMARK__orig_val__42172);\n\n(zprint.zfns.zlast = zlast_orig_val__42171);\n\n(zprint.zfns.ztag = ztag_orig_val__42170);\n\n(zprint.zfns.zmeta_QMARK_ = zmeta_QMARK__orig_val__42169);\n\n(zprint.zfns.zuneval_QMARK_ = zuneval_QMARK__orig_val__42168);\n\n(zprint.zfns.zcoll_QMARK_ = zcoll_QMARK__orig_val__42167);\n\n(zprint.zfns.zset_QMARK_ = zset_QMARK__orig_val__42166);\n\n(zprint.zfns.znamespacedmap_QMARK_ = znamespacedmap_QMARK__orig_val__42164);\n\n(zprint.zfns.zmap_QMARK_ = zmap_QMARK__orig_val__42162);\n\n(zprint.zfns.zvector_QMARK_ = zvector_QMARK__orig_val__42160);\n\n(zprint.zfns.zlist_QMARK_ = zlist_QMARK__orig_val__42159);\n\n(zprint.zfns.zwhitespace_QMARK_ = zwhitespace_QMARK__orig_val__42158);\n\n(zprint.zfns.zfind_path = zfind_path_orig_val__42157);\n\n(zprint.zfns.zfocus = zfocus_orig_val__42156);\n\n(zprint.zfns.zfn_obj_QMARK_ = zfn_obj_QMARK__orig_val__42155);\n\n(zprint.zfns.zanonfn_QMARK_ = zanonfn_QMARK__orig_val__42154);\n\n(zprint.zfns.zmap_no_comment = zmap_no_comment_orig_val__42153);\n\n(zprint.zfns.zmap_w_nl_comma = zmap_w_nl_comma_orig_val__42152);\n\n(zprint.zfns.zmap_w_bl = zmap_w_bl_orig_val__42151);\n\n(zprint.zfns.zmap_w_nl = zmap_w_nl_orig_val__42150);\n\n(zprint.zfns.zmap = zmap_orig_val__42149);\n\n(zprint.zfns.zcount_zloc_seq_nc_nws = zcount_zloc_seq_nc_nws_orig_val__42148);\n\n(zprint.zfns.zcount = zcount_orig_val__42147);\n\n(zprint.zfns.znthnext = znthnext_orig_val__42146);\n\n(zprint.zfns.znextnws_w_nl = znextnws_w_nl_orig_val__42145);\n\n(zprint.zfns.znextnws = znextnws_orig_val__42144);\n\n(zprint.zfns.zfourth = zfourth_orig_val__42143);\n\n(zprint.zfns.zthird = zthird_orig_val__42142);\n\n(zprint.zfns.zsecond = zsecond_orig_val__42141);\n\n(zprint.zfns.zfirst_sexpr = zfirst_sexpr_orig_val__42140);\n\n(zprint.zfns.zfirst = zfirst_orig_val__42139);\n\n(zprint.zfns.zstart = zstart_orig_val__42138);\n\n(zprint.zfns.zfocus_style = zfocus_style_orig_val__42137);\n\n(zprint.zfns.zseqnws_w_bl = zseqnws_w_bl_orig_val__42136);\n\n(zprint.zfns.zseqnws_w_nl = zseqnws_w_nl_orig_val__42135);\n\n(zprint.zfns.zseqnws = zseqnws_orig_val__42134);\n\n(zprint.zfns.zsexpr_QMARK_ = zsexpr_QMARK__orig_val__42133);\n\n(zprint.zfns.zsexpr = zsexpr_orig_val__42132);\n\n(zprint.zfns.zcomment_QMARK_ = zcomment_QMARK__orig_val__42131);\n\n(zprint.zfns.zbyte_array_QMARK_ = zbyte_array_QMARK__orig_val__42130);\n\n(zprint.zfns.znumstr = znumstr_orig_val__42129);\n\n(zprint.zfns.zstring = zstring_orig_val__42128);\n}});\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","zprint/zutil.cljc","~:line",2,"~:column",14,"~:end-line",2,"~:end-column",26,"~:no-doc",true],"~:ns-aliases",["^ ","~$clojure.spec.alpha","~$cljs.spec.alpha","~$clojure.tools.reader.impl.utils","~$cljs.tools.reader.impl.utils","~$cljs.loader","~$shadow.loader","~$clojure.tools.reader.impl.commons","~$cljs.tools.reader.impl.commons","~$clojure.tools.reader.impl.errors","~$cljs.tools.reader.impl.errors","~$react","~$module$node_modules$react$index","~$clojure.tools.reader.reader-types","~$cljs.tools.reader.reader-types","~$clojure.tools.reader.edn","~$cljs.tools.reader.edn","~$clojure.pprint","~$cljs.pprint","~$react-dom","~$module$node_modules$react_dom$index","~$clojure.repl","~$cljs.repl"],"~:use-macros",null,"~:excludes",["~#set",[]],"~:name","~$zprint.zutil","~:reader-aliases",["^ "],"~:op","~:ns","~:imports",null,"~:requires",["^ ","~$rewrite-clj.parser","^11","~$p","^11","~$rewrite-clj.node","^12","~$rewrite-clj.zip","^13","~$cljs.core","^14","~$goog","^15","~$zprint.zfns","^16","~$n","^12","~$z","^13","~$clojure.string","^17"],"~:seen",["^U",["~:require"]],"~:uses",["^ ","~$tag","^13","~$right*","^13","~$skip","^13","~$rightmost?","^13","~$left*","^13","~$sexpr","^13","~$up*","^13","~$edn*","^13","~$replace*","^13","~$down*","^13","~$string","^13","~$leftmost?","^13","~$next*","^13","~$length","^13","~$prev*","^13","~$insert-right*","^13","~$whitespace-or-comment?","^13"],"~:require-macros",["^ ","^14","^14","^13","^13","~$z","^13"],"~:form",["~#list",["~$ns","^W",["^1N",["^19","^17","^16",["^11","~:as","~$p"],["^12","^1P","~$n"],["^13","^1P","~$z","~:refer",["^1D","^1A","^1<","^1?","^1G","^1I","^1C","^1J","^1B","^1@","^1E","^1;","^1=","^1K","^1H","^1>","^1F"]]]]]],"~:flags",["^ ","^19",["^U",[]]],"~:js-deps",["^ "],"~:deps",["^15","^14","^17","^16","^11","^12","^13"]],"^Z","^W","~:resource-id",["~:shadow.build.classpath/resource","zprint/zutil.cljc"],"~:compiled-at",1666857667675,"^X",["^ ","^11","^11","~$p","^11","^12","^12","^13","^13","^14","^14","^15","^15","^16","^16","~$n","^12","~$z","^13","^17","^17"],"~:resource-name","zprint/zutil.cljc","~:warnings",[],"~:source",";!zprint {:style :require-justify}\n(ns ^:no-doc zprint.zutil\n  (:require\n    #?@(:bb []\n        :clj [[zprint.macros :refer [do-redef-vars]]])\n    clojure.string\n    zprint.zfns\n    #?@(:clj [[zprint.redef]])\n    [rewrite-clj.parser :as p]\n    [rewrite-clj.node   :as n]\n    [rewrite-clj.zip    :as    z\n                        :refer [down* up* right* left* next* prev* replace*\n                                insert-right* edn* sexpr string tag skip\n                                whitespace-or-comment? length rightmost?\n                                leftmost?]]))\n\n;;\n;; # Zipper oriented style printers\n;;\n\n(defn whitespace?\n  [zloc]\n  (or (= (tag zloc) :whitespace) (= (tag zloc) :newline) (= (tag zloc) :comma)))\n\n; indent-only\n(defn skip-whitespace\n  ([zloc] (skip-whitespace z/right zloc))\n  ([f zloc] (skip f whitespace? zloc)))\n\n(defn whitespace-not-newline?\n  [zloc]\n  (or (= (tag zloc) :whitespace) (= (tag zloc) :comma)))\n\n; conflicts with clojure.core:\n\n(def zremove z/remove)\n\n(def zreplace z/replace)\n\n;;\n;; Check to see if we are at the focus by checking the\n;; path.\n;;\n\n(declare find-root-and-path)\n\n(defn zfocus\n  \"Is the zipper zloc equivalent to the path floc.  In this\n  case, floc isn't a zipper, but was turned into a path early on.\"\n  [zloc floc]\n  (let [[_ zpath] (find-root-and-path zloc)] (= zpath floc)))\n\n(defn zfocus-style\n  \"Take the various inputs and come up with a style.\"\n  [style zloc floc]\n  (let [style (if (= style :f) style (if (zfocus zloc floc) :f :b))] style))\n\n(defn z-coll? \"Is the zloc a collection?\" [zloc] (z/seq? zloc))\n\n(defn zuneval? \"Is this a #_(...)\" [zloc] (= (tag zloc) :uneval))\n\n(defn zmeta? \"Is this a ^{...}\" [zloc] (= (tag zloc) :meta))\n\n(defn zquote?\n  \"Is this a '(...) or '[ ... ] or some other quote?\"\n  [zloc]\n  (= (tag zloc) :quote))\n\n(defn zreader-macro? \"Is this a @...\" [zloc] (= (tag zloc) :reader-macro))\n\n(defn ztag \"Return the tag for this zloc\" [zloc] (tag zloc))\n\n(defn znamespacedmap?\n  \"Is this a namespaced map?\"\n  [zloc]\n  #?(:clj (= (tag zloc) :namespaced-map)\n     :cljs (or (= (tag zloc) :namespaced-map)\n               (re-find #\"^#:\" (z/string zloc)))))\n\n(defn zcomment?\n  \"Returns true if this is a comment.\"\n  [zloc]\n  (when zloc (= (tag zloc) :comment)))\n\n(defn znewline?\n  \"Returns true if this is a newline.\"\n  [zloc]\n  (when zloc (= (tag zloc) :newline)))\n\n(defn znumstr\n  \"Does z/string, but takes an additional argument for hex conversion.\n  Hex conversion is not implemented for zippers, though, because at present\n  it is only used for byte-arrays, which don't really show up here.\"\n  [zloc _ _]\n  (string zloc))\n\n(defn zstart \"Find the zloc inside of this zloc.\" [zloc] (down* zloc))\n\n(defn zfirst\n  \"Find the first non-whitespace zloc inside of this zloc, or\n  the first whitespace zloc that is the focus.\"\n  [zloc]\n  (let [nloc (down* zloc)] (if nloc (skip right* whitespace? nloc))))\n\n(declare zsexpr?)\n\n(defn zfirst-sexpr\n  \"Find the first sexpr-able? zloc inside of this zloc.\"\n  [zloc]\n  (let [nloc (down* zloc)] (if nloc (skip right* #(not (zsexpr? %)) nloc))))\n\n(defn zsecond\n  \"Find the second non-whitespace zloc inside of this zloc.\"\n  [zloc]\n  (if-let [first-loc (zfirst zloc)]\n    (if-let [nloc (right* first-loc)] (skip right* whitespace? nloc))))\n\n(defn zthird\n  \"Find the third non-whitespace zloc inside of this zloc.\"\n  [zloc]\n  (some->> (zfirst zloc)\n           right*\n           (skip right* whitespace?)\n           right*\n           (skip right* whitespace?)))\n\n(defn zfourth\n  \"Find the fourth non-whitespace zloc inside of this zloc.\"\n  [zloc]\n  (some->> (zfirst zloc)\n           right*\n           (skip right* whitespace?)\n           right*\n           (skip right* whitespace?)\n           right*\n           (skip right* whitespace?)))\n\n(defn zrightnws\n  \"Find the next non-whitespace zloc inside of this zloc. Returns nil\n  if nothing left.\"\n  [zloc]\n  (if zloc (if-let [nloc (right* zloc)] (skip right* whitespace? nloc))))\n\n(defn znextnws-w-nl\n  \"Find the next non-whitespace zloc inside of this zloc considering \n  newlines to not be whitespace. Returns nil if nothing left. Which is\n  why this is nextnws and not rightnws, since it is exposed in zfns.\"\n  [zloc]\n  (if zloc\n    (if-let [nloc (right* zloc)] (skip right* whitespace-not-newline? nloc))))\n\n(defn zrightmost\n  \"Find the rightmost non-whitespace zloc at this level\"\n  [zloc]\n  (loop [nloc (zrightnws zloc)\n         ploc zloc]\n    (if-not nloc ploc (recur (zrightnws nloc) nloc))))\n\n(defn zleftnws\n  \"Find the next non-whitespace zloc inside of this zloc.\"\n  [zloc]\n  (if zloc (if-let [nloc (left* zloc)] (skip left* whitespace? nloc))))\n\n(defn zleftmost\n  \"Find the leftmost non-whitespace zloc at this level\"\n  [zloc]\n  (loop [nloc (zleftnws zloc)\n         ploc zloc]\n    (if-not nloc ploc (recur (zleftnws nloc) nloc))))\n\n; This uses next*, not right*, and will step up out of a sequence.\n#_(defn znextnws\n    \"Find the next non-whitespace zloc.\"\n    [zloc]\n    (if (z/end? zloc)\n      zloc\n      (if-let [nloc (next* zloc)] (skip next* whitespace? nloc))))\n\n(defn zprevnws\n  \"Find the next non-whitespace zloc.\"\n  [zloc]\n  (if-let [ploc (prev* zloc)] (skip prev* whitespace? ploc)))\n\n(defn znthnext\n  \"Find the nth non-whitespace zloc inside of this zloc.\"\n  [zloc n]\n  (loop [nloc (skip-whitespace (down* zloc))\n         i ^long n]\n    (if (or (nil? nloc) (= i 0)) nloc (recur (zrightnws nloc) (dec i)))))\n\n(defn zfind\n  \"Find the locations (counting from zero, and only counting non-whitespace\n  elements) of the first zthing?.  Return its index if it is found, nil if not.\"\n  [zthing? zloc]\n  (loop [nloc (skip-whitespace (down* zloc))\n         i 0]\n    (when (not (nil? nloc))\n      (if (zthing? nloc) i (recur (zrightnws nloc) (inc i))))))\n\n(defn znl [] \"Return a zloc which is a newline.\" (edn* (p/parse-string \"\\n\")))\n\n(defn multi-nl\n  \"Return a sequence of zloc newlines.\"\n  [n]\n  (apply vector (repeat n (znl))))\n\n(defn split-newline-from-comment\n  \"Given a zloc which is a comment, replace it with a zloc which is the\n  same comment with no newline, and a newline that follows it.  This is\n  done in the zipper so that later navigation in this area remains\n  continues to work.\"\n  [zloc]\n  (let [comment-no-nl (p/parse-string\n                        (clojure.string/replace-first (z/string zloc) \"\\n\" \"\"))\n        new-comment (replace* zloc comment-no-nl)\n        new-comment (insert-right* new-comment (p/parse-string \"\\n\"))]\n    new-comment))\n\n(defn zmap-w-bl\n  \"Return a vector containing the return of applying a function to\n  every non-whitespace zloc inside of zloc, including two newlines\n  for every blank line encountered.  Note that a truly blank line\n  will show up as one zloc with two newlines in it.  It will have\n  (= (z/tag nloc) :newline), but it will have both newlines.  To\n  ease handling of these multi-line newlines, this routine will\n  split them up into multiple individual newlines.\"\n  [zfn zloc]\n  (loop [nloc (down* zloc)\n         blank? false\n         previous-was-nl? false\n         previous-comment? nil\n         out []]\n    (if-not nloc\n      out\n      (let [ws? (whitespace? nloc)\n            nl? (= (z/tag nloc) :newline)\n            nl-len (when nl? (length nloc))\n            multi-nl? (when nl? (> (length nloc) 1))\n            emit-nl? (or (and blank? nl?) multi-nl?)\n            ; newline thing to emit\n            nl-to-emit (when emit-nl?\n                         (cond multi-nl? (mapv zfn\n                                           (multi-nl (if (or previous-was-nl?\n                                                             (not blank?))\n                                                       nl-len\n                                                       (inc nl-len))))\n                               previous-was-nl? [(zfn nloc)]\n                               :else [(zfn nloc) (zfn nloc)]))\n            ; non newline thing to emit\n            comment? (= (z/tag nloc) :comment)\n            ; This may reset the nloc for the rest of the sequence!\n            nloc (if comment? (split-newline-from-comment nloc) nloc)\n            result (when (or (not ws?) (and nl? previous-comment?)) (zfn nloc))]\n        #_(prn \"map-w-bl: blank?\" blank?\n               \", zloc:\" (z/string nloc)\n               \", length:\" (length nloc)\n               \", ws?\" ws?\n               \", previous-was-nl??\" previous-was-nl?\n               \", previous-comment?\" previous-comment?\n               \", nl? \" nl?\n               \", nl-len:\" nl-len\n               \", multi-nl?\" multi-nl?\n               \", emit-nl?\" emit-nl?\n               \", nl-to-emit\" (map z/string nl-to-emit))\n        (recur (right* nloc)\n               (if blank?\n                 ; If already blank, then if it is whitespace it is still\n                 ; blank.  That includes newlines (which are ws? too).\n                 (or ws? nl?)\n                 ; Not already blank, only a newline (of any length)\n                 ; will start blank\n                 nl?)\n               ; If we emitted something, was it a nl?  If nothing emitted,\n               ; no change.\n               (if (or result nl-to-emit)\n                 ; Two ways to emit a nl\n                 (or (and nl? previous-comment?) emit-nl?)\n                 previous-was-nl?)\n               comment?\n               (cond result (conj out result)\n                     nl-to-emit (apply conj out nl-to-emit)\n                     :else out))))))\n\n(defn zmap-w-nl\n  \"Return a vector containing the return of applying a function to\n  every non-whitespace zloc inside of zloc, including newlines.\n  This will also split newlines into separate zlocs if they were\n  multiple, and split the newline off the end of a comment. The\n  comment split actually changes the zipper for the rest of the\n  sequence, where the newline splits do not.\"\n  [zfn zloc]\n  (loop [nloc (down* zloc)\n         out []]\n    (if-not nloc\n      out\n      (let [; non-newline thing to emit\n            nl? (= (z/tag nloc) :newline)\n            comment? (= (z/tag nloc) :comment)\n            ; This may reset the nloc for the rest of the sequence!\n            nloc (if comment? (split-newline-from-comment nloc) nloc)\n            result (when (not (whitespace? nloc)) (zfn nloc))\n            nl-len (when nl? (length nloc))\n            multi-nl? (when nl? (> (length nloc) 1))\n            ; newline thing to emit\n            nl-to-emit\n              (when nl?\n                (if multi-nl? (mapv zfn (multi-nl nl-len)) [(zfn nloc)]))]\n        #_(println \"zmap-w-nl: tag:\" (z/tag nloc))\n        (recur (right* nloc)\n               (cond result (conj out result)\n                     nl-to-emit (apply conj out nl-to-emit)\n                     :else out))))))\n\n(defn zmap-w-nl-comma\n  \"Return a vector containing the return of applying a function to\n  every non-whitespace zloc inside of zloc, including newlines and commas.\n  This will also split newlines into separate zlocs if they were\n  multiple, and split the newline off the end of a comment.\"\n  [zfn zloc]\n  (loop [nloc (down* zloc)\n         out []]\n    (if-not nloc\n      out\n      (let [; non-newline thing to emit\n            nl? (= (z/tag nloc) :newline)\n            comma? #?(:clj (= (z/tag nloc) :comma)\n                      :cljs (or (= (z/tag nloc) :comma)\n                                (and (= (z/tag nloc) :whitespace)\n                                     (clojure.string/includes? (z/string nloc)\n                                                               \",\"))))\n            comment? (= (z/tag nloc) :comment)\n            ; This may reset the nloc for the rest of the sequence!\n            nloc (if comment? (split-newline-from-comment nloc) nloc)\n            result (when (or (not (whitespace? nloc)) comma?) (zfn nloc))\n            nl-len (when nl? (length nloc))\n            multi-nl? (when nl? (> (length nloc) 1))\n            ; newline thing to emit\n            nl-to-emit\n              (when nl?\n                (if multi-nl? (mapv zfn (multi-nl nl-len)) [(zfn nloc)]))]\n        #_(prn \"zmap-w-nl-comma: tag:\" (z/tag nloc) (z/string nloc))\n        (recur (right* nloc)\n               (cond result (conj out result)\n                     nl-to-emit (apply conj out nl-to-emit)\n                     :else out))))))\n\n(defn zmap\n  \"Return a vector containing the return of applying a function to \n  every non-whitespace zloc inside of zloc. The newline that shows\n  up in every comment is also split out into a separate zloc.\"\n  [zfn zloc]\n  #_(prn \"zmap: zloc\" (z/string zloc))\n  (loop [nloc (down* zloc)\n         previous-comment? nil\n         out []]\n    (if-not nloc\n      out\n      (let [comment? (= (z/tag nloc) :comment)\n            nl? (= (z/tag nloc) :newline)\n            ; This may reset the nloc for the rest of the sequence!\n            nloc (if comment? (split-newline-from-comment nloc) nloc)\n            result (when (or (not (whitespace? nloc))\n                             (and nl? previous-comment?))\n                     (zfn nloc))]\n        (recur (right* nloc) comment? (if result (conj out result) out))))))\n\n(defn zmap-no-comment\n  \"Return a vector containing the return of applying a function to \n  every non-whitespace zloc inside of zloc. Comments are considered\n  whitespace for this routine, and left out.\"\n  [zfn zloc]\n  #_(prn \"zmap-no-comment: zloc\" (z/string zloc))\n  (loop [nloc (down* zloc)\n         previous-comment? nil\n         out []]\n    (if-not nloc\n      out\n      (let [comment? (= (z/tag nloc) :comment)\n            nl? (= (z/tag nloc) :newline)\n            result (when (not (or (whitespace? nloc) comment? nl?)) (zfn nloc))]\n        (recur (right* nloc) comment? (if result (conj out result) out))))))\n\n\n; This was the original zmap before all of the changes...\n#_(defn zmap-alt\n    \"Return a vector containing the return of applying a function to \n  every non-whitespace zloc inside of zloc.\"\n    [zfn zloc]\n    (loop [nloc (down* zloc)\n           out []]\n      (if-not nloc\n        out\n        (recur (right* nloc)\n               (if-let [result (when (not (whitespace? nloc)) (zfn nloc))]\n                 (conj out result)\n                 out)))))\n\n(defn zcount\n  \"Return the count of non-whitespace elements in zloc.  Comments are\n  counted as one thing, commas are ignored as whitespace.\"\n  [zloc]\n  (loop [nloc (down* zloc)\n         i 0]\n    (if-not nloc\n      i\n      (recur (right* nloc) (if (not (whitespace? nloc)) (inc i) i)))))\n\n; Used in core.cljc\n(defn zmap-all\n  \"Return a vector containing the return of applying a function to \n  every zloc inside of zloc.\"\n  [zfn zloc]\n  (loop [nloc (down* zloc)\n         out []]\n    (if-not nloc out (recur (right* nloc) (conj out (zfn nloc))))))\n\n(defn zseqnws\n  \"Return a seq of all of the non-whitespace children of zloc.\"\n  [zloc]\n  (zmap identity zloc))\n\n(defn zseqnws-w-nl\n  \"Return a seq of all of the non-whitespace children of zloc, including\n  newlines.\"\n  [zloc]\n  (zmap-w-nl identity zloc))\n\n(defn zseqnws-w-bl\n  \"Return a seq of all of the non-whitespace children of zloc, including\n  only newlines that start and end blank lines.\"\n  [zloc]\n  (zmap-w-bl identity zloc))\n\n(defn zremove-right\n  \"Remove everything to the right of the current zloc. In other words,\n  make the current zloc the rightmost.\"\n  [zloc]\n  (loop [nloc zloc]\n    (if (rightmost? nloc) nloc (recur (zremove (right* nloc))))))\n\n(defn ztake-append\n  \"Considering the current zloc a collection, move down into it and\n  take n non-whitespace elements, dropping the rest.  Then append the\n  given element to the end, coercing it into a node/zloc.  Note, this \n  is not quite implemented that way, as it uses replace.\"\n  [n zloc end-struct]\n  (loop [nloc (down* zloc)\n         index 0]\n    (if (>= index n)\n      (up* (zremove-right (zreplace nloc end-struct)))\n      (let [xloc (right* nloc)]\n        (recur xloc (if (whitespace? xloc) index (inc index)))))))\n\n(defn zcount-zloc-seq-nc-nws\n  \"How many non-whitespace non-comment children are in zloc-seq? Note\n  that this is fundamentally different from zcount, in that it doesn't\n  take a zloc, but rather a zloc-seq (i.e., a seq of elements, each of\n  which is a zloc).\"\n  [zloc-seq]\n  (reduce #(if (whitespace-or-comment? %2) %1 (inc %1)) 0 zloc-seq))\n\n(defn find-root-and-path\n  \"Create a vector with the root as well as another vector\n  which contains the number of right moves after each down\n  down to find a particular zloc.  The right moves include\n  both whitespace and comments.\"\n  [zloc]\n  (if zloc\n    (loop [nloc zloc\n           left 0\n           out ()]\n      (if-not (left* nloc)\n        (if-not (up* nloc) [nloc out] (recur (up* nloc) 0 (cons left out)))\n        (recur (left* nloc) (inc left) out)))))\n\n(defn find-root-and-path-nw\n  \"Create a vector with the root as well as another vector\n  which contains the number of right moves after each down\n  down to find a particular zloc.  The right moves are\n  non-whitespace, but include comments.\"\n  [zloc]\n  (if zloc\n    (loop [nloc zloc\n           left 0\n           out ()]\n      (if-not (left* nloc)\n        (if-not (up* nloc) [nloc out] (recur (up* nloc) 0 (cons left out)))\n        (recur (left* nloc) (if (whitespace? nloc) left (inc left)) out)))))\n\n(defn find-root\n  \"Find the root from a zloc by doing lots of ups.\"\n  [zloc]\n  (loop [nloc zloc] (if-not (z/up nloc) nloc (recur (z/up nloc)))))\n\n(defn move-down-and-right\n  \"Move one down and then right a certain number of steps.\"\n  [zloc ^long right-count]\n  (loop [nloc (down* zloc)\n         remaining-right right-count]\n    (if (zero? remaining-right)\n      nloc\n      (recur (right* nloc) (dec remaining-right)))))\n\n(defn follow-path\n  \"Follow the path vector from the root and return the zloc\n  at this location.\"\n  [path-vec zloc]\n  (reduce move-down-and-right zloc path-vec))\n\n(defn zanonfn? \"Is this an anonymous fn?\" [zloc] (= (tag zloc) :fn))\n\n(defn zlast\n  \"Return the last non-whitespace (but possibly comment) element inside\n  of this zloc.\"\n  [zloc]\n  (let [nloc (down* zloc)] (when nloc (zrightmost nloc))))\n\n(defn zsexpr?\n  \"Returns true if this can be converted to an sexpr. Works around a bug\n  where n/printable-only? returns false for n/tag :fn, but z/sexpr fails\n  on something with n/tag :fn\"\n  [zloc]\n  (and zloc (not= :fn (tag zloc)) (not (n/printable-only? (z/node zloc)))))\n\n;\n; This doesn't work, because there are situations where (zsexpr? zloc)\n; will fail but it is still a keyword.\n;\n#_(defn zkeyword?-alt\n    \"Returns true if this is a keyword.\"\n    [zloc]\n    (and zloc (zsexpr? zloc) (keyword? (sexpr zloc))))\n\n(defn zkeyword?\n  \"Returns true if this is a keyword.\"\n  [zloc]\n  (and zloc (clojure.string/starts-with? (z/string zloc) \":\")))\n\n(defn zsymbol?\n  \"Returns true if this is a symbol.\"\n  [zloc]\n  ; Need to make sure it is a :token before sexpr\n  (and zloc (= (tag zloc) :token) (zsexpr? zloc) (symbol? (sexpr zloc))))\n\n(defn znil?\n  \"Returns true if this is nil.\"\n  [zloc]\n  ; Need to make sure it is a :token before sexpr\n  (and zloc (= (tag zloc) :token) (zsexpr? zloc) (nil? (z/sexpr zloc))))\n\n(defn zreader-cond-w-symbol?\n  \"Returns true if this is a reader-conditional with a symbol in \n  the first position (could be :clj or :cljs, whatever).\"\n  [zloc]\n  (let [result (when (zreader-macro? zloc)\n                 (let [element (z/down zloc)]\n                   (when (= (z/string element) \"?\")\n                     (let [element (z/down (z/right element))]\n                       (when (or (= (z/string element) \":clj\")\n                                 (= (z/string element) \":cljs\"))\n                         (zsymbol? (z/right element)))))))]\n    #_(println \"zreader-cond-w-symbol?:\" (z/string zloc) \"result:\" result)\n    result))\n\n(defn zreader-cond-w-coll?\n  \"Returns true if this is a reader-conditional with a collection in \n  the first position (could be :clj or :cljs, whatever).\"\n  [zloc]\n  (let [result (when (zreader-macro? zloc)\n                 (let [element (z/down zloc)]\n                   (when (= (z/string element) \"?\")\n                     (let [element (z/down (z/right element))]\n                       (when (or (= (z/string element) \":clj\")\n                                 (= (z/string element) \":cljs\"))\n                         (z-coll? (z/right element)))))))]\n    #_(println \"zreader-cond-w-coll?:\" (z/string zloc) \"result:\" result)\n    result))\n\n(defn zdotdotdot\n  \"Return a zloc that will turn into a string of three dots.\"\n  []\n  (edn* (p/parse-string \"...\")))\n\n(defn zconstant?\n  \"Returns true if this is a keyword, string, or number, in other words,\n  a constant.\"\n  [zloc]\n  #_(println \"zconstant?\" (z/string zloc))\n  (let [ztag (z/tag zloc)]\n    (if (or (= ztag :unquote) (= ztag :quote) (= ztag :syntax-quote))\n      (zconstant? (zfirst zloc))\n      (and (not (z-coll? zloc))\n           (or (zkeyword? zloc)\n               #_(println \"zconstant? - not keyword:\" (z/string zloc))\n               (when (and (= (tag zloc) :token) (zsexpr? zloc))\n                 #_(println \"zconstant?:\" (z/string zloc)\n                            \"\\n z-coll?\" (z-coll? zloc)\n                            \"z/tag:\" (z/tag zloc))\n                 (let [sexpr (sexpr zloc)]\n                   (or (string? sexpr)\n                       (number? sexpr)\n                       (= \"true\" (str sexpr))\n                       (= \"false\" (str sexpr))))))))))\n\n;;\n;; # Integrate specs with doc-string\n;;\n;; Find find-docstring could be a lot smarter, and perhaps\n;; find the docstring in the meta data (so that, defn might\n;; work, for instance).\n\n(defn find-doc-in-map\n  \"Given a zloc zipper of a map, find the :doc element.\"\n  [zloc]\n  (loop [nloc (z/down zloc)]\n    (when nloc\n      (if (and (zkeyword? nloc) (= (z/string nloc) \":doc\"))\n        (when (string? (sexpr (z/right nloc))) (z/right nloc))\n        (recur (z/right (z/right nloc)))))))\n\n(defn find-docstring\n  \"Find a docstring in a zipper of a function.\"\n  [zloc]\n  (let [fn-name (z/string (z/down zloc))]\n    (cond (or (= fn-name \"defn\") (= fn-name \"defmacro\"))\n            (let [docloc (z/right (z/right (z/down zloc)))]\n              (when (string? (sexpr docloc)) docloc))\n          (= fn-name \"def\") (let [maploc (z/down (z/right (z/down zloc)))]\n                              (when (z/map? maploc) (find-doc-in-map maploc)))\n          :else nil)))\n\n(defn add-spec-to-docstring\n  \"Given a zipper of a function definition, add the spec info to\n  the docstring. Works for docstring with (def ...) functions, but\n  the left-indent isn't optimal.  But to fix that, we'd have to do\n  the zprinting here, where we know the indent of the existing\n  docstring.\"\n  [zloc spec-str]\n  #_(println \"spec-str:\" spec-str)\n  (if-let [doc-zloc (find-docstring zloc)]\n    (let [new-doc-zloc (replace* doc-zloc\n                                 (z/node (edn* (p/parse-string\n                                                 (str \"\\\"\"\n                                                      (str (sexpr doc-zloc))\n                                                      spec-str\n                                                      \"\\\"\")))))]\n      (edn* (z/root new-doc-zloc)))\n    zloc))\n\n(defn zloc-to-keyword\n  \"Given a zloc, turn it into a keyword if it starts with a :, but remove\n  the : first.\"\n  [zloc]\n  (let [s (z/string zloc)]\n    (if (clojure.string/starts-with? s \":\")\n      ; remove the : now that we know it has one and turn it into a keyword\n      (keyword (subs s 1))\n      (symbol s))))\n\n(defn zlift-ns\n  \"Perform a lift-ns on a pair-seq that is returned from\n  partition-2-all-nc, which is a seq of pairs of zlocs that may or\n  may not have been sorted and which may or may not have had things\n  removed from it and may or may not actually be pairs.  Could be\n  single things, could be multiple things.  If contains multiple\n  things, the first thing is the key, but if it is just a single\n  thing, the first thing is *not* a key. So we only need to work\n  on the first of each seq which has more than one element in it,\n  and possibly replace it. This will only lift out a ns if all keys\n  in seqs with more than one element have the same namespace. Returns\n  the [namespace pair-seq] or nil.\"\n  [{:keys [in-code? lift-ns? lift-ns-in-code? unlift-ns?], :as map-options}\n   pair-seq ns]\n  #_(println \"zlift-ns: lift-ns?\" lift-ns?)\n  (cond\n    (and lift-ns? (if in-code? lift-ns-in-code? true))\n      (if ns\n        ; Already lifted, leave it alone\n        ;\n        ; One option might be to only lift it if there is more than one\n        ; key-value pair, since a lifted namespace with a single key-value\n        ; pair is kind of odd.  That would solve the deps.edn problem.\n        ; Note that it is not trivial to figure out how many key-value pairs\n        ; there are here, since pair-seq isn't really all key-value pairs.\n        [ns pair-seq]\n        ; Needs a lift, if possible\n        (let [strip-ns (fn [named]\n                         (if (symbol? named)\n                           (symbol nil (name named))\n                           (keyword nil (name named))))]\n          (loop [ns nil\n                 pair-seq pair-seq\n                 out []]\n            (let [[k & rest-of-pair :as pair] (first pair-seq)\n                  #_(println \"lift k:\" k \"rest-of-x-pair:\" rest-of-pair)\n                  current-ns\n                    (when (and ; This is at least a pair\n                            rest-of-pair\n                            ; It does not include an implicit ns\n                            (not (clojure.string/starts-with? (z/string k)\n                                                              \"::\"))\n                            (or (zkeyword? k) (zsymbol? k)))\n                      ; Is there an actual namespace on the key?\n                      (namespace (zloc-to-keyword k)))]\n              (if-not k\n                (when ns [(str \":\" ns) out])\n                (if current-ns\n                  (if ns\n                    (when (= ns current-ns)\n                      (recur ns\n                             (next pair-seq)\n                             (conj out\n                                   (cons (edn* (n/token-node (strip-ns (z/sexpr\n                                                                         k))))\n                                         rest-of-pair))))\n                    (recur current-ns\n                           (next pair-seq)\n                           (conj out\n                                 (cons (edn* (n/token-node (strip-ns (z/sexpr\n                                                                       k))))\n                                       rest-of-pair))))\n                  (when (= (count pair) 1)\n                    (recur ns (next pair-seq) (conj out pair)))))))))\n    (and ns unlift-ns? (not lift-ns?))\n      ; We have a namespace that was already lifted, and we want to unlift\n      ; it, and we didn't ask to have things lifted.  That last is so that\n      ; lift-ns? has to be false for unlift-ns? to work.\n      (loop [pair-seq pair-seq\n             out []]\n        (let [[k & rest-of-pair :as pair] (first pair-seq)\n              #_(println \"unlift k:\" k \"rest-of-y-pair:\" rest-of-pair)\n              current-ns (when (and ; This is at least a pair\n                                 rest-of-pair\n                                 ; It does not include an implicit ns\n                                 (not (clojure.string/starts-with? (z/string k)\n                                                                   \"::\"))\n                                 (or (zkeyword? k) (zsymbol? k)))\n                           ; Is there an actual namespace on the key?\n                           (namespace (zloc-to-keyword k)))\n              #_(println \"unlift k: namespace:\" current-ns)]\n          (if-not k\n            [nil out]\n            ; If we have a current-ns on a key, we can't unlift\n            (cond current-ns [ns pair-seq]\n                  ; We aren't going to unlift anything but a keyword\n                  (not (zkeyword? k)) [ns pair-seq]\n                  ; Skip single things\n                  (= (count pair) 1) (recur (next pair-seq) (conj out pair))\n                  :else\n                    (recur\n                      (next pair-seq)\n                      (conj out\n                            ; put ns with k\n                            (cons (edn* (n/token-node\n                                          (symbol\n                                            ; If k is a zkeyword? then it\n                                            ; is a :token, and will not\n                                            ; have a problem with z/sexpr\n                                            (str ns \"/\" (name (z/sexpr k))))))\n                                  rest-of-pair)))))))\n    :else [ns pair-seq]))\n\n;!zprint {:vector {:respect-nl? true}}\n(defn zredef-call\n  \"Redefine all of the traversal functions for zippers, then\n  call the function of no arguments passed in.\"\n  [body-fn]\n  (#?@(:bb [with-redefs]\n       :clj [do-redef-vars :zipper]\n       :cljs [with-redefs])\n   [zprint.zfns/zstring z/string\n    zprint.zfns/znumstr znumstr\n    zprint.zfns/zbyte-array? (constantly false)\n    zprint.zfns/zcomment? zcomment?\n    zprint.zfns/zsexpr sexpr\n    zprint.zfns/zsexpr? zsexpr?\n    zprint.zfns/zseqnws zseqnws\n    zprint.zfns/zseqnws-w-nl zseqnws-w-nl\n    zprint.zfns/zseqnws-w-bl zseqnws-w-bl\n    zprint.zfns/zfocus-style zfocus-style\n    zprint.zfns/zstart zstart\n    zprint.zfns/zfirst zfirst\n    zprint.zfns/zfirst-sexpr zfirst-sexpr\n    zprint.zfns/zsecond zsecond\n    zprint.zfns/zthird zthird\n    zprint.zfns/zfourth zfourth\n    zprint.zfns/znextnws zrightnws\n    zprint.zfns/znextnws-w-nl znextnws-w-nl\n    zprint.zfns/znthnext znthnext\n    zprint.zfns/zcount zcount\n    zprint.zfns/zcount-zloc-seq-nc-nws zcount-zloc-seq-nc-nws\n    zprint.zfns/zmap zmap\n    zprint.zfns/zmap-w-nl zmap-w-nl\n    zprint.zfns/zmap-w-bl zmap-w-bl\n    zprint.zfns/zmap-w-nl-comma zmap-w-nl-comma\n    zprint.zfns/zmap-no-comment zmap-no-comment\n    zprint.zfns/zanonfn? zanonfn?\n    zprint.zfns/zfn-obj? (constantly false)\n    zprint.zfns/zfocus zfocus\n    zprint.zfns/zfind-path find-root-and-path-nw\n    zprint.zfns/zwhitespace? whitespace?\n    zprint.zfns/zlist? z/list?\n    zprint.zfns/zvector? z/vector?\n    zprint.zfns/zmap? z/map?\n    zprint.zfns/znamespacedmap? znamespacedmap?\n    zprint.zfns/zset? z/set?\n    zprint.zfns/zcoll? z-coll?\n    zprint.zfns/zuneval? zuneval?\n    zprint.zfns/zmeta? zmeta?\n    zprint.zfns/ztag ztag\n    zprint.zfns/zlast zlast\n    zprint.zfns/zarray? (constantly false)\n    zprint.zfns/zatom? (constantly false)\n    zprint.zfns/zderef (constantly false)\n    zprint.zfns/zrecord? (constantly false)\n    zprint.zfns/zns? (constantly false)\n    zprint.zfns/zobj-to-vec (constantly nil)\n    zprint.zfns/zexpandarray (constantly nil)\n    zprint.zfns/znewline? znewline?\n    zprint.zfns/zwhitespaceorcomment? whitespace-or-comment?\n    zprint.zfns/zmap-all zmap-all\n    zprint.zfns/zpromise? (constantly false)\n    zprint.zfns/zfuture? (constantly false)\n    zprint.zfns/zdelay? (constantly false)\n    zprint.zfns/zkeyword? zkeyword?\n    zprint.zfns/zconstant? zconstant?\n    zprint.zfns/zagent? (constantly false)\n    zprint.zfns/zreader-macro? zreader-macro?\n    zprint.zfns/zarray-to-shift-seq (constantly nil)\n    zprint.zfns/zdotdotdot zdotdotdot\n    zprint.zfns/zsymbol? zsymbol?\n    zprint.zfns/znil? znil?\n    zprint.zfns/zreader-cond-w-symbol? zreader-cond-w-symbol?\n    zprint.zfns/zreader-cond-w-coll? zreader-cond-w-coll?\n    zprint.zfns/zlift-ns zlift-ns\n    zprint.zfns/zfind zfind\n    zprint.zfns/ztake-append ztake-append]\n   (body-fn)))","~:reader-features",["^U",["~:cljs"]],"~:cljc",true,"~:source-map-compact",["^ ","mappings","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","names",["zprint.zutil/whitespace?","zloc","cljs.core._EQ_","rewrite-clj.zip/tag","var_args","G__41642","zprint.zutil/skip-whitespace","js/Error","zprint.zutil.skip_whitespace","rewrite-clj.zip/right","f","rewrite-clj.zip/skip","zprint.zutil/whitespace-not-newline?","zprint.zutil/zremove","rewrite-clj.zip/remove","zprint.zutil/zreplace","rewrite-clj.zip/replace","zprint.zutil/zfocus","floc","vec__41648","cljs.core.nth","_","zpath","zprint.zutil/find-root-and-path","zprint.zutil/zfocus-style","style","zprint.zutil/z-coll?","rewrite-clj.zip/seq?","zprint.zutil/zuneval?","zprint.zutil/zmeta?","zprint.zutil/zquote?","zprint.zutil/zreader-macro?","zprint.zutil/ztag","zprint.zutil/znamespacedmap?","or__5045__auto__","cljs.core/re-find","rewrite-clj.zip/string","zprint.zutil/zcomment?","zprint.zutil/znewline?","zprint.zutil/znumstr","zprint.zutil/zstart","rewrite-clj.zip/down*","zprint.zutil/zfirst","nloc","rewrite-clj.zip/right*","zprint.zutil/zfirst-sexpr","p1__41692#","cljs.core/not","zprint.zutil/zsexpr?","zprint.zutil/zsecond","temp__5802__auto__","first-loc","zprint.zutil/zthird","G__41711","zprint.zutil/zfourth","G__41717","zprint.zutil/zrightnws","zprint.zutil/znextnws-w-nl","zprint.zutil/zrightmost","ploc","zprint.zutil/zleftnws","rewrite-clj.zip/left*","zprint.zutil/zleftmost","zprint.zutil/zprevnws","rewrite-clj.zip/prev*","zprint.zutil/znthnext","n","i","zprint.zutil/zfind","zthing?","zprint.zutil/znl","rewrite_clj.zip.edn_STAR_","rewrite-clj.parser/parse-string","zprint.zutil/multi-nl","cljs.core.apply","cljs.core/vector","cljs.core.repeat","zprint.zutil/split-newline-from-comment","comment-no-nl","clojure.string/replace-first","new-comment","rewrite-clj.zip/replace*","rewrite-clj.zip/insert-right*","zprint.zutil/zmap-w-bl","zfn","blank?","previous-was-nl?","previous-comment?","out","ws?","nl?","nl-len","rewrite-clj.zip/length","multi-nl?","emit-nl?","nl-to-emit","cljs.core.mapv","comment?","result","and__5043__auto__","cljs.core.conj","cljs.core/conj","zprint.zutil/zmap-w-nl","zprint.zutil/zmap-w-nl-comma","comma?","clojure.string/includes?","zprint.zutil/zmap","zprint.zutil/zmap-no-comment","zprint.zutil/zcount","zprint.zutil/zmap-all","zprint.zutil/zseqnws","cljs.core/identity","zprint.zutil/zseqnws-w-nl","zprint.zutil/zseqnws-w-bl","zprint.zutil/zremove-right","rewrite-clj.zip/rightmost?","G__41917","zprint.zutil/ztake-append","end-struct","index","rewrite-clj.zip/up*","xloc","zprint.zutil/zcount-zloc-seq-nc-nws","zloc-seq","p1__41936#","p2__41930#","cljs.core.reduce","rewrite-clj.zip/whitespace-or-comment?","left","cljs.core/cons","zprint.zutil/find-root-and-path-nw","zprint.zutil/find-root","rewrite-clj.zip/up","zprint.zutil/move-down-and-right","right-count","remaining-right","zprint.zutil/follow-path","path-vec","zprint.zutil/zanonfn?","zprint.zutil/zlast","cljs.core.not_EQ_","rewrite-clj.node/printable-only?","rewrite-clj.zip/node","zprint.zutil/zkeyword?","clojure.string/starts-with?","zprint.zutil/zsymbol?","cljs.core/Symbol","rewrite-clj.zip/sexpr","zprint.zutil/znil?","zprint.zutil/zreader-cond-w-symbol?","element","rewrite-clj.zip/down","zprint.zutil/zreader-cond-w-coll?","zprint.zutil/zdotdotdot","zprint.zutil/zconstant?","ztag","G__42007","sexpr","zprint.zutil/find-doc-in-map","zprint.zutil/find-docstring","fn-name","docloc","maploc","rewrite-clj.zip/map?","zprint.zutil/add-spec-to-docstring","spec-str","doc-zloc","new-doc-zloc","rewrite-clj.zip/root","zprint.zutil/zloc-to-keyword","s","cljs.core.keyword","cljs.core.subs","cljs.core.symbol","p__42049","map__42050","cljs.core/--destructure-map","cljs.core.get","zprint.zutil/zlift-ns","in-code?","lift-ns?","lift-ns-in-code?","unlift-ns?","map-options","pair-seq","ns","strip-ns","named","cljs.core/name","vec__42076","seq__42077","cljs.core/seq","first__42078","cljs.core/first","cljs.core/next","k","rest-of-pair","pair","current-ns","cljs.core/namespace","rewrite_clj.node.token_node","cljs.core/count","vec__42122","seq__42123","first__42124","zprint.zutil/zredef-call","body-fn","zstring-orig-val__42128","znumstr-orig-val__42129","zbyte-array?-orig-val__42130","zcomment?-orig-val__42131","zsexpr-orig-val__42132","zsexpr?-orig-val__42133","zseqnws-orig-val__42134","zseqnws-w-nl-orig-val__42135","zseqnws-w-bl-orig-val__42136","zfocus-style-orig-val__42137","zstart-orig-val__42138","zfirst-orig-val__42139","zfirst-sexpr-orig-val__42140","zsecond-orig-val__42141","zthird-orig-val__42142","zfourth-orig-val__42143","znextnws-orig-val__42144","znextnws-w-nl-orig-val__42145","znthnext-orig-val__42146","zcount-orig-val__42147","zcount-zloc-seq-nc-nws-orig-val__42148","zmap-orig-val__42149","zmap-w-nl-orig-val__42150","zmap-w-bl-orig-val__42151","zmap-w-nl-comma-orig-val__42152","zmap-no-comment-orig-val__42153","zanonfn?-orig-val__42154","zfn-obj?-orig-val__42155","zfocus-orig-val__42156","zfind-path-orig-val__42157","zwhitespace?-orig-val__42158","zlist?-orig-val__42159","zvector?-orig-val__42160","zmap?-orig-val__42162","znamespacedmap?-orig-val__42164","zset?-orig-val__42166","zcoll?-orig-val__42167","zuneval?-orig-val__42168","zmeta?-orig-val__42169","ztag-orig-val__42170","zlast-orig-val__42171","zarray?-orig-val__42172","zatom?-orig-val__42173","zderef-orig-val__42174","zrecord?-orig-val__42175","zns?-orig-val__42176","zobj-to-vec-orig-val__42177","zexpandarray-orig-val__42178","znewline?-orig-val__42179","zwhitespaceorcomment?-orig-val__42180","zmap-all-orig-val__42181","zpromise?-orig-val__42182","zfuture?-orig-val__42183","zdelay?-orig-val__42184","zkeyword?-orig-val__42185","zconstant?-orig-val__42186","zagent?-orig-val__42187","zreader-macro?-orig-val__42188","zarray-to-shift-seq-orig-val__42189","zdotdotdot-orig-val__42190","zsymbol?-orig-val__42191","znil?-orig-val__42192","zreader-cond-w-symbol?-orig-val__42193","zreader-cond-w-coll?-orig-val__42194","zlift-ns-orig-val__42195","zfind-orig-val__42196","ztake-append-orig-val__42197","zstring-temp-val__42208","znumstr-temp-val__42209","zbyte-array?-temp-val__42210","zcomment?-temp-val__42211","zsexpr-temp-val__42212","zsexpr?-temp-val__42213","zseqnws-temp-val__42214","zseqnws-w-nl-temp-val__42215","zseqnws-w-bl-temp-val__42216","zfocus-style-temp-val__42217","zstart-temp-val__42218","zfirst-temp-val__42219","zfirst-sexpr-temp-val__42220","zsecond-temp-val__42221","zthird-temp-val__42222","zfourth-temp-val__42223","znextnws-temp-val__42224","znextnws-w-nl-temp-val__42225","znthnext-temp-val__42226","zcount-temp-val__42227","zcount-zloc-seq-nc-nws-temp-val__42228","zmap-temp-val__42229","zmap-w-nl-temp-val__42230","zmap-w-bl-temp-val__42231","zmap-w-nl-comma-temp-val__42232","zmap-no-comment-temp-val__42233","zanonfn?-temp-val__42234","zfn-obj?-temp-val__42235","zfocus-temp-val__42236","zfind-path-temp-val__42237","zwhitespace?-temp-val__42238","zlist?-temp-val__42239","zvector?-temp-val__42240","zmap?-temp-val__42241","znamespacedmap?-temp-val__42242","zset?-temp-val__42243","zcoll?-temp-val__42244","zuneval?-temp-val__42245","zmeta?-temp-val__42246","ztag-temp-val__42247","zlast-temp-val__42248","zarray?-temp-val__42249","zatom?-temp-val__42250","zderef-temp-val__42251","zrecord?-temp-val__42252","zns?-temp-val__42253","zobj-to-vec-temp-val__42254","zexpandarray-temp-val__42255","znewline?-temp-val__42256","zwhitespaceorcomment?-temp-val__42257","zmap-all-temp-val__42258","zpromise?-temp-val__42259","zfuture?-temp-val__42260","zdelay?-temp-val__42261","zkeyword?-temp-val__42262","zconstant?-temp-val__42263","zagent?-temp-val__42264","zreader-macro?-temp-val__42265","zarray-to-shift-seq-temp-val__42266","zdotdotdot-temp-val__42267","zsymbol?-temp-val__42268","znil?-temp-val__42269","zreader-cond-w-symbol?-temp-val__42270","zreader-cond-w-coll?-temp-val__42271","zlift-ns-temp-val__42272","zfind-temp-val__42273","ztake-append-temp-val__42274","zprint.zfns/zstring","zprint.zfns/znumstr","zprint.zfns/zbyte-array?","cljs.core/constantly","zprint.zfns/zcomment?","zprint.zfns/zsexpr","zprint.zfns/zsexpr?","zprint.zfns/zseqnws","zprint.zfns/zseqnws-w-nl","zprint.zfns/zseqnws-w-bl","zprint.zfns/zfocus-style","zprint.zfns/zstart","zprint.zfns/zfirst","zprint.zfns/zfirst-sexpr","zprint.zfns/zsecond","zprint.zfns/zthird","zprint.zfns/zfourth","zprint.zfns/znextnws","zprint.zfns/znextnws-w-nl","zprint.zfns/znthnext","zprint.zfns/zcount","zprint.zfns/zcount-zloc-seq-nc-nws","zprint.zfns/zmap","zprint.zfns/zmap-w-nl","zprint.zfns/zmap-w-bl","zprint.zfns/zmap-w-nl-comma","zprint.zfns/zmap-no-comment","zprint.zfns/zanonfn?","zprint.zfns/zfn-obj?","zprint.zfns/zfocus","zprint.zfns/zfind-path","zprint.zfns/zwhitespace?","zprint.zfns/zlist?","rewrite-clj.zip/list?","zprint.zfns/zvector?","rewrite-clj.zip/vector?","zprint.zfns/zmap?","zprint.zfns/znamespacedmap?","zprint.zfns/zset?","rewrite-clj.zip/set?","zprint.zfns/zcoll?","zprint.zfns/zuneval?","zprint.zfns/zmeta?","zprint.zfns/ztag","zprint.zfns/zlast","zprint.zfns/zarray?","zprint.zfns/zatom?","zprint.zfns/zderef","zprint.zfns/zrecord?","zprint.zfns/zns?","zprint.zfns/zobj-to-vec","zprint.zfns/zexpandarray","zprint.zfns/znewline?","zprint.zfns/zwhitespaceorcomment?","zprint.zfns/zmap-all","zprint.zfns/zpromise?","zprint.zfns/zfuture?","zprint.zfns/zdelay?","zprint.zfns/zkeyword?","zprint.zfns/zconstant?","zprint.zfns/zagent?","zprint.zfns/zreader-macro?","zprint.zfns/zarray-to-shift-seq","zprint.zfns/zdotdotdot","zprint.zfns/zsymbol?","zprint.zfns/znil?","zprint.zfns/zreader-cond-w-symbol?","zprint.zfns/zreader-cond-w-coll?","zprint.zfns/zlift-ns","zprint.zfns/zfind","zprint.zfns/ztake-append"]],"~:used-vars",["^U",["~$zprint.zfns/zdotdotdot","~$cljs.core/--destructure-map","~$clojure.string/replace-first","~$zprint.zfns/znthnext","~$zprint.zfns/zseqnws","~$zprint.zfns/zset?","~$zprint.zfns/zlift-ns","~$zprint.zutil/zcount-zloc-seq-nc-nws","~$rewrite-clj.zip/up","~$cljs.core/keyword","~$zprint.zutil/z-coll?","~$zprint.zutil/znamespacedmap?","~$rewrite-clj.zip/whitespace-or-comment?","~$zprint.zfns/zmeta?","~$clojure.string/starts-with?","~$zprint.zutil/zanonfn?","~$zprint.zutil/zkeyword?","~$zprint.zutil/zreader-cond-w-coll?","~$zprint.zutil/zseqnws-w-nl","~$zprint.zfns/zsexpr","~$zprint.zutil/zremove-right","~$zprint.zutil/zcomment?","~$zprint.zfns/zbyte-array?","~$zprint.zfns/zobj-to-vec","~$zprint.zutil/zmap-w-nl-comma","~$rewrite-clj.zip/left*","~$zprint.zutil/zreader-cond-w-symbol?","~$zprint.zfns/zcount","~$rewrite-clj.zip/up*","~$cljs.core/=","~$zprint.zfns/zstart","~$zprint.zutil/znextnws-w-nl","~$rewrite-clj.zip/sexpr","~$zprint.zfns/zmap-all","~$zprint.zfns/znextnws","~$zprint.zfns/zfocus-style","~$rewrite-clj.zip/map?","~$zprint.zfns/zseqnws-w-bl","~$rewrite-clj.zip/down*","~$zprint.zutil/zleftmost","~$zprint.zutil/whitespace?","~$rewrite-clj.zip/down","~$rewrite-clj.zip/string","~$rewrite-clj.zip/node","~$zprint.zfns/zstring","~$cljs.core/count","~$zprint.zutil/zrightmost","~$zprint.zutil/zconstant?","~$cljs.core/reduce","~$cljs.core/seq","~$rewrite-clj.zip/replace*","~$zprint.zutil/find-root-and-path","~$cljs.core/apply","~$zprint.zfns/zmap-w-bl","~$zprint.zutil/zremove","~$zprint.zutil/zreplace","~$rewrite-clj.zip/edn*","~$cljs.core/identity","~$zprint.zutil/zfirst-sexpr","~$zprint.zutil/zprevnws","~$zprint.zfns/znextnws-w-nl","~$zprint.zfns/zfuture?","~$zprint.zfns/zmap-w-nl","~$cljs.core/mapv","~$cljs.core/not=","~$zprint.zfns/zns?","~$zprint.zutil/ztake-append","~$zprint.zutil/follow-path","~$rewrite-clj.zip/insert-right*","~$rewrite-clj.zip/prev*","~$zprint.zutil/znewline?","~$zprint.zutil/split-newline-from-comment","~$zprint.zutil/zlast","~$zprint.zutil/zfourth","~$zprint.zfns/znumstr","~$clojure.string/includes?","~$zprint.zutil/zsymbol?","~$zprint.zfns/zexpandarray","~$zprint.zfns/zreader-cond-w-symbol?","~$zprint.zfns/zwhitespaceorcomment?","~$zprint.zutil/zdotdotdot","~$zprint.zutil/znthnext","~$zprint.zutil/multi-nl","~$zprint.zutil/znil?","~$zprint.zutil/add-spec-to-docstring","~$zprint.zfns/zthird","~$zprint.zutil/zfocus","~$cljs.core/conj","~$rewrite-clj.zip/list?","~$zprint.zutil/zfirst","~$zprint.zfns/zcoll?","~$cljs.core/namespace","~$rewrite-clj.node/token-node","~$zprint.zutil/zmeta?","~$zprint.zfns/ztag","~$zprint.zfns/zmap","~$zprint.zfns/znil?","~$zprint.zutil/zstart","~$rewrite-clj.zip/length","~$rewrite-clj.zip/right*","~$zprint.zutil/zrightnws","~$zprint.zfns/zdelay?","~$zprint.zutil/znumstr","~$zprint.zfns/zfind-path","~$zprint.zfns/zsymbol?","~$cljs.core/get","~$zprint.zutil/zcount","~$cljs.core/constantly","~$zprint.zutil/znl","~$zprint.zutil/find-root-and-path-nw","~$zprint.zutil/zreader-macro?","~$zprint.zfns/zfind","~$zprint.zutil/zmap-w-bl","~$zprint.zfns/zuneval?","~$zprint.zutil/zredef-call","~$zprint.zfns/zfirst","~$zprint.zutil/zsexpr?","~$zprint.zutil/zseqnws-w-bl","~$rewrite-clj.zip/tag","~$rewrite-clj.zip/right","~$cljs.core/symbol","~$rewrite-clj.zip/seq?","~$zprint.zfns/znewline?","~$cljs.core/re-find","~$zprint.zfns/zlist?","~$zprint.zfns/zcount-zloc-seq-nc-nws","~$zprint.zfns/zfourth","~$zprint.zutil/zsecond","~$zprint.zfns/zarray?","~$rewrite-clj.zip/skip","~$zprint.zutil/zmap-no-comment","~$rewrite-clj.zip/root","~$cljs.core/nth","~$zprint.zutil/zlift-ns","~$zprint.zutil/skip-whitespace","~$zprint.zfns/zcomment?","~$zprint.zutil/move-down-and-right","~$zprint.zfns/zmap-w-nl-comma","~$zprint.zfns/zatom?","~$zprint.zutil/zthird","~$zprint.zutil/whitespace-not-newline?","~$rewrite-clj.parser/parse-string","~$zprint.zfns/zanonfn?","~$zprint.zfns/zkeyword?","~$cljs.core/next","~$zprint.zfns/zseqnws-w-nl","~$zprint.zfns/znamespacedmap?","~$zprint.zfns/zderef","~$zprint.zutil/zleftnws","~$zprint.zutil/find-docstring","~$cljs.core/not","~$zprint.zfns/zpromise?","~$zprint.zfns/zmap-no-comment","~$zprint.zfns/zsecond","~$zprint.zfns/zfn-obj?","~$cljs.core/cons","~$zprint.zfns/zreader-cond-w-coll?","~$zprint.zutil/zfocus-style","~$rewrite-clj.zip/remove","~$zprint.zfns/zconstant?","~$cljs.core/Symbol","~$zprint.zutil/ztag","~$zprint.zfns/zrecord?","~$zprint.zutil/zmap-all","~$zprint.zfns/zfocus","~$zprint.zutil/zmap","~$zprint.zfns/zagent?","~$cljs.core/repeat","~$zprint.zutil/zloc-to-keyword","~$zprint.zfns/zsexpr?","~$zprint.zfns/zarray-to-shift-seq","~$rewrite-clj.zip/vector?","~$cljs.core/first","~$zprint.zfns/ztake-append","~$rewrite-clj.node/printable-only?","~$zprint.zfns/zreader-macro?","~$zprint.zfns/zmap?","~$zprint.zfns/zfirst-sexpr","~$rewrite-clj.zip/set?","~$zprint.zfns/zwhitespace?","~$zprint.zutil/find-doc-in-map","~$zprint.zutil/zseqnws","~$cljs.core/name","~$cljs.core/subs","~$zprint.zfns/zvector?","~$zprint.zutil/zquote?","~$js/Error","~$zprint.zfns/zlast","~$cljs.core/vector","~$rewrite-clj.zip/replace","~$zprint.zutil/find-root","~$zprint.zutil/zuneval?","~$zprint.zutil/zfind","~$rewrite-clj.zip/rightmost?","~$zprint.zutil/zmap-w-nl"]]],"~:cache-keys",["~#cmap",[["^1V","rewrite_clj/zip/options.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","~:shadow.build.compiler/resolve",["^ ","~:require-id",null,"~:deps-ids",["^U",[]],"~:deps-syms",["^15","^14","~$rewrite-clj.node.protocols"]]],["^1V","goog/dom/tagname.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","~$goog.dom.HtmlElement"]]],["^1V","rewrite_clj/zip/walk.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","~$rewrite-clj.zip.move","~$rewrite-clj.zip.subedit"]]],["^1V","cljs/tools/reader/impl/utils.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","^17","~$goog.string"]]],["^1V","rewrite_clj/node/reader_macro.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","^6O","~$rewrite-clj.node.whitespace"]]],["^1V","rewrite_clj/parser.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","~$rewrite-clj.node.forms","~$rewrite-clj.parser.core","~$rewrite-clj.reader"]]],["^1V","goog/html/trustedtypes.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15"]]],["^1V","goog/string/stringformat.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^6S"]]],["^1V","goog/labs/useragent/browser.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","~$goog.array","~$goog.object","~$goog.labs.userAgent.util","~$goog.string.internal"]]],["^1V","goog/html/safeurl.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","~$goog.asserts","~$goog.fs.url","~$goog.html.TrustedResourceUrl","~$goog.i18n.bidi.Dir","~$goog.i18n.bidi.DirectionalString","~$goog.string.Const","~$goog.string.TypedString","^6["]]],["^1V","goog/array/array.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^70"]]],["^1V","rewrite_clj/parser/whitespace.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","^6T","^6W"]]],["^1V","rewrite_clj/node/regex.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","^6O"]]],["^1V","goog/debug/error.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15"]]],["^1V","cljs/tools/reader/edn.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","^F","^J","^@","^D","~$cljs.tools.reader","^6S","~$goog.string.StringBuffer"]]],["^1V","goog/dom/nodetype.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15"]]],["^1V","cljs/tools/reader/impl/inspect.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14"]]],["^1V","cljs/tools/reader.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","^J","^@","^D","^F","^6X","^6S","^78"]]],["^1V","rewrite_clj/zip/base.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","~$rewrite-clj.custom-zipper.core","^6U","^6O","^11","~$rewrite-clj.zip.options","~$rewrite-clj.zip.whitespace"]]],["^1V","rewrite_clj/zip/editz.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","^79","~$rewrite-clj.custom-zipper.utils","^6O","~$rewrite-clj.node.token","^6T","~$rewrite-clj.zip.base","^7:","~$rewrite-clj.zip.removez","^7;"]]],["^1V","rewrite_clj/parser/token.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","^7=","^6W"]]],["^1V","rewrite_clj/node/uneval.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","^6O"]]],["^1V","goog/string/typedstring.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15"]]],["^1V","rewrite_clj/parser/keyword.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","~$rewrite-clj.node.keyword","^6W"]]],["^1V","rewrite_clj/zip/seqz.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","^79","^7>","~$rewrite-clj.zip.editz","~$rewrite-clj.zip.findz","~$rewrite-clj.zip.insert","^6Q"]]],["^1V","goog/object/object.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15"]]],["^1V","goog/dom/asserts.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^70"]]],"~:SHADOW-TIMESTAMP",[1666857604000,1666857604000,1666857293000],["^1V","rewrite_clj/node/keyword.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","^6O"]]],["^1V","rewrite_clj/node/token.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","^6O"]]],["^1V","goog/math/long.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^70","~$goog.reflect"]]],["^1V","goog/html/trustedresourceurl.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^70","~$goog.fs.blob","^71","~$goog.html.SafeScript","~$goog.html.trustedtypes","^73","^74","^75","^76"]]],["^1V","rewrite_clj/node.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","~$rewrite-clj.node.coercer","~$rewrite-clj.node.comment","~$rewrite-clj.node.extras","~$rewrite-clj.node.fn","^6U","~$rewrite-clj.node.integer","^7@","~$rewrite-clj.node.meta","~$rewrite-clj.node.namespaced-map","^6O","~$rewrite-clj.node.quote","~$rewrite-clj.node.reader-macro","~$rewrite-clj.node.regex","~$rewrite-clj.node.seq","~$rewrite-clj.node.stringz","^7=","~$rewrite-clj.node.uneval","^6T"]]],["^1V","rewrite_clj/node/comment.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","^6O"]]],["^1V","rewrite_clj/zip/subedit.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","^79","^7>","^7:"]]],["^1V","goog/string/internal.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15"]]],["^1V","goog/functions/functions.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15"]]],["^1V","rewrite_clj/parser/string.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","^17","^7T","^6W","^78"]]],["^1V","goog/html/safestyle.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^75","~$goog.html.SafeUrl","^76","^70","^6["]]],["^1V","goog/dom/safe.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^70","~$goog.dom.asserts","~$goog.functions","~$goog.html.SafeHtml","^7G","~$goog.html.SafeStyle","^7V","^72","~$goog.html.uncheckedconversions","^75","^6["]]],["^1V","rewrite_clj/zip/removez.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","^79","^7<","^6Q","^7;"]]],["^1V","clojure/walk.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14"]]],["^1V","goog/html/safehtml.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^75","^73","^74","^7G","^7Z","~$goog.html.SafeStyleSheet","^7V","~$goog.dom.TagName","^72","^76","^70","~$goog.labs.userAgent.browser","^6X","^6Y","^6[","~$goog.dom.tags","^7H"]]],["^1V","rewrite_clj/node/forms.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","^6O"]]],["^1V","goog/dom/tags.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^6Y"]]],["^1V","rewrite_clj/node/integer.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","~$rewrite-clj.interop","^6O"]]],["^1V","rewrite_clj/parser/core.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","^7J","^7L","^7N","^6O","^7P","^7Q","^7R","^7S","^7=","^7U","~$rewrite-clj.parser.keyword","~$rewrite-clj.parser.namespaced-map","~$rewrite-clj.parser.string","~$rewrite-clj.parser.token","~$rewrite-clj.parser.whitespace","^6W"]]],["^1V","rewrite_clj/node/fn.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","^17","~$clojure.walk","^84","^6O"]]],["^1V","goog/fs/blob.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15"]]],["^1V","rewrite_clj/node/protocols.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","^17","^84"]]],["^1V","goog/asserts/asserts.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","~$goog.debug.Error","~$goog.dom.NodeType"]]],["^1V","zprint/zutil.cljc"],["6c7de285c399d67aaa77693a88b73d129953fa1f","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","^17","^16","^11","^12","^13"]]],["^1V","rewrite_clj/zip/whitespace.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","^79","^7J","^7K","^6T"]]],["^1V","goog/uri/uri.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^6X","^70","~$goog.collections.maps","^6S","~$goog.structs","~$goog.uri.utils","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"]]],["^1V","rewrite_clj/node/meta.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","^84","^6O","^6T"]]],["^1V","rewrite_clj/node/stringz.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","^17","^L","^6O"]]],["^1V","rewrite_clj/parser/namespaced_map.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","^7O","^6O","^6T","^6W"]]],["^1V","goog/collections/maps.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15"]]],["^1V","rewrite_clj/node/whitespace.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","^6O","^6W"]]],["^1V","goog/i18n/bidi.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15"]]],["^1V","rewrite_clj/zip/move.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","^79","^7;"]]],["^1V","goog/fs/url.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15"]]],["^1V","rewrite_clj/node/quote.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","^6O"]]],["^1V","goog/base.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",[]]],["^1V","goog/structs/structs.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^6X","^6Y"]]],["^1V","cljs/tools/reader/impl/errors.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","^J","^17","~$cljs.tools.reader.impl.inspect"]]],["^1V","rewrite_clj/zip/context.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","^79","^6O","~$rewrite-clj.zip.seqz","~$rewrite-clj.zip.walk"]]],["^1V","clojure/string.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","^6S","^78"]]],["^1V","rewrite_clj/zip/findz.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","^79","^7>","^6Q"]]],["^1V","rewrite_clj/zip.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","^79","^7I","^7>","~$rewrite-clj.zip.context","^7A","^7B","^7C","^6Q","^7?","^8C","^6R","^8D","^7;"]]],["^1V","rewrite_clj/zip/insert.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","^79","^6O","^6T","^7;"]]],["^1V","zprint/zfns.cljc"],["6c7de285c399d67aaa77693a88b73d129953fa1f","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14"]]],["^1V","rewrite_clj/node/namespaced_map.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","^6O"]]],["^1V","goog/string/string.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","~$goog.dom.safe","^7[","^75","^6["]]],["^1V","rewrite_clj/custom_zipper/core.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","~$clojure.zip","~$rewrite-clj.custom-zipper.switchable","^6O"]]],["^1V","goog/reflect/reflect.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15"]]],["^1V","goog/labs/useragent/util.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","~$goog.labs.userAgent","^6["]]],["^1V","clojure/zip.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14"]]],["^1V","goog/string/stringbuffer.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15"]]],["^1V","cljs/tools/reader/reader_types.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","^@","^6S","^78"]]],["^1V","rewrite_clj/reader.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","^L","^D","^F","^@","^J","^84","^78"]]],["^1V","goog/labs/useragent/useragent.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15"]]],["^1V","rewrite_clj/custom_zipper/utils.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","^79"]]],["^1V","rewrite_clj/node/coercer.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","^17","^7J","^7L","^6U","^7M","^7@","^7N","^7O","^6O","^7P","^7Q","^7R","^7S","^7T","^7=","^7U","^6T"]]],["^1V","goog/html/uncheckedconversions.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^70","^7Y","^7G","^7Z","^80","^7V","^72","^75","^6[","^73"]]],["^1V","cljs/tools/reader/impl/commons.cljs"],["927809dcb44fa726e4969d993e3e733636d95ebb","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","^F","^J","^@"]]],["^1V","goog/dom/htmlelement.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15"]]],["^1V","cljs/core.cljs"],["bc14df6666853ed869d7b88aaa864111c65d0c7f","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","~$goog.math.Long","~$goog.math.Integer","^6S","^6Y","^6X","~$goog.Uri","^78"]]],["^1V","rewrite_clj/custom_zipper/switchable.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14"]]],["^1V","goog/html/safescript.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^75","^76","^7H","^70"]]],["^1V","rewrite_clj/node/extras.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","^7J","^6T"]]],["^1V","goog/html/safestylesheet.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^75","^7Z","^76","^6Y","^70","^6["]]],["^1V","goog/math/integer.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^7E"]]],["^1V","goog/uri/utils.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^70","^6S"]]],["^1V","goog/string/const.js"],["e7c400433b3c1fadb574d4cc5a65cddccff5500f","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^70","^76"]]],["^1V","rewrite_clj/interop.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","^6S","~$goog.string.format"]]],["^1V","rewrite_clj/node/seq.cljc"],["3744f553562a31e10c2a7cd37758888e3b691f01","^6K",["^ ","^6L",null,"^6M",["^U",[]],"^6N",["^15","^14","^84","^6O"]]]]],"~:clj-info",["^ ","jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/string.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/impl/errors.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/env.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/default_data_readers.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/core.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/edn.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/reader.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/reader_types.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/util.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/compiler.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/tools/reader/impl/inspect.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/edn.clj",1666857280000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/passes/and_or.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/pprint.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map/base64_vlq.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/set.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/reader_types.clj",1666857280000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/node/protocols.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/instant.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map/base64.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/interop.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/impl/utils.clj",1666857280000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/custom_zipper/core.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/externs.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/zip.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/impl/commons.clj",1666857280000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/js_deps.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/binaryage/devtools/1.0.6/devtools-1.0.6.jar!/devtools/defaults.clj",1666857314000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/java/io.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/impl/inspect.clj",1666857280000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/source_map.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/node/comment.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/parser.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/node/whitespace.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/zip/whitespace.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/impl.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/custom_zipper/switchable.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/node/forms.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/tagged_literals.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojure/1.11.1/clojure-1.11.1.jar!/clojure/core.clj",1663156501000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/zip/subedit.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/parser/core.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/passes.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/node/extras.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/vendor/clojure/data/json.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/zip/options.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/instant.clj",1666857293000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/clojurescript/1.11.60/clojurescript-1.11.60.jar!/cljs/analyzer/impl/namespaces.cljc",1666857293000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/zip.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/rewrite-clj/rewrite-clj/1.0.699-alpha/rewrite-clj-1.0.699-alpha.jar!/rewrite_clj/zip/base.cljc",1666857316000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/clojure/tools/reader/impl/errors.clj",1666857280000,"jar:file:/Users/aleksey/.m2/repository/org/clojure/tools.reader/1.3.6/tools.reader-1.3.6.jar!/cljs/tools/reader/reader_types.clj",1666857280000],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","zprint/zutil.cljc","^7",2,"^8",14,"^9",2,"^:",26,"^;",true],"^<",["^ ","^=","^>","^?","^@","^A","^B","^C","^D","^E","^F","^G","^H","^I","^J","^K","^L","^M","^N","^O","^P","^Q","^R"],"^S",null,"^T",["^U",[]],"^V","^W","^X",["^ "],"^[",null,"^10",["^ ","^11","^11","~$p","^11","^12","^12","^13","^13","^14","^14","^15","^15","^16","^16","~$n","^12","~$z","^13","^17","^17"],"^18",["^U",["^19"]],"~:shadow/js-access-global",["^U",["Error"]],"^1:",["^ ","^1;","^13","^1<","^13","^1=","^13","^1>","^13","^1?","^13","^1@","^13","^1A","^13","^1B","^13","^1C","^13","^1D","^13","^1E","^13","^1F","^13","^1G","^13","^1H","^13","^1I","^13","^1J","^13","^1K","^13"],"~:defs",["^ ","~$zcount-zloc-seq-nc-nws",["^ ","~:protocol-inline",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",454,"^8",7,"^9",454,"^:",29,"~:arglists",["^1N",["~$quote",["^1N",[["~$zloc-seq"]]]]],"~:doc","How many non-whitespace non-comment children are in zloc-seq? Note\n  that this is fundamentally different from zcount, in that it doesn't\n  take a zloc, but rather a zloc-seq (i.e., a seq of elements, each of\n  which is a zloc)."],"^V","^2=","^6","zprint/zutil.cljc","^:",29,"~:method-params",["^1N",[["^:4"]]],"~:protocol-impl",null,"~:arglists-meta",["^1N",[null,null]],"^8",1,"~:variadic?",false,"^7",454,"~:ret-tag",["^U",[null,"~$any"]],"^9",454,"~:max-fixed-arity",1,"~:fn-var",true,"^:2",["^1N",["^:3",["^1N",[["^:4"]]]]],"^:5","How many non-whitespace non-comment children are in zloc-seq? Note\n  that this is fundamentally different from zcount, in that it doesn't\n  take a zloc, but rather a zloc-seq (i.e., a seq of elements, each of\n  which is a zloc)."],"~$zreader-cond-w-symbol?",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",551,"^8",7,"^9",551,"^:",29,"^:2",["^1N",["^:3",["^1N",[["~$zloc"]]]]],"^:5","Returns true if this is a reader-conditional with a symbol in \n  the first position (could be :clj or :cljs, whatever)."],"^V","^2P","^6","zprint/zutil.cljc","^:",29,"^:6",["^1N",[["^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",551,"^::",["^U",[null,"~$boolean","~$clj-nil"]],"^9",551,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Returns true if this is a reader-conditional with a symbol in \n  the first position (could be :clj or :cljs, whatever)."],"~$z-coll?",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",58,"^8",7,"^9",58,"^:",14,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Is the zloc a collection?"],"^V","^2@","^6","zprint/zutil.cljc","^:",14,"^:6",["^1N",[["^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",58,"^::","^:@","^9",58,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Is the zloc a collection?"],"~$zleftmost",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",164,"^8",7,"^9",164,"^:",16,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Find the leftmost non-whitespace zloc at this level"],"^V","^31","^6","zprint/zutil.cljc","^:",16,"^:6",["^1N",[["^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",164,"^::","^:;","^9",164,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Find the leftmost non-whitespace zloc at this level"],"~$whitespace?",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",21,"^8",7,"^9",21,"^:",18,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]]],"^V","^32","^6","zprint/zutil.cljc","^:",18,"^:6",["^1N",[["^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",21,"^::","^:@","^9",21,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]]],"~$zremove-right",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",434,"^8",7,"^9",434,"^:",20,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Remove everything to the right of the current zloc. In other words,\n  make the current zloc the rightmost."],"^V","^2J","^6","zprint/zutil.cljc","^:",20,"^:6",["^1N",[["^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",434,"^9",434,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Remove everything to the right of the current zloc. In other words,\n  make the current zloc the rightmost."],"~$zmap-w-nl-comma",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",314,"^8",7,"^9",314,"^:",22,"^:2",["^1N",["^:3",["^1N",[["~$zfn","^:?"]]]]],"^:5","Return a vector containing the return of applying a function to\n  every non-whitespace zloc inside of zloc, including newlines and commas.\n  This will also split newlines into separate zlocs if they were\n  multiple, and split the newline off the end of a comment."],"^V","^2N","^6","zprint/zutil.cljc","^:",22,"^:6",["^1N",[["^:G","^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",314,"^::","^:;","^9",314,"^:<",2,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:G","^:?"]]]]],"^:5","Return a vector containing the return of applying a function to\n  every non-whitespace zloc inside of zloc, including newlines and commas.\n  This will also split newlines into separate zlocs if they were\n  multiple, and split the newline off the end of a comment."],"~$zcomment?",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",80,"^8",7,"^9",80,"^:",16,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Returns true if this is a comment."],"^V","^2K","^6","zprint/zutil.cljc","^:",16,"^:6",["^1N",[["^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",80,"^::",["^U",["^:@","^:A"]],"^9",80,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Returns true if this is a comment."],"~$znamespacedmap?",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",73,"^8",7,"^9",73,"^:",22,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Is this a namespaced map?"],"^V","^2A","^6","zprint/zutil.cljc","^:",22,"^:6",["^1N",[["^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",73,"^::",["^U",["~$clj","^:@","~$cljs.core/IVector","^:;","~$cljs.core/MetaFn","^:A"]],"^9",73,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Is this a namespaced map?"],"~$zanonfn?",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",510,"^8",7,"^9",510,"^:",15,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Is this an anonymous fn?"],"^V","^2E","^6","zprint/zutil.cljc","^:",15,"^:6",["^1N",[["^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",510,"^::","^:@","^9",510,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Is this an anonymous fn?"],"~$zkeyword?",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",534,"^8",7,"^9",534,"^:",16,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Returns true if this is a keyword."],"^V","^2F","^6","zprint/zutil.cljc","^:",16,"^:6",["^1N",[["^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",534,"^::",["^U",[null,"^:@"]],"^9",534,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Returns true if this is a keyword."],"~$zseqnws-w-nl",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",422,"^8",7,"^9",422,"^:",19,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Return a seq of all of the non-whitespace children of zloc, including\n  newlines."],"^V","^2H","^6","zprint/zutil.cljc","^:",19,"^:6",["^1N",[["^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",422,"^::","^:;","^9",422,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Return a seq of all of the non-whitespace children of zloc, including\n  newlines."],"~$zremove",["^ ","^V","^3@","^6","zprint/zutil.cljc","^7",36,"^8",1,"^9",36,"^:",13,"^5",["^ ","^6","zprint/zutil.cljc","^7",36,"^8",6,"^9",36,"^:",13]],"~$znextnws-w-nl",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",144,"^8",7,"^9",144,"^:",20,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Find the next non-whitespace zloc inside of this zloc considering \n  newlines to not be whitespace. Returns nil if nothing left. Which is\n  why this is nextnws and not rightnws, since it is exposed in zfns."],"^V","^2U","^6","zprint/zutil.cljc","^:",20,"^:6",["^1N",[["^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",144,"^::",["^U",["^:;","^:A"]],"^9",144,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Find the next non-whitespace zloc inside of this zloc considering \n  newlines to not be whitespace. Returns nil if nothing left. Which is\n  why this is nextnws and not rightnws, since it is exposed in zfns."],"~$zrightmost",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",152,"^8",7,"^9",152,"^:",17,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Find the rightmost non-whitespace zloc at this level"],"^V","^38","^6","zprint/zutil.cljc","^:",17,"^:6",["^1N",[["^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",152,"^::","^:;","^9",152,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Find the rightmost non-whitespace zloc at this level"],"~$zconstant?",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",584,"^8",7,"^9",584,"^:",17,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Returns true if this is a keyword, string, or number, in other words,\n  a constant."],"^V","^39","^6","zprint/zutil.cljc","^:",17,"^:6",["^1N",[["^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",584,"^::",["^U",[null,"^:@","^:;","^:A"]],"^9",584,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Returns true if this is a keyword, string, or number, in other words,\n  a constant."],"~$find-root-and-path",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",462,"^8",7,"^9",462,"^:",25,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Create a vector with the root as well as another vector\n  which contains the number of right moves after each down\n  down to find a particular zloc.  The right moves include\n  both whitespace and comments."],"^V","^3=","^6","zprint/zutil.cljc","^:",25,"^:6",["^1N",[["^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",462,"^::",["^U",["^:K","^:A"]],"^9",462,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Create a vector with the root as well as another vector\n  which contains the number of right moves after each down\n  down to find a particular zloc.  The right moves include\n  both whitespace and comments."],"~$zreplace",["^ ","^V","^3A","^6","zprint/zutil.cljc","^7",38,"^8",1,"^9",38,"^:",14,"^5",["^ ","^6","zprint/zutil.cljc","^7",38,"^8",6,"^9",38,"^:",14]],"~$find-docstring",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",621,"^8",7,"^9",621,"^:",21,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Find a docstring in a zipper of a function."],"^V","^5G","^6","zprint/zutil.cljc","^:",21,"^:6",["^1N",[["^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",621,"^::",["^U",["^:;","^:A"]],"^9",621,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Find a docstring in a zipper of a function."],"~$zfourth",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",127,"^8",7,"^9",127,"^:",14,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Find the fourth non-whitespace zloc inside of this zloc."],"^V","^3S","^6","zprint/zutil.cljc","^:",14,"^:6",["^1N",[["^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",127,"^::",["^U",["^:;","^:A"]],"^9",127,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Find the fourth non-whitespace zloc inside of this zloc."],"~$znewline?",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",85,"^8",7,"^9",85,"^:",16,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Returns true if this is a newline."],"^V","^3P","^6","zprint/zutil.cljc","^:",16,"^:6",["^1N",[["^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",85,"^::",["^U",["^:@","^:A"]],"^9",85,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Returns true if this is a newline."],"~$ztake-append",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",441,"^8",7,"^9",441,"^:",19,"^:2",["^1N",["^:3",["^1N",[["~$n","^:?","~$end-struct"]]]]],"^:5","Considering the current zloc a collection, move down into it and\n  take n non-whitespace elements, dropping the rest.  Then append the\n  given element to the end, coercing it into a node/zloc.  Note, this \n  is not quite implemented that way, as it uses replace."],"^V","^3L","^6","zprint/zutil.cljc","^:",19,"^:6",["^1N",[["~$n","^:?","^:Z"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",441,"^::",["^U",["^:J","^:;","^:L","^:A"]],"^9",441,"^:<",3,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["~$n","^:?","^:Z"]]]]],"^:5","Considering the current zloc a collection, move down into it and\n  take n non-whitespace elements, dropping the rest.  Then append the\n  given element to the end, coercing it into a node/zloc.  Note, this \n  is not quite implemented that way, as it uses replace."],"~$follow-path",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",504,"^8",7,"^9",504,"^:",18,"^:2",["^1N",["^:3",["^1N",[["~$path-vec","^:?"]]]]],"^:5","Follow the path vector from the root and return the zloc\n  at this location."],"^V","^3M","^6","zprint/zutil.cljc","^:",18,"^:6",["^1N",[["^;0","^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",504,"^::",["^U",[null,"^:;"]],"^9",504,"^:<",2,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^;0","^:?"]]]]],"^:5","Follow the path vector from the root and return the zloc\n  at this location."],"~$zfirst-sexpr",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",107,"^8",7,"^9",107,"^:",19,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Find the first sexpr-able? zloc inside of this zloc."],"^V","^3D","^6","zprint/zutil.cljc","^:",19,"^:6",["^1N",[["^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",107,"^::",["^U",["^:;","^:A"]],"^9",107,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Find the first sexpr-able? zloc inside of this zloc."],"~$zprevnws",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",179,"^8",7,"^9",179,"^:",15,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Find the next non-whitespace zloc."],"^V","^3E","^6","zprint/zutil.cljc","^:",15,"^:6",["^1N",[["^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",179,"^::",["^U",["^:;","^:A"]],"^9",179,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Find the next non-whitespace zloc."],"~$multi-nl",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",202,"^8",7,"^9",202,"^:",15,"^:2",["^1N",["^:3",["^1N",[["~$n"]]]]],"^:5","Return a sequence of zloc newlines."],"^V","^40","^6","zprint/zutil.cljc","^:",15,"^:6",["^1N",[["~$n"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",202,"^::","^:;","^9",202,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["~$n"]]]]],"^:5","Return a sequence of zloc newlines."],"~$split-newline-from-comment",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",207,"^8",7,"^9",207,"^:",33,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Given a zloc which is a comment, replace it with a zloc which is the\n  same comment with no newline, and a newline that follows it.  This is\n  done in the zipper so that later navigation in this area remains\n  continues to work."],"^V","^3Q","^6","zprint/zutil.cljc","^:",33,"^:6",["^1N",[["^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",207,"^::",["^U",["^:J","^:;","^:L","^:A"]],"^9",207,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Given a zloc which is a comment, replace it with a zloc which is the\n  same comment with no newline, and a newline that follows it.  This is\n  done in the zipper so that later navigation in this area remains\n  continues to work."],"~$zlast",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",512,"^8",7,"^9",512,"^:",12,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Return the last non-whitespace (but possibly comment) element inside\n  of this zloc."],"^V","^3R","^6","zprint/zutil.cljc","^:",12,"^:6",["^1N",[["^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",512,"^::",["^U",["^:;","^:A"]],"^9",512,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Return the last non-whitespace (but possibly comment) element inside\n  of this zloc."],"~$zdotdotdot",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",579,"^8",7,"^9",579,"^:",17,"^:2",["^1N",["^:3",["^1N",[[]]]]],"^:5","Return a zloc that will turn into a string of three dots."],"^V","^3Z","^6","zprint/zutil.cljc","^:",17,"^:6",["^1N",[[]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",579,"^::","^:;","^9",579,"^:<",0,"^:=",true,"^:2",["^1N",["^:3",["^1N",[[]]]]],"^:5","Return a zloc that will turn into a string of three dots."],"~$znthnext",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",184,"^8",7,"^9",184,"^:",15,"^:2",["^1N",["^:3",["^1N",[["^:?","~$n"]]]]],"^:5","Find the nth non-whitespace zloc inside of this zloc."],"^V","^3[","^6","zprint/zutil.cljc","^:",15,"^:6",["^1N",[["^:?","~$n"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",184,"^::","^:;","^9",184,"^:<",2,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?","~$n"]]]]],"^:5","Find the nth non-whitespace zloc inside of this zloc."],"~$znil?",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",545,"^8",7,"^9",545,"^:",12,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Returns true if this is nil."],"^V","^41","^6","zprint/zutil.cljc","^:",12,"^:6",["^1N",[["^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",545,"^::",["^U",[null,"^:@"]],"^9",545,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Returns true if this is nil."],"~$zsymbol?",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",539,"^8",7,"^9",539,"^:",15,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Returns true if this is a symbol."],"^V","^3V","^6","zprint/zutil.cljc","^:",15,"^:6",["^1N",[["^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",539,"^::",["^U",[null,"^:@"]],"^9",539,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Returns true if this is a symbol."],"~$zreader-cond-w-coll?",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",565,"^8",7,"^9",565,"^:",27,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Returns true if this is a reader-conditional with a collection in \n  the first position (could be :clj or :cljs, whatever)."],"^V","^2G","^6","zprint/zutil.cljc","^:",27,"^:6",["^1N",[["^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",565,"^::",["^U",["^:@","^:A"]],"^9",565,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Returns true if this is a reader-conditional with a collection in \n  the first position (could be :clj or :cljs, whatever)."],"~$zmeta?",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",62,"^8",7,"^9",62,"^:",13,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Is this a ^{...}"],"^V","^4;","^6","zprint/zutil.cljc","^:",13,"^:6",["^1N",[["^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",62,"^::","^:@","^9",62,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Is this a ^{...}"],"~$add-spec-to-docstring",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",632,"^8",7,"^9",632,"^:",28,"^:2",["^1N",["^:3",["^1N",[["^:?","~$spec-str"]]]]],"^:5","Given a zipper of a function definition, add the spec info to\n  the docstring. Works for docstring with (def ...) functions, but\n  the left-indent isn't optimal.  But to fix that, we'd have to do\n  the zprinting here, where we know the indent of the existing\n  docstring."],"^V","^42","^6","zprint/zutil.cljc","^:",28,"^:6",["^1N",[["^:?","^;="]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",632,"^::",["^U",[null,"^:;"]],"^9",632,"^:<",2,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?","^;="]]]]],"^:5","Given a zipper of a function definition, add the spec info to\n  the docstring. Works for docstring with (def ...) functions, but\n  the left-indent isn't optimal.  But to fix that, we'd have to do\n  the zprinting here, where we know the indent of the existing\n  docstring."],"~$zfocus",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",47,"^8",7,"^9",47,"^:",13,"^:2",["^1N",["^:3",["^1N",[["^:?","~$floc"]]]]],"^:5","Is the zipper zloc equivalent to the path floc.  In this\n  case, floc isn't a zipper, but was turned into a path early on."],"^V","^44","^6","zprint/zutil.cljc","^:",13,"^:6",["^1N",[["^:?","^;?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",47,"^::","^:@","^9",47,"^:<",2,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?","^;?"]]]]],"^:5","Is the zipper zloc equivalent to the path floc.  In this\n  case, floc isn't a zipper, but was turned into a path early on."],"~$zfirst",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",99,"^8",7,"^9",99,"^:",13,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Find the first non-whitespace zloc inside of this zloc, or\n  the first whitespace zloc that is the focus."],"^V","^47","^6","zprint/zutil.cljc","^:",13,"^:6",["^1N",[["^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",99,"^::",["^U",["^:;","^:A"]],"^9",99,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Find the first non-whitespace zloc inside of this zloc, or\n  the first whitespace zloc that is the focus."],"~$zsexpr?",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",518,"^8",7,"^9",518,"^:",14,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Returns true if this can be converted to an sexpr. Works around a bug\n  where n/printable-only? returns false for n/tag :fn, but z/sexpr fails\n  on something with n/tag :fn"],"^V","^4R","^6","zprint/zutil.cljc","^:",14,"^:6",["^1N",[["^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",518,"^::",["^U",[null,"^:@"]],"^9",518,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Returns true if this can be converted to an sexpr. Works around a bug\n  where n/printable-only? returns false for n/tag :fn, but z/sexpr fails\n  on something with n/tag :fn"],"~$zcount",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",398,"^8",7,"^9",398,"^:",13,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Return the count of non-whitespace elements in zloc.  Comments are\n  counted as one thing, commas are ignored as whitespace."],"^V","^4H","^6","zprint/zutil.cljc","^:",13,"^:6",["^1N",[["^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",398,"^::","~$number","^9",398,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Return the count of non-whitespace elements in zloc.  Comments are\n  counted as one thing, commas are ignored as whitespace."],"~$zstart",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",97,"^8",7,"^9",97,"^:",13,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Find the zloc inside of this zloc."],"^V","^4?","^6","zprint/zutil.cljc","^:",13,"^:6",["^1N",[["^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",97,"^::",["^U",["^:J","^:L","^:A"]],"^9",97,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Find the zloc inside of this zloc."],"~$zrightnws",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",138,"^8",7,"^9",138,"^:",16,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Find the next non-whitespace zloc inside of this zloc. Returns nil\n  if nothing left."],"^V","^4B","^6","zprint/zutil.cljc","^:",16,"^:6",["^1N",[["^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",138,"^::",["^U",["^:;","^:A"]],"^9",138,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Find the next non-whitespace zloc inside of this zloc. Returns nil\n  if nothing left."],"~$zreader-macro?",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",69,"^8",7,"^9",69,"^:",21,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Is this a @..."],"^V","^4L","^6","zprint/zutil.cljc","^:",21,"^:6",["^1N",[["^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",69,"^::","^:@","^9",69,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Is this a @..."],"~$zthird",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",118,"^8",7,"^9",118,"^:",13,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Find the third non-whitespace zloc inside of this zloc."],"^V","^5=","^6","zprint/zutil.cljc","^:",13,"^:6",["^1N",[["^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",118,"^::",["^U",["^:;","^:A"]],"^9",118,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Find the third non-whitespace zloc inside of this zloc."],"~$zseqnws-w-bl",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",428,"^8",7,"^9",428,"^:",19,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Return a seq of all of the non-whitespace children of zloc, including\n  only newlines that start and end blank lines."],"^V","^4S","^6","zprint/zutil.cljc","^:",19,"^:6",["^1N",[["^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",428,"^::","^:;","^9",428,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Return a seq of all of the non-whitespace children of zloc, including\n  only newlines that start and end blank lines."],"~$find-root-and-path-nw",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",476,"^8",7,"^9",476,"^:",28,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Create a vector with the root as well as another vector\n  which contains the number of right moves after each down\n  down to find a particular zloc.  The right moves are\n  non-whitespace, but include comments."],"^V","^4K","^6","zprint/zutil.cljc","^:",28,"^:6",["^1N",[["^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",476,"^::",["^U",["^:K","^:A"]],"^9",476,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Create a vector with the root as well as another vector\n  which contains the number of right moves after each down\n  down to find a particular zloc.  The right moves are\n  non-whitespace, but include comments."],"~$zmap-w-bl",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",219,"^8",7,"^9",219,"^:",16,"^:2",["^1N",["^:3",["^1N",[["^:G","^:?"]]]]],"^:5","Return a vector containing the return of applying a function to\n  every non-whitespace zloc inside of zloc, including two newlines\n  for every blank line encountered.  Note that a truly blank line\n  will show up as one zloc with two newlines in it.  It will have\n  (= (z/tag nloc) :newline), but it will have both newlines.  To\n  ease handling of these multi-line newlines, this routine will\n  split them up into multiple individual newlines."],"^V","^4N","^6","zprint/zutil.cljc","^:",16,"^:6",["^1N",[["^:G","^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",219,"^::","^:;","^9",219,"^:<",2,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:G","^:?"]]]]],"^:5","Return a vector containing the return of applying a function to\n  every non-whitespace zloc inside of zloc, including two newlines\n  for every blank line encountered.  Note that a truly blank line\n  will show up as one zloc with two newlines in it.  It will have\n  (= (z/tag nloc) :newline), but it will have both newlines.  To\n  ease handling of these multi-line newlines, this routine will\n  split them up into multiple individual newlines."],"~$whitespace-not-newline?",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",30,"^8",7,"^9",30,"^:",30,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]]],"^V","^5>","^6","zprint/zutil.cljc","^:",30,"^:6",["^1N",[["^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",30,"^::","^:@","^9",30,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]]],"~$zmap-no-comment",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",367,"^8",7,"^9",367,"^:",22,"^:2",["^1N",["^:3",["^1N",[["^:G","^:?"]]]]],"^:5","Return a vector containing the return of applying a function to \n  every non-whitespace zloc inside of zloc. Comments are considered\n  whitespace for this routine, and left out."],"^V","^54","^6","zprint/zutil.cljc","^:",22,"^:6",["^1N",[["^:G","^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",367,"^::",["^U",["^:J","^:K"]],"^9",367,"^:<",2,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:G","^:?"]]]]],"^:5","Return a vector containing the return of applying a function to \n  every non-whitespace zloc inside of zloc. Comments are considered\n  whitespace for this routine, and left out."],"~$zlift-ns",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",660,"^8",7,"^9",660,"^:",15,"^:2",["^1N",["^:3",["^1N",[[["^ ","~:keys",["~$in-code?","~$lift-ns?","~$lift-ns-in-code?","~$unlift-ns?"],"^1P","~$map-options"],"~$pair-seq","^1O"]]]]],"^:5","Perform a lift-ns on a pair-seq that is returned from\n  partition-2-all-nc, which is a seq of pairs of zlocs that may or\n  may not have been sorted and which may or may not have had things\n  removed from it and may or may not actually be pairs.  Could be\n  single things, could be multiple things.  If contains multiple\n  things, the first thing is the key, but if it is just a single\n  thing, the first thing is *not* a key. So we only need to work\n  on the first of each seq which has more than one element in it,\n  and possibly replace it. This will only lift out a ns if all keys\n  in seqs with more than one element have the same namespace. Returns\n  the [namespace pair-seq] or nil."],"^V","^57","^6","zprint/zutil.cljc","^:",15,"^:6",["^1N",[["~$p__42049","^;T","^1O"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",660,"^::",["^U",["^:K","^:A"]],"^9",660,"^:<",3,"^:=",true,"^:2",["^1N",["^:3",["^1N",[[["^ ","^;N",["^;O","^;P","^;Q","^;R"],"^1P","^;S"],"^;T","^1O"]]]]],"^:5","Perform a lift-ns on a pair-seq that is returned from\n  partition-2-all-nc, which is a seq of pairs of zlocs that may or\n  may not have been sorted and which may or may not have had things\n  removed from it and may or may not actually be pairs.  Could be\n  single things, could be multiple things.  If contains multiple\n  things, the first thing is the key, but if it is just a single\n  thing, the first thing is *not* a key. So we only need to work\n  on the first of each seq which has more than one element in it,\n  and possibly replace it. This will only lift out a ns if all keys\n  in seqs with more than one element have the same namespace. Returns\n  the [namespace pair-seq] or nil."],"~$zsecond",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",112,"^8",7,"^9",112,"^:",14,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Find the second non-whitespace zloc inside of this zloc."],"^V","^51","^6","zprint/zutil.cljc","^:",14,"^:6",["^1N",[["^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",112,"^::",["^U",["^:;","^:A"]],"^9",112,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Find the second non-whitespace zloc inside of this zloc."],"~$move-down-and-right",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",495,"^8",7,"^9",495,"^:",26,"^:2",["^1N",["^:3",["^1N",[["^:?","~$right-count"]]]]],"^:5","Move one down and then right a certain number of steps."],"^V","^5:","^6","zprint/zutil.cljc","^:",26,"^:6",["^1N",[["^:?","^;X"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",495,"^::","^:;","^9",495,"^:<",2,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?","^;X"]]]]],"^:5","Move one down and then right a certain number of steps."],"~$skip-whitespace",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",26,"^8",7,"^9",26,"^:",22,"^:2",["^1N",["^:3",["^1N",[["^:?"],["~$f","^:?"]]]]],"~:top-fn",["^ ","^:9",false,"~:fixed-arity",2,"^:<",2,"^:6",[["^:?"],["~$f","^:?"]],"^:2",["^1N",[["^:?"],["~$f","^:?"]]],"^:8",["^1N",[null,null]]]],"^V","^58","^6","zprint/zutil.cljc","^:",22,"^;Z",["^ ","^:9",false,"^;[",2,"^:<",2,"^:6",[["^:?"],["~$f","^:?"]],"^:2",["^1N",[["^:?"],["~$f","^:?"]]],"^:8",["^1N",[null,null]]],"^:6",[["^:?"],["~$f","^:?"]],"^:7",null,"^;[",2,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"~:methods",[["^ ","^;[",1,"^:9",false,"~:tag","^:;"],["^ ","^;[",2,"^:9",false,"^<1",["^U",["^:;","^:A"]]]],"^7",26,"^9",26,"^:<",2,"^:=",true,"^:2",["^1N",[["^:?"],["~$f","^:?"]]]],"~$zloc-to-keyword",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",650,"^8",7,"^9",650,"^:",22,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Given a zloc, turn it into a keyword if it starts with a :, but remove\n  the : first."],"^V","^5Z","^6","zprint/zutil.cljc","^:",22,"^:6",["^1N",[["^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",650,"^::",["^U",["^:;","~$cljs.core/Keyword","^5R","^:A"]],"^9",650,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Given a zloc, turn it into a keyword if it starts with a :, but remove\n  the : first."],"~$zfocus-style",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",53,"^8",7,"^9",53,"^:",19,"^:2",["^1N",["^:3",["^1N",[["~$style","^:?","^;?"]]]]],"^:5","Take the various inputs and come up with a style."],"^V","^5O","^6","zprint/zutil.cljc","^:",19,"^:6",["^1N",[["^<5","^:?","^;?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",53,"^::",["^U",[null,"^<3"]],"^9",53,"^:<",3,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^<5","^:?","^;?"]]]]],"^:5","Take the various inputs and come up with a style."],"~$zleftnws",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",159,"^8",7,"^9",159,"^:",15,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Find the next non-whitespace zloc inside of this zloc."],"^V","^5F","^6","zprint/zutil.cljc","^:",15,"^:6",["^1N",[["^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",159,"^::",["^U",["^:;","^:A"]],"^9",159,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Find the next non-whitespace zloc inside of this zloc."],"~$zmap-all",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",409,"^8",7,"^9",409,"^:",15,"^:2",["^1N",["^:3",["^1N",[["^:G","^:?"]]]]],"^:5","Return a vector containing the return of applying a function to \n  every zloc inside of zloc."],"^V","^5U","^6","zprint/zutil.cljc","^:",15,"^:6",["^1N",[["^:G","^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",409,"^::",["^U",["^:J","^:K"]],"^9",409,"^:<",2,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:G","^:?"]]]]],"^:5","Return a vector containing the return of applying a function to \n  every zloc inside of zloc."],"~$zmap",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",347,"^8",7,"^9",347,"^:",11,"^:2",["^1N",["^:3",["^1N",[["^:G","^:?"]]]]],"^:5","Return a vector containing the return of applying a function to \n  every non-whitespace zloc inside of zloc. The newline that shows\n  up in every comment is also split out into a separate zloc."],"^V","^5W","^6","zprint/zutil.cljc","^:",11,"^:6",["^1N",[["^:G","^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",347,"^::",["^U",["^:J","^:K"]],"^9",347,"^:<",2,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:G","^:?"]]]]],"^:5","Return a vector containing the return of applying a function to \n  every non-whitespace zloc inside of zloc. The newline that shows\n  up in every comment is also split out into a separate zloc."],"~$ztag",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",71,"^8",7,"^9",71,"^:",11,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Return the tag for this zloc"],"^V","^5S","^6","zprint/zutil.cljc","^:",11,"^:6",["^1N",[["^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",71,"^::",["^U",["^:;","^:A"]],"^9",71,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Return the tag for this zloc"],"~$zredef-call",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",764,"^8",7,"^9",764,"^:",18,"^:2",["^1N",["^:3",["^1N",[["~$body-fn"]]]]],"^:5","Redefine all of the traversal functions for zippers, then\n  call the function of no arguments passed in."],"^V","^4P","^6","zprint/zutil.cljc","^:",18,"^:6",["^1N",[["^<;"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",764,"^9",764,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^<;"]]]]],"^:5","Redefine all of the traversal functions for zippers, then\n  call the function of no arguments passed in."],"~$zseqnws",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",417,"^8",7,"^9",417,"^:",14,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Return a seq of all of the non-whitespace children of zloc."],"^V","^6;","^6","zprint/zutil.cljc","^:",14,"^:6",["^1N",[["^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",417,"^::",["^U",["^:J","^:K"]],"^9",417,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Return a seq of all of the non-whitespace children of zloc."],"~$find-doc-in-map",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",612,"^8",7,"^9",612,"^:",22,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Given a zloc zipper of a map, find the :doc element."],"^V","^6:","^6","zprint/zutil.cljc","^:",22,"^:6",["^1N",[["^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",612,"^::",["^U",["^:;","^:A"]],"^9",612,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Given a zloc zipper of a map, find the :doc element."],"~$zmap-w-nl",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",284,"^8",7,"^9",284,"^:",16,"^:2",["^1N",["^:3",["^1N",[["^:G","^:?"]]]]],"^:5","Return a vector containing the return of applying a function to\n  every non-whitespace zloc inside of zloc, including newlines.\n  This will also split newlines into separate zlocs if they were\n  multiple, and split the newline off the end of a comment. The\n  comment split actually changes the zipper for the rest of the\n  sequence, where the newline splits do not."],"^V","^6H","^6","zprint/zutil.cljc","^:",16,"^:6",["^1N",[["^:G","^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",284,"^::","^:;","^9",284,"^:<",2,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:G","^:?"]]]]],"^:5","Return a vector containing the return of applying a function to\n  every non-whitespace zloc inside of zloc, including newlines.\n  This will also split newlines into separate zlocs if they were\n  multiple, and split the newline off the end of a comment. The\n  comment split actually changes the zipper for the rest of the\n  sequence, where the newline splits do not."],"~$znl",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",200,"^8",7,"^9",200,"^:",10,"^:2",["^1N",["^:3",["^1N",[[]]]]]],"^V","^4J","^6","zprint/zutil.cljc","^:",10,"^:6",["^1N",[[]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",200,"^::","^:;","^9",200,"^:<",0,"^:=",true,"^:2",["^1N",["^:3",["^1N",[[]]]]]],"~$find-root",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",490,"^8",7,"^9",490,"^:",16,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Find the root from a zloc by doing lots of ups."],"^V","^6D","^6","zprint/zutil.cljc","^:",16,"^:6",["^1N",[["^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",490,"^9",490,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Find the root from a zloc by doing lots of ups."],"~$zuneval?",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",60,"^8",7,"^9",60,"^:",15,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Is this a #_(...)"],"^V","^6E","^6","zprint/zutil.cljc","^:",15,"^:6",["^1N",[["^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",60,"^::","^:@","^9",60,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Is this a #_(...)"],"~$zfind",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",191,"^8",7,"^9",191,"^:",12,"^:2",["^1N",["^:3",["^1N",[["~$zthing?","^:?"]]]]],"^:5","Find the locations (counting from zero, and only counting non-whitespace\n  elements) of the first zthing?.  Return its index if it is found, nil if not."],"^V","^6F","^6","zprint/zutil.cljc","^:",12,"^:6",["^1N",[["^<C","^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",191,"^::",["^U",["^;C","^:A"]],"^9",191,"^:<",2,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^<C","^:?"]]]]],"^:5","Find the locations (counting from zero, and only counting non-whitespace\n  elements) of the first zthing?.  Return its index if it is found, nil if not."],"~$zquote?",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",64,"^8",7,"^9",64,"^:",14,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Is this a '(...) or '[ ... ] or some other quote?"],"^V","^6?","^6","zprint/zutil.cljc","^:",14,"^:6",["^1N",[["^:?"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",64,"^::","^:@","^9",64,"^:<",1,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?"]]]]],"^:5","Is this a '(...) or '[ ... ] or some other quote?"],"~$znumstr",["^ ","^:1",null,"^5",["^ ","^6","zprint/zutil.cljc","^7",90,"^8",7,"^9",90,"^:",14,"^:2",["^1N",["^:3",["^1N",[["^:?","~$_","~$_"]]]]],"^:5","Does z/string, but takes an additional argument for hex conversion.\n  Hex conversion is not implemented for zippers, though, because at present\n  it is only used for byte-arrays, which don't really show up here."],"^V","^4D","^6","zprint/zutil.cljc","^:",14,"^:6",["^1N",[["^:?","~$_","~$_"]]],"^:7",null,"^:8",["^1N",[null,null]],"^8",1,"^:9",false,"^7",90,"^::",["^U",["^:;","^:A"]],"^9",90,"^:<",3,"^:=",true,"^:2",["^1N",["^:3",["^1N",[["^:?","~$_","~$_"]]]]],"^:5","Does z/string, but takes an additional argument for hex conversion.\n  Hex conversion is not implemented for zippers, though, because at present\n  it is only used for byte-arrays, which don't really show up here."]],"^1L",["^ ","^14","^14","^13","^13","~$z","^13"],"~:cljs.analyzer/constants",["^ ","^18",["^U",["~:in-code?","~:fn","~:namespaced-map","^5","~:whitespace","~:else","~:reader-macro","~:unquote","~:comma","~:uneval","~:lift-ns-in-code?","~:token","~:syntax-quote","~:quote","~:comment","~:lift-ns?","~:b","~:f","~:newline","~:unlift-ns?"]],"~:order",["^<J","^<V","^<N","~:f","~:b","^<O","^5","^<S","^<L","^<I","^<T","^<K","^<H","^<Q","^<M","^<R","^<G","^<U","^<P","^<W"]],"^1R",["^ ","^19",["^U",[]]],"^1S",["^ "],"^1T",["^15","^14","^17","^16","^11","^12","^13"]],"^Z","^W","~:ns-specs",["^ "],"~:ns-spec-vars",["^U",[]],"~:compiler-options",["^6J",[["^<[","~:static-fns"],true,["^<[","~:shadow-tweaks"],null,["^<[","~:source-map-inline"],null,["^<[","~:elide-asserts"],false,["^<[","~:optimize-constants"],null,["^<[","^1Y"],null,["^<[","~:external-config"],null,["^<[","~:tooling-config"],null,["^<[","~:emit-constants"],null,["^<[","~:load-tests"],null,["^<[","~:form-size-threshold"],null,["^<[","~:global-goog-object&array"],null,["^<[","~:data-readers"],null,["^<[","~:infer-externs"],"~:auto",["^<[","^1["],null,["~:js-options","~:js-provider"],"~:shadow",["~:mode"],"~:dev",["^<[","~:fn-invoke-direct"],null,["^<[","~:source-map"],"/dev/null"]]]